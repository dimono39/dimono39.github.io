<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>?? Система анализа образовательных результатов</title>
    
    <!-- Bootstrap 5 -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Bootstrap Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css">
    
    <!-- Библиотеки -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.2.1/dist/chartjs-plugin-annotation.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
    <script src="https://unpkg.com/html-docx-js@0.3.1/dist/html-docx.js"></script>
    
    <style>
        /* Основные стили */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        /* Шапка */
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .subtitle {
            opacity: 0.9;
            font-size: 1.1em;
        }

        /* Вкладки */
        .tabs {
            background: #34495e;
            padding: 0;
            display: flex;
            flex-wrap: wrap;
        }

        .tab-btn {
            background: none;
            color: white;
            border: none;
            padding: 15px 20px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 13px;
            flex: 1;
            min-width: 140px;
        }

        .tab-btn:hover {
            background: rgba(255,255,255,0.1);
        }

        .tab-btn.active {
            background: #3498db;
            box-shadow: inset 0 -3px 0 #2980b9;
        }

        .tab-content {
            display: none;
            padding: 25px;
            min-height: 600px;
        }

        .tab-content.active {
            display: block;
        }

        /* Прогресс бар */
        .progress-container {
            padding: 20px 30px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
        }

        .progress-bar {
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .progress-text {
            font-size: 0.9em;
            color: #666;
            text-align: center;
        }

        /* Мастер настройки */
        .setup-wizard {
            padding: 30px;
        }

        .wizard-step {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .wizard-step.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Шаги */
        .step-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .step-number {
            background: #667eea;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.2em;
        }

        .step-description {
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        /* Карточки типов работ */
        .worktype-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .worktype-card {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 15px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .worktype-card:hover {
            border-color: #667eea;
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.2);
        }

        .worktype-card.selected {
            border-color: #4CAF50;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        }

        .worktype-icon {
            font-size: 2.5em;
            margin-bottom: 15px;
        }

        .worktype-card h3 {
            color: #333;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .worktype-card p {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 15px;
            line-height: 1.4;
        }

        .worktype-details {
            display: flex;
            gap: 15px;
            color: #888;
            font-size: 0.85em;
        }

        /* Карточки настроек */
        .settings-card {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            border-left: 5px solid #667eea;
            animation: slideIn 0.4s ease;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .card-title {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.3em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Формы */
        .form-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        label.required::after {
            content: " *";
            color: #e74c3c;
        }

        .form-input, .form-select, .form-textarea {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            transition: all 0.3s ease;
            background: white;
        }

        .form-input:focus, .form-select:focus, .form-textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .form-textarea {
            resize: vertical;
            min-height: 100px;
        }

        .form-hint {
            color: #666;
            font-size: 0.85em;
            margin-top: 5px;
            display: block;
        }

        /* Кнопки */
        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-success {
            background: linear-gradient(135deg, #4CAF50 0%, #8BC34A 100%);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
            color: white;
        }

        .btn-outline {
            background: white;
            border: 2px solid #667eea;
            color: #667eea;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .btn-icon {
            padding: 10px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .btn-icon:hover {
            background: #5a6fd8;
        }

        /* Навигация шагов */
        .step-navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }

        /* Карточка с информацией */
        .info-card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            border: 2px solid #e9ecef;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .info-item {
            display: flex;
            flex-direction: column;
        }

        .info-label {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
        }

        .info-value {
            font-weight: 600;
            color: #333;
        }

        /* Статистика посещаемости */
        .attendance-stats {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }

        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            min-width: 120px;
            border: 2px solid #e9ecef;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            color: #666;
            font-size: 0.9em;
        }

        /* Критерии */
        .criteria-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .criteria-type-selector {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .criteria-presets {
            background: white;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
        }

        .preset-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        .preset-btn {
            padding: 8px 15px;
            background: #f8f9fa;
            border: 2px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .preset-btn:hover {
            border-color: #667eea;
            background: #eef1ff;
        }

        .criteria-controls {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .recommendation-card {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
        }

        .recommendation-card ul {
            margin: 10px 0 0 20px;
        }

        .recommendation-card li {
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        /* Модальные окна */


		.modal-actions {
			display: flex;
			gap: 10px;
			justify-content: flex-end;
			margin-top: 20px;
		}
		.modal-overlay.show {
			display: flex;
		}
		.modal-overlay {
			position: fixed;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background: rgba(0,0,0,0.5);
			display: none;
			justify-content: center;
			align-items: center;
			z-index: 2000;
		}
        .modal-content {
			background: white;
			padding: 30px;
			border-radius: 15px;
			max-width: 500px;
			width: 90%;
			max-height: 80vh;
			overflow-y: auto;
			animation: modalSlideIn 0.3s ease;
			box-shadow: 0 20px 40px rgba(0,0,0,0.3);
			margin: 20px;
		}

		@keyframes modalSlideIn {
			from { transform: translateY(-50px); opacity: 0; }
			to { transform: translateY(0); opacity: 1; }
		}
		.modal-content.success {
			text-align: center;
		}

		.modal-icon {
			font-size: 4em;
			margin-bottom: 20px;
		}

		.modal-actions {
			display: flex;
			gap: 10px;
			justify-content: flex-end;
			margin-top: 20px;
		}

        /* Критерии оценивания */
        .criteria-grid {
            background: white;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #e9ecef;
            margin-bottom: 20px;
        }

        .criteria-row {
            display: grid;
            grid-template-columns: 150px 150px 1fr;
            gap: 15px;
            padding: 12px 15px;
            border-bottom: 1px solid #f1f1f1;
            align-items: center;
        }

        .criteria-row.header {
            background: #f8f9fa;
            font-weight: bold;
            color: #333;
        }

        .criteria-grade {
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .criteria-range {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .criteria-range input {
            width: 70px;
            padding: 6px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .criteria-range input:disabled {
            background: #f5f5f5;
            cursor: not-allowed;
        }

        .criteria-description input {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .grade-badge {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        .grade-5 { background: #4CAF50; }
        .grade-4 { background: #8BC34A; }
        .grade-3 { background: #FFC107; }
        .grade-2 { background: #F44336; }
        .level-high { background: #4CAF50; }
        .level-medium { background: #FFC107; }
        .level-low { background: #F44336; }

        .criteria-action {
            display: flex;
            gap: 5px;
        }

        .btn-icon.small {
            padding: 4px 8px;
            font-size: 12px;
        }

        .btn-icon.small.danger {
            background: #F44336;
        }

        .preview-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .preview-item {
            background: white;
            border-radius: 8px;
            padding: 15px;
            border: 2px solid #e9ecef;
            text-align: center;
            transition: all 0.3s ease;
        }

        .preview-item:hover {
            border-color: #667eea;
            transform: translateY(-2px);
        }

        .preview-grade {
            font-size: 1.8em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .preview-range {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        .preview-desc {
            font-size: 0.85em;
            color: #333;
            line-height: 1.4;
        }

        .input-with-button {
            display: flex;
            gap: 10px;
        }

        .input-with-button input {
            flex: 1;
        }

        .form-control-large {
            padding: 12px;
            font-size: 16px;
            width: 100%;
        }

        /* Адаптивность */
        @media (max-width: 768px) {
            .worktype-grid {
                grid-template-columns: 1fr;
            }
            
            .form-row {
                grid-template-columns: 1fr;
            }
            
            .step-navigation {
                flex-direction: column;
                gap: 10px;
            }
            
            .btn {
                width: 100%;
            }
            
            .container {
                border-radius: 10px;
            }
            
            .header {
                padding: 20px;
            }
            
            .setup-wizard {
                padding: 20px;
            }
            
            .tabs {
                flex-direction: column;
            }
            
            .tab-btn {
                min-width: 100%;
                font-size: 12px;
                padding: 12px 15px;
            }
            
            .criteria-row {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            
            .preview-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Для очень маленьких экранов */
        @media (max-width: 480px) {
            .tab-btn {
                padding: 10px 15px;
                font-size: 14px;
            }
        }

        /* Стили для элементов печати */
        @media print {
            .no-print {
                display: none !important;
            }
            
            .print-only {
                display: block !important;
            }
            
            .avoid-page-break {
                page-break-inside: avoid;
            }
            
            .force-page-break {
                page-break-before: always;
            }
        }

        /* Классы для управления печатью в основном интерфейсе */
        .print-ignore {
            display: none !important;
        }

        .print-chart {
            max-width: 100%;
            height: auto;
        }

        /* Основные стили для печати на странице отчета */
        @media print {
            @page {
                margin: 15mm;
            }
            
            body {
                font-size: 12pt !important;
                line-height: 1.5 !important;
            }
            
            .no-print {
                display: none !important;
            }
            
            .print-break {
                page-break-before: always;
            }
            
            .avoid-break {
                page-break-inside: avoid;
            }
        }

        /* Уведомления */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 8px;
            color: white;
            z-index: 10000;
            transform: translateX(120%);
            transition: transform 0.3s ease;
            max-width: 400px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.info {
            background: #3498db;
        }

        .notification.success {
            background: #2ecc71;
        }

        .notification.warning {
            background: #f39c12;
        }

        .notification.error {
            background: #e74c3c;
        }

        /* Улучшенные стили для печати */
        @media print {
            /* Скрываем непечатаемые элементы */
            .no-print, .tabs, .tab-btn, .btn, .search-box, 
            input, select, textarea, .modal-overlay, .notification {
                display: none !important;
            }
            
            /* Базовые настройки страницы */
            @page {
                size: A4;
                margin: 15mm;
                orphans: 3;
                widows: 3;
            }
            
            /* Настройки для всех страниц */
            body {
                font-size: 12pt !important;
                line-height: 1.4 !important;
                color: black !important;
                background: white !important;
                padding: 0 !important;
                margin: 0 !important;
            }
            
            /* Контейнер для А4 */
            .container {
                width: 210mm !important;
                max-width: 210mm !important;
                min-height: 297mm !important;
                margin: 0 !important;
                padding: 0 !important;
                box-shadow: none !important;
                border: none !important;
                background: white !important;
            }
        }

        .section-title {
            color: #2c3e50;
            margin: 20px 0 15px 0;
            padding-bottom: 8px;
            border-bottom: 2px solid #3498db;
            font-size: 1.3em;
        }

        /* Экспортные кнопки */
        .export-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin: 15px 0;
        }

        /* Графики */
        .chart-container {
            background: white;
            padding: 15px;
            margin: 15px 0;
            border-radius: 8px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
            position: relative;
        }

        .chart-legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
        }

        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 3px;
        }

        /* KPI карточки */
        .kpi-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }

        .kpi-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
            border-left: 4px solid #3498db;
        }

        .kpi-card.success { border-left-color: #27ae60 !important; }
        .kpi-card.warning { border-left-color: #f39c12 !important; }
        .kpi-card.danger { border-left-color: #e74c3c !important; }

        .kpi-card.success .kpi-value { color: #27ae60; }
        .kpi-card.warning .kpi-value { color: #f39c12; }
        .kpi-card.danger .kpi-value { color: #e74c3c; }

        .kpi-value {
            font-size: 1.6em;
            font-weight: bold;
            color: #2c3e50;
            margin: 8px 0;
        }

        .kpi-label {
            color: #7f8c8d;
            font-size: 0.85em;
        }

        /* Таблицы */
        .table-container {
            overflow-x: auto;
            margin: 15px 0;
            font-size: 13px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            font-size: 13px;
        }

        th, td {
            padding: 10px 12px;
            text-align: left;
            border-bottom: 1px solid #ecf0f1;
        }

        th {
            background: #34495e;
            color: white;
            font-weight: 600;
            cursor: pointer;
            font-size: 12px;
        }

        th:hover {
            background: #2c3e50;
        }

        tr:nth-child(even) {
            background: #f8f9fa;
        }

        tr:hover {
            background: #e8f4fc;
        }

        /* Поиск */
        .search-box {
            width: 100%;
            padding: 10px;
            margin: 8px 0;
            border: 2px solid #3498db;
            border-radius: 20px;
            font-size: 14px;
        }

        .print-only {
            display: none;
        }

        .print-controls {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #3498db;
        }

        .btn-print {
            background: #9b59b6;
            color: white;
        }

        .btn-print:hover {
            background: #8e44ad;
        }

        /* QR-код */
        .qr-code-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9999;
        }

        .qr-code-tooltip {
            position: relative;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            cursor: help;
            transition: all 0.3s;
            text-align: center;
        }

        .qr-code-tooltip:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(0,0,0,0.4);
        }

        .qr-code-tooltip:hover .qr-code-image {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .qr-code-image {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 10px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s;
            z-index: 10000;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .qr-code-image img {
            width: 150px;
            height: 150px;
            border: 2px solid #3498db;
            border-radius: 5px;
        }

        @media (max-width: 768px) {
            .qr-code-container {
                top: 10px;
                right: 10px;
            }
            
            .qr-code-tooltip {
                font-size: 11px;
                padding: 8px 12px;
            }
        }
		
    </style>
</head>
<body>
    <!-- Модальные окна -->
    <div class="modal-overlay" id="modalOverlay">
       <div class="modal-content" id="modalContent"></div>
    </div>

    <!-- Уведомления -->
    <div class="notification" id="notification"></div>

    <div class="container">
        <div class="header">
            <h1>?? Система анализа образовательных результатов</h1>
            <p>Профессиональный анализ результатов контрольных, ВПР, ОГЭ, ЕГЭ и функциональной грамотности</p>
        </div>
        
        <div class="tabs no-print">
            <button class="tab-btn active" onclick="showTab('setup')">?? Настройки работы</button>
            <button class="tab-btn" onclick="showTab('tasks')">?? Таксономия заданий</button>
            <button class="tab-btn" onclick="showTab('students')">?? Учащиеся</button>
            <button class="tab-btn" onclick="showTab('results')">?? Результаты и ошибки</button>
            <button class="tab-btn" onclick="showTab('analytics')">?? Аналитика</button>
            <button class="tab-btn" onclick="showTab('visualization')">?? Визуализация</button>
            <button class="tab-btn" onclick="showTab('recommendations')">?? Рекомендации</button>
            <button class="tab-btn" onclick="showTab('export')">?? Экспорт</button>
        </div>

        <!-- Вкладка настройки теста -->
        <div id="setup" class="tab-content active">
            <header class="header">
                <h1>?? Конструктор диагностических работ</h1>
                <p class="subtitle">Настройте параметры работы для быстрого анализа результатов</p>
            </header>

            <!-- Индикатор прогресса -->
            <div class="progress-container">
                <div class="progress-bar">
                    <div class="progress-fill" id="setupProgress" style="width: 10%;"></div>
                </div>
                <div class="progress-text" id="progressText">Начните с выбора типа работы</div>
            </div>

            <div class="setup-wizard">
                <!-- Шаг 1: Тип работы -->
                <div class="wizard-step active" id="step1">
                    <div class="step-header">
                        <span class="step-number">1</span>
                        <h2>?? Выберите тип работы</h2>
                    </div>
                    <p class="step-description">Это определит остальные настройки и критерии оценивания</p>
                    
                    <div class="worktype-grid">
                        <div class="worktype-card" onclick="selectWorkType('current')">
                            <div class="worktype-icon">??</div>
                            <h3>Текущая контрольная</h3>
                            <p>Оценка знаний по текущей теме</p>
                            <div class="worktype-details">
                                <span>? 40-45 мин</span>
                                <span>?? 10-15 заданий</span>
                            </div>
                        </div>
                        
                        <div class="worktype-card" onclick="selectWorkType('milestone')">
                            <div class="worktype-icon">??</div>
                            <h3>Рубежная</h3>
                            <p>Контроль за четверть/триместр</p>
                            <div class="worktype-details">
                                <span>? 80-90 мин</span>
                                <span>?? 20-25 заданий</span>
                            </div>
                        </div>
                        
                        <div class="worktype-card" onclick="selectWorkType('final')">
                            <div class="worktype-icon">??</div>
                            <h3>Итоговая</h3>
                            <p>Годовая контрольная работа</p>
                            <div class="worktype-details">
                                <span>? 90-120 мин</span>
                                <span>?? 25-30 заданий</span>
                            </div>
                        </div>
                        
                        <div class="worktype-card" onclick="selectWorkType('oge')">
                            <div class="worktype-icon">??</div>
                            <h3>ОГЭ</h3>
                            <p>Государственный экзамен 9 класс</p>
                            <div class="worktype-details">
                                <span>? 180-235 мин</span>
                                <span>?? Части 1 и 2</span>
                            </div>
                        </div>
                        
                        <div class="worktype-card" onclick="selectWorkType('ege')">
                            <div class="worktype-icon">??</div>
                            <h3>ЕГЭ</h3>
                            <p>Единый госэкзамен 11 класс</p>
                            <div class="worktype-details">
                                <span>? 180-235 мин</span>
                                <span>?? Части 1 и 2</span>
                            </div>
                        </div>
                        
                        <div class="worktype-card" onclick="selectWorkType('vpr')">
                            <div class="worktype-icon">??</div>
                            <h3>ВПР</h3>
                            <p>Всероссийская проверочная работа</p>
                            <div class="worktype-details">
                                <span>? 45-60 мин</span>
                                <span>?? Стандартный набор</span>
                            </div>
                        </div>
                        
                        <div class="worktype-card" onclick="selectWorkType('func_literacy')">
                            <div class="worktype-icon">??</div>
                            <h3>Функциональная грамотность</h3>
                            <p>Оценка практических навыков</p>
                            <div class="worktype-details">
                                <span>? 60-90 мин</span>
                                <span>?? Контекстные задания</span>
                            </div>
                        </div>
                        
                        <div class="worktype-card" onclick="selectWorkType('psychology')">
                            <div class="worktype-icon">??</div>
                            <h3>Психологическая диагностика</h3>
                            <p>Оценка личностных качеств</p>
                            <div class="worktype-details">
                                <span>? 40-60 мин</span>
                                <span>?? Тесты, анкеты</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="worktype-select-container" style="display: none;">
                        <label for="workType" class="section-label">Или выберите из списка:</label>
                        <select id="workType" class="form-control-large" onchange="updateWorkType(); scheduleAutoSave(); updateProgress();">
                            <option value="">-- Выберите тип работы --</option>
                            <option value="current">Текущая контрольная</option>
                            <option value="milestone">Рубежная</option>
                            <option value="final">Итоговая</option>
                            <option value="oge">ОГЭ</option>
                            <option value="ege">ЕГЭ</option>
                            <option value="vpr">ВПР</option>
                            <option value="func_literacy">Функциональная грамотность</option>
                            <option value="diagnostic">Диагностическая</option>
                            <option value="psychology">Психологическая диагностика</option>
                        </select>
                    </div>
                    
                    <div class="worktype-info" id="worktypeInfo" style="display: none;">
                        <div class="info-card">
                            <h4 id="selectedWorktypeTitle">Название типа</h4>
                            <p id="selectedWorktypeDesc">Описание типа работы</p>
                            <div class="info-grid">
                                <div class="info-item">
                                    <span class="info-label">Рекомендуемое время:</span>
                                    <span class="info-value" id="infoTime">45 минут</span>
                                </div>
                                <div class="info-item">
                                    <span class="info-label">Формат:</span>
                                    <span class="info-value" id="infoFormat">Тест</span>
                                </div>
                                <div class="info-item">
                                    <span class="info-label">Система оценивания:</span>
                                    <span class="info-value" id="infoGrading">5-балльная</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <button class="btn btn-primary btn-next" onclick="nextStep()" disabled id="nextStep1">
                        Далее > Основная информация
                    </button>
                </div>

                <!-- Шаг 2: Основная информация -->
                <div class="wizard-step" id="step2">
                    <div class="step-header">
                        <span class="step-number">2</span>
                        <h2>?? Основная информация</h2>
                    </div>
                    
                    <div class="settings-card">
                        <div class="form-row">
                            <div class="form-group">
                                <label for="subject" class="required">?? Предмет</label>
                                <input type="text" id="subject" placeholder="Например: Математика" 
                                       oninput="scheduleAutoSave(); updateProgress();" 
                                       class="form-input">
                                <small class="form-hint">Укажите учебный предмет</small>
                            </div>
                            
                            <div class="form-group">
                                <label for="class" class="required">?? Класс</label>
                                <input type="text" id="class" placeholder="Например: 5А" 
                                       oninput="scheduleAutoSave(); updateProgress();" 
                                       class="form-input">
                                <small class="form-hint">Укажите класс и параллель</small>
                            </div>
                        </div>
                        
                        <div class="form-row">
                            <div class="form-group">
                                <label for="testDate" class="required">?? Дата проведения</label>
                                <input type="date" id="testDate" 
                                       onchange="scheduleAutoSave(); updateProgress();" 
                                       class="form-input">
                                <small class="form-hint">Дата проведения работы</small>
                            </div>
                            
                            <div class="form-group">
                                <label for="timeLimit" class="required">? Время выполнения (минут)</label>
                                <input type="number" id="timeLimit" min="1" value="45" 
                                       oninput="scheduleAutoSave(); updateProgress();" 
                                       class="form-input">
                                <small class="form-hint">Продолжительность работы в минутах</small>
                            </div>
                        </div>
                    </div>
                    
                    <div class="settings-card">
                        <h3 class="card-title">?? Содержание работы</h3>
                        
                        <div class="form-group">
                            <label for="testTheme" class="required">?? Тема работы</label>
                            <input type="text" id="testTheme" placeholder="Например: Дроби и проценты" 
                                   oninput="scheduleAutoSave(); updateProgress();" 
                                   class="form-input">
                            <small class="form-hint">Основная тема контрольной работы</small>
                        </div>
                        
                        <div class="form-group">
                            <label for="testGoals" class="required">?? Проверяемые цели и элементы содержания</label>
                            <textarea id="testGoals" rows="4" 
                                      placeholder="Перечислите проверяемые знания, умения, навыки..." 
                                      oninput="scheduleAutoSave(); updateProgress();" 
                                      class="form-textarea"></textarea>
                            <small class="form-hint">Какие именно умения и знания проверяет эта работа?</small>
                        </div>
                        
                        <div class="form-group">
                            <label for="workFormat" class="required">?? Формат работы</label>
                            <select id="workFormat" onchange="scheduleAutoSave(); updateProgress();" class="form-select">
                                <option value="traditional">Традиционная (с решениями)</option>
                                <option value="test">Тест (выбор ответа)</option>
                                <option value="mixed">Смешанная</option>
                                <option value="extended">С развернутым ответом</option>
                            </select>
                            <small class="form-hint">Определяет способ проверки и анализа</small>
                        </div>
                    </div>
                    
                    <div class="step-navigation">
                        <button class="btn" onclick="prevStep()">
                            < Назад к типу работы
                        </button>
                        <button class="btn btn-primary" onclick="nextStep()" id="nextStep2">
                            Далее > Учащиеся
                        </button>
                    </div>
                </div>

                <!-- Шаг 3: Учащиеся -->
                <div class="wizard-step" id="step3">
                    <div class="step-header">
                        <span class="step-number">3</span>
                        <h2>?? Учащиеся</h2>
                    </div>
                    
                    <div class="settings-card">
                        <div class="form-row">
                            <div class="form-group">
                                <label for="totalStudents" class="required">?? Количество учащихся по списку</label>
                                <input type="number" id="totalStudents" min="1" max="100" value="25" 
                                       oninput="updatePresentStudents(); scheduleAutoSave(); updateProgress();" 
                                       class="form-input">
                                <small class="form-hint">Общее количество учеников в классе</small>
                            </div>
                            
                            <div class="form-group">
                                <label for="presentStudents" class="required">?? Количество писавших работу</label>
                                <div class="input-with-button">
                                    <input type="number" id="presentStudents" min="1" max="100" value="23" 
                                           oninput="scheduleAutoSave(); updateProgress();" 
                                           class="form-input">
                                    <button type="button" class="btn-icon" onclick="syncStudentsCount()" 
                                            title="Синхронизировать с текущим списком">
                                        ??
                                    </button>
                                </div>
                                <small class="form-hint">Сколько учеников присутствовало на работе</small>
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <label for="absentReason">?? Причины отсутствия</label>
                            <textarea id="absentReason" rows="3" 
                                      placeholder="Указать причины отсутствия учащихся..." 
                                      oninput="scheduleAutoSave();" 
                                      class="form-textarea"></textarea>
                            <small class="form-hint">Болезнь, соревнования, семейные обстоятельства и т.д.</small>
                        </div>
                        
                        <div class="attendance-stats">
                            <div class="stat-card">
                                <div class="stat-value" id="attendancePercent">92%</div>
                                <div class="stat-label">Посещаемость</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-value" id="absentCount">2</div>
                                <div class="stat-label">Отсутствуют</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="step-navigation">
                        <button class="btn" onclick="prevStep()">
                            < Назад к информации
                        </button>
                        <button class="btn btn-primary" onclick="nextStep()" id="nextStep3">
                            Далее > Критерии
                        </button>
                    </div>
                </div>

                <!-- Шаг 4: Критерии оценивания -->
                <div class="wizard-step" id="step4">
                    <div class="step-header">
                        <span class="step-number">4</span>
                        <h2>?? Критерии оценивания</h2>
                    </div>
                    
                    <div class="settings-card">
                        <div class="criteria-header">
                            <h3>Система оценивания</h3>
                            <div class="criteria-type-selector">
                                <label>Тип шкалы:</label>
                                <select id="criteriaType" onchange="changeCriteriaType()">
                                    <option value="points">Баллы (0-100)</option>
                                    <option value="percent">Проценты (0-100%)</option>
                                    <option value="custom">Своя шкала</option>
                                </select>
                            </div>
                        </div>
                        
                        <div id="criteriaSettingsContainer">
                            <!-- Динамически загружаемые критерии -->
                        </div>
                        
                        <div class="criteria-presets">
                            <h4>?? Быстрые пресеты:</h4>
                            <div class="preset-grid">
                                <button class="preset-btn" onclick="applyPreset('standard_5')">
                                    ?? Стандартная (2-5)
                                </button>
                                <button class="preset-btn" onclick="applyPreset('five_point')">
                                    1?? Пятибалльная (1-5)
                                </button>
                                <button class="preset-btn" onclick="applyPreset('vpr_percent')">
                                    ?? ВПР (проценты)
                                </button>
                                <button class="preset-btn" onclick="applyPreset('psychology_levels')">
                                    ?? Психология (уровни)
                                </button>
                                <button class="preset-btn" onclick="applyPreset('ege_scaled')">
                                    ?? ЕГЭ (шкалированные)
                                </button>
                            </div>
                        </div>
                        
                        <div class="criteria-controls">
                            <button class="btn btn-success" onclick="saveCriteriaSettings()">
                                ?? Сохранить критерии
                            </button>
                            <button class="btn" onclick="loadDefaultCriteria()">
                                ?? Стандартные настройки
                            </button>
                            <button class="btn" onclick="generateAutoCriteria()">
                                ?? Автогенерация
                            </button>
                        </div>
                        
                        <div class="recommendation-card">
                            <strong>?? Подсказка:</strong>
                            <ul>
                                <li><strong>Баллы</strong> - классическая система оценивания</li>
                                <li><strong>Проценты</strong> - удобно для тестов и ВПР</li>
                                <li><strong>Своя шкала</strong> - для нестандартных систем оценивания</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="settings-card">
                        <h3>?? Предварительный просмотр</h3>
                        <div class="preview-grid" id="criteriaPreview">
                            <!-- Предпросмотр критериев -->
                        </div>
                    </div>
                    
                    <div class="step-navigation">
                        <button class="btn" onclick="prevStep()">
                            < Назад к учащимся
                        </button>
                        <button class="btn btn-primary" onclick="completeSetup()" id="completeSetup">
                            ? Завершить настройку
                        </button>
                    </div>
                </div>
            </div>

            <!-- Кнопки действий (показываются после завершения) -->
            <div class="action-buttons" id="actionButtons" style="display: none;">
                <button class="btn btn-success" onclick="saveTestSettings()">
                    ?? Сохранить настройки
                </button>
                <button class="btn btn-warning" onclick="loadSampleData()">
                    ?? Загрузить пример
                </button>
                <button class="btn" onclick="restoreBackupDialog()">
                    ?? Восстановить из резервной копии
                </button>
                <button class="btn btn-outline" onclick="editSetup()">
                    ?? Редактировать настройки
                </button>
                <button class="btn btn-danger" onclick="showResetDialog()">
                    ?? Сброс всех данных
                </button>
            </div>

            <!-- Модальные окна -->
			<div class="modal-overlay" id="resetDialog">
				<div class="modal-content">
					<h3>?? Подтверждение сброса</h3>
					<p>Вы уверены, что хотите сбросить все данные? Это действие нельзя отменить.</p>
					<div class="modal-actions">
						<button class="btn" onclick="closeModal('resetDialog')">Отмена</button>
						<button class="btn btn-danger" onclick="resetAllData()">Сбросить всё</button>
					</div>
				</div>
			</div>

			<div class="modal-overlay" id="successModal">
				<div class="modal-content success">
					<div class="modal-icon">?</div>
					<h3>Настройки сохранены!</h3>
					<p>Все параметры успешно сохранены. Теперь вы можете перейти к добавлению заданий.</p>
					<button class="btn btn-success" onclick="closeModal('successModal')">Продолжить</button>
				</div>
			</div>
        </div>

        <!-- Вкладка таксономии заданий -->
        <div id="tasks" class="tab-content">
            <h2 class="section-title">?? Таксономический анализ заданий</h2>
            <div id="tasksContainer"></div>
            <button class="btn btn-success" onclick="saveTasks()">?? Сохранить задания</button>
        </div>

        <!-- Вкладка учащихся -->
        <div id="students" class="tab-content">
            <h2 class="section-title">?? Список учащихся</h2>
            
            <button class="btn btn-info mb-3" onclick="toggleViewMode()">
                <i class="fas fa-exchange-alt me-2"></i>
                <span id="viewModeText">Перейти к управлению классами</span>
            </button>

            <div id="classManagerContainer" style="display: none;"></div>          
            <div id="studentsContainer"></div>
            <button class="btn btn-success" onclick="saveStudents()">?? Сохранить список</button>
        </div>

        <!-- Вкладка результатов и ошибок -->
        <div id="results" class="tab-content">
            <h2 class="section-title">?? Результаты и анализ ошибки</h2>
            <button class="btn btn-warning" onclick="showBulkEditScores()">?? Массовое редактирование оценок</button>
            <div id="resultsContainer"></div>
            <button class="btn btn-success" onclick="saveResults()">?? Сохранить результаты</button>
        </div>

        <!-- Вкладка аналитики -->
        <div id="analytics" class="tab-content">
            <h2 class="section-title">?? Комплексная аналитика</h2>
            
            <div class="export-buttons">
                <button class="btn" onclick="showComparativeAnalysis()">?? Сравнительный анализ</button>
                <button class="btn" onclick="initAdvancedSearch()">?? Расширенный поиск</button>
                <button class="btn" onclick="showSmartRecommendations()">?? Умные рекомендации</button>
            </div>
            
            <h3 class="section-title">Общая статистика</h3>
            <div class="kpi-grid" id="kpiDashboard"></div>

            <h3 class="section-title">Таксономический анализ по уровням сложности</h3>
            <div id="taxonomyAnalysis"></div>

            <h3 class="section-title">Анализ ошибок</h3>
            <div id="errorsAnalysis"></div>

            <h3 class="section-title">Персональный анализ учащихся</h3>
            <div id="personalAnalysis"></div>

            <div id="specializedAnalysis"></div>
            
            <div id="smartRecommendationsContainer"></div>
        </div>

        <!-- Вкладка визуализации -->
        <div id="visualization" class="tab-content">
            <h2 class="section-title">?? Визуализация результатов</h2>
            
            <div class="print-controls no-print">
                <h4>??? Управление печатью</h4>
                <p>Для печати отчета используйте кнопку ниже или сочетание клавиш Ctrl+P</p>
                <button class="btn btn-print" onclick="printFullReport()">??? Печать полного отчета</button>
                <button class="btn" onclick="printOptimizedReport()">?? Оптимизированная печать</button>
            </div>
            
            <div class="chart-row">
                <div class="chart-container">
                    <h3>?? Распределение оценок</h3>
                    <canvas id="gradesChart"></canvas>
                </div>
                <div class="chart-container">
                    <h3>?? Коридор решаемости заданий</h3>
                    <canvas id="solvabilityChart"></canvas>
                    <div class="chart-legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #e74c3c"></div>
                            <span>Красная зона (&lt;30%) - требуется повторное объяснение</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #f39c12"></div>
                            <span>Желтая зона (30-60%) - требуются коррекционные мероприятия</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #2ecc71"></div>
                            <span>Зеленая зона (60-90%) - материал усвоен хорошо</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #27ae60"></div>
                            <span>Отличная зона (&gt;90%) - высокий уровень усвоения</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="chart-container">
                <h3>?? Связь уровня сложности и решаемости</h3>
                <canvas id="complexityChart"></canvas>
            </div>

            <div class="chart-container">
                <h3>?? Тепловая карта успеваемости</h3>
                <div id="heatmapContainer"></div>
            </div>

            <div id="specializedCharts"></div>
        </div>

        <!-- Вкладка рекомендаций -->
        <div id="recommendations" class="tab-content">
            <h2 class="section-title">?? Выводы и рекомендации</h2>
            
            <div class="print-only">
                <div class="header" style="padding: 15px; margin-bottom: 20px;">
                    <h2 style="font-size: 1.5em; margin: 0;">Аналитический отчет по диагностической работе</h2>
                    <p style="margin: 5px 0;"><strong id="printSubjectClass"></strong> | <span id="printTheme"></span> | <span id="printDate"></span></p>
                </div>
            </div>
            
            <h3 class="section-title">Ключевые выводы</h3>
            <div id="keyConclusions"></div>

            <h3 class="section-title">План коррекционных мероприятий</h3>
            <div id="correctionPlan"></div>

            <h3 class="section-title">Дальнейшие шаги</h3>
            <div id="nextSteps"></div>
        </div>

        <!-- Вкладка экспорта -->
        <div id="export" class="tab-content">
            <h2 class="section-title">?? Экспорт отчетов</h2>
            
            <div class="export-buttons">
                <button class="btn btn-success" onclick="exportHTML()">?? Полный HTML отчет</button>
                <button class="btn btn-print" onclick="printFullReport()">??? Печать на А4</button>
                <button class="btn" onclick="printOptimizedReport()">?? Оптимизированная печать</button>
                <button class="btn" onclick="exportToExcel()">?? Excel отчет</button>
                <button class="btn" onclick="exportToPDF()">?? PDF отчет</button>
                <button class="btn" onclick="exportJSON()">?? Данные (JSON)</button>
                <button class="btn" onclick="exportSpecializedReport()">?? Специализированный отчет</button>
                <button class="btn" onclick="exportForTeacher()">????? Отчет для учителя</button>
                <button class="btn" onclick="exportForEJournal()">?? Экспорт для эл.дневника</button>
                <button class="btn" onclick="showComparativeAnalysis()">?? Сравнительный анализ</button>
                <button class="btn" onclick="showBulkEditScores()">?? Массовое редактирование</button>
                <button class="btn" onclick="initAdvancedSearch()">?? Расширенный поиск</button>
                <button class="btn" onclick="printPsychologyReport()">?? Печать псих. заключения</button>
                <button class="btn" onclick="exportAppData('json')">?? Экспорт всех данных (JSON)</button>
                
                <!-- Скрытый input для импорта -->
                <input type="file" id="fileImport" accept=".json" style="display: none;" onchange="handleFileImport(event)">
                <button class="btn" onclick="document.getElementById('fileImport').click()">?? Импорт данных</button>
                
                <button class="btn btn-danger" onclick="showResetDialog()">?? Сброс всех данных</button>
            </div>

            <div class="chart-container">
                <h3>?? Предпросмотр отчета</h3>
                <div id="reportPreview"></div>
            </div>
        </div>
    </div>

    <script src="script.js"></script>
    <script>
  


		
		
	    let saveTimeout;
        // Глобальные переменные
		let appData = {
			test: {
				subject: "",
				class: "",
				testDate: new Date().toISOString().split('T')[0],
				theme: "",
				goals: "",
				workType: "current",
				workFormat: "mixed",
				timeLimit: 45,
				totalStudents: 25,
				presentStudents: 23,
				absentReason: "",
				criteria: {
					5: { min: 18, max: 20 },
					4: { min: 15, max: 17 },
					3: { min: 10, max: 14 },
					2: { min: 0, max: 9 }
				},
				criteriaType: 'points',
				criteriaSystem: 'standard',
				customCriteria: [],
				criteriaCount: 4,
				criteriaScale: '2-5'
			},
			tasks: [],
			students: [],
			results: [],
			errors: [],
			psychologyFeatures: [],
			
			// ИНИЦИАЛИЗИРУЕМ ПОЛНОСТЬЮ
			templates: {
				loadedTemplates: [],
				lastTemplatePath: "",
				lastTemplateName: "", // Добавляем это поле
				availableSubjects: []
			}
		};
		
		// Структура для хранения классов и всех учеников школы
		const schoolData = {
			classes: [], // Массив классов
			lastImportDate: null, // Дата последнего импорта
			schoolName: '' // Название школы
		};

		// Структура одного класса
		class SchoolClass {
			constructor(name, grade, teacher = '') {
				this.id = 'class_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
				this.name = name;
				this.grade = grade;
				this.teacher = teacher;
				this.students = [];
				this.createdAt = new Date().toISOString();
			}
		}

		// Структура ученика школы
		class SchoolStudent {
			constructor(lastName, firstName, middleName = '', id = '') {
				this.id = id || 'student_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
				this.lastName = lastName;
				this.firstName = firstName;
				this.middleName = middleName;
				this.fullName = `${lastName} ${firstName} ${middleName}`.trim();
				this.classId = null;
				this.isPresent = true;
			}
		}
	
		
		// Глобальные переменные для хранения экземпляров графиков
		window.gradesChartInstance = null;
		window.complexityChartInstance = null;
		window.solvabilityChartInstance = null;
		window.literacyChartInstance = null;
		window.literacyRadarChartInstance = null;
		window.trendChartInstance = null;
		
        // Уровни сложности
        const complexityLevels = {
            1: { name: "Базовый/Репродуктивный", color: "#27ae60", desc: "воспроизведение фактов, правил, определений" },
            2: { name: "Применение", color: "#3498db", desc: "применение знаний в стандартной ситуации" },
            3: { name: "Анализ/Синтез", color: "#f39c12", desc: "анализ, сравнение, аргументация" },
            4: { name: "Творчество", color: "#e74c3c", desc: "решение нестандартных задач, творческие задания" }
        };

        // Типы ошибок
        const errorTypes = {
            factual: { name: "Фактические ошибки", color: "#e74c3c", desc: "неверные даты, имена, формулы" },
            conceptual: { name: "Концептуальные ошибки", color: "#9b59b6", desc: "непонимание теории, законов, принципов" },
            application: { name: "Ошибки применения", color: "#3498db", desc: "неверный выбор способа решения" },
            calculation: { name: "Вычислительные ошибки", color: "#f39c12", desc: "ошибки в вычислениях" },
            logical: { name: "Логические ошибки", color: "#d35400", desc: "нарушение логики в рассуждениях" },
            attention: { name: "Ошибки внимательности", color: "#16a085", desc: "неверно прочел условие, пропустил вопрос" },
            technical: { name: "Технические ошибки", color: "#7f8c8d", desc: "единицы измерения, оформление" }
        };

        // Типы работ
        const workTypes = {
            current: { name: "Текущая контрольная", criteria: "стандартные" },
            milestone: { name: "Рубежная", criteria: "расширенные" },
            final: { name: "Итоговая", criteria: "итоговые" },
            oge: { name: "ОГЭ", criteria: "государственные" },
            ege: { name: "ЕГЭ", criteria: "государственные" },
            vpr: { name: "ВПР", criteria: "федеральные" },
            func_literacy: { name: "Функциональная грамотность", criteria: "компетентностные" },
            diagnostic: { name: "Диагностическая", criteria: "диагностические" },
			psychology: { 
        name: "Психологическая диагностика", 
			criteria: "психологические" 
		}
        };

        // Уровни ВПР
        const vprLevels = {
            1: { name: "Базовый", color: "#27ae60" },
            2: { name: "Повышенный", color: "#3498db" }
        };

        // Компетенции ВПР
        const vprCompetencies = {
            text_work: "Работа с текстом",
            calculations: "Вычислительные навыки", 
            logic: "Логическое мышление",
            graphics: "Графическая грамотность",
            data_work: "Работа с данными"
        };

        // Виды функциональной грамотности
        const functionalLiteracyTypes = {
            reading: { name: "Читательская грамотность", color: "#3498db" },
            math: { name: "Математическая грамотность", color: "#e74c3c" },
            science: { name: "Естественнонаучная грамотность", color: "#9b59b6" },
            financial: { name: "Финансовая грамотность", color: "#27ae60" },
            global: { name: "Глобальные компетенции", color: "#f39c12" },
            digital: { name: "Цифровая грамотность", color: "#34495e" }
        };

        // Контексты для функциональной грамотности
        const literacyContexts = {
            personal: "Личный",
            educational: "Учебный", 
            professional: "Профессиональный",
            social: "Общественный",
            global: "Глобальный"
        };

        // ==================== ФУНКЦИОНАЛЬНЫЕ РЕШЕНИЯ ====================
		// Функция для безопасной загрузки данных
		function loadAppData() {
			const savedData = localStorage.getItem('testAnalyticsData');
			if (savedData) {
				const parsedData = JSON.parse(savedData);
				appData = parsedData;
				
				// Гарантируем, что templates существует
				if (!appData.templates) {
					appData.templates = {
						loadedTemplates: [],
						lastTemplatePath: "",
						lastTemplateName: "",
						availableSubjects: []
					};
				}
				
				// Гарантируем, что все поля templates существуют
				appData.templates = {
					loadedTemplates: appData.templates.loadedTemplates || [],
					lastTemplatePath: appData.templates.lastTemplatePath || "",
					lastTemplateName: appData.templates.lastTemplateName || "",
					availableSubjects: appData.templates.availableSubjects || []
				};
			}
		}

		// Вызываем при загрузке страницы
		document.addEventListener('DOMContentLoaded', function() {
			loadAppData();
			renderAll();
		});
		
		
		
		// ============ ИНТЕГРАЦИЯ ГИБРИДНОГО СКАНЕРА ============

		// 1. Класс TemplateStorage (добавить в начало файла или отдельным блоком)
		class TemplateStorage {
			constructor() {
				this.dbName = 'TestMakerTemplatesDB';
				this.storeName = 'templates';
				this.version = 1;
				this.db = null;
			}

			async init() {
				return new Promise((resolve, reject) => {
					const request = indexedDB.open(this.dbName, this.version);
					
					request.onupgradeneeded = (e) => {
						const db = e.target.result;
						if (!db.objectStoreNames.contains(this.storeName)) {
							const store = db.createObjectStore(this.storeName, { keyPath: 'fullPath' });
							store.createIndex('subject', 'subject', { unique: false });
							store.createIndex('workType', 'workType', { unique: false });
							store.createIndex('class', 'class', { unique: false });
						}
					};
					
					request.onsuccess = (e) => {
						this.db = e.target.result;
						console.log('? TemplateStorage инициализирован');
						resolve();
					};
					
					request.onerror = (e) => reject(e.target.error);
				});
			}

			async saveTemplate(templateData) {
				return new Promise((resolve, reject) => {
					if (!this.db) {
						reject(new Error('База данных не инициализирована'));
						return;
					}
					
					const transaction = this.db.transaction([this.storeName], 'readwrite');
					const store = transaction.objectStore(this.storeName);
					
					const template = {
						fullPath: templateData.fullPath,
						name: templateData.name,
						subject: templateData.subject,
						class: templateData.class,
						workType: templateData.workType,
						theme: templateData.theme,
						data: templateData.data,
						lastModified: templateData.lastModified || Date.now(),
						taskCount: templateData.taskCount,
						addedDate: Date.now()
					};
					
					const request = store.put(template);
					request.onsuccess = () => resolve();
					request.onerror = (e) => reject(e.target.error);
				});
			}

			async getAllTemplates() {
				return new Promise((resolve, reject) => {
					if (!this.db) {
						reject(new Error('База данных не инициализирована'));
						return;
					}
					
					const transaction = this.db.transaction([this.storeName], 'readonly');
					const store = transaction.objectStore(this.storeName);
					const request = store.getAll();
					
					request.onsuccess = (e) => resolve(e.target.result || []);
					request.onerror = (e) => reject(e.target.error);
				});
			}

			async deleteTemplate(fullPath) {
				return new Promise((resolve, reject) => {
					if (!this.db) {
						reject(new Error('База данных не инициализирована'));
						return;
					}
					
					const transaction = this.db.transaction([this.storeName], 'readwrite');
					const store = transaction.objectStore(this.storeName);
					const request = store.delete(fullPath);
					
					request.onsuccess = () => resolve();
					request.onerror = (e) => reject(e.target.error);
				});
			}

			async clearAll() {
				return new Promise((resolve, reject) => {
					if (!this.db) {
						reject(new Error('База данных не инициализирована'));
						return;
					}
					
					const transaction = this.db.transaction([this.storeName], 'readwrite');
					const store = transaction.objectStore(this.storeName);
					const request = store.clear();
					
					request.onsuccess = () => resolve();
					request.onerror = (e) => reject(e.target.error);
				});
			}
		}

		// 2. Упрощенный BackgroundTemplateScanner (без сложного UI)
		class BackgroundTemplateScanner {
			constructor() {
				this.storage = new TemplateStorage();
				this.directoryHandle = null;
				this.isWatching = false;
				this.watchInterval = 30000; // 30 секунд
				this.watchTimer = null;
				this.cachedTemplates = new Map();
				
				this.config = {
					autoScan: true,
					notifyOnChanges: true,
					deepScan: true
				};
				
				this.state = {
					lastScanTime: null,
					scanning: false
				};
			}

			async initialize() {
				try {
					await this.storage.init();
					await this.loadCachedTemplates();
					this.loadConfig();
					console.log('? Сканер шаблонов инициализирован');
					return true;
				} catch (error) {
					console.error('? Ошибка инициализации сканера:', error);
					return false;
				}
			}

			async selectFolder() {
				try {
					if ('showDirectoryPicker' in window) {
						this.directoryHandle = await window.showDirectoryPicker({
							id: 'templateFolder',
							mode: 'read'
						});
						
						localStorage.setItem('templateFolderName', this.directoryHandle.name);
						localStorage.setItem('hasTemplateFolderAccess', 'true');
						
						await this.scanNow();
						
						if (this.config.autoScan) {
							this.startWatching();
						}
						
						showNotification('? Папка выбрана и просканирована', 'success');
						return true;
					} else {
						// Fallback
						showNotification('Ваш браузер не поддерживает автоматическое сканирование', 'warning');
						return false;
					}
				} catch (error) {
					if (error.name !== 'AbortError') {
						showNotification(`? Ошибка: ${error.message}`, 'error');
					}
					return false;
				}
			}

			async scanNow() {
				if (this.state.scanning || !this.directoryHandle) return;
				
				this.state.scanning = true;
				
				try {
					const changes = await this.performScan();
					this.state.lastScanTime = Date.now();
					
					if (changes.added.length > 0 || changes.updated.length > 0 || changes.removed.length > 0) {
						let message = 'Обнаружены изменения: ';
						const parts = [];
						if (changes.added.length) parts.push(`+${changes.added.length}`);
						if (changes.updated.length) parts.push(`?${changes.updated.length}`);
						if (changes.removed.length) parts.push(`-${changes.removed.length}`);
						
						if (this.config.notifyOnChanges) {
							showNotification(message + parts.join(', '), 'info');
						}
					}
					
					return changes;
				} catch (error) {
					console.error('Ошибка сканирования:', error);
					showNotification(`Ошибка сканирования: ${error.message}`, 'error');
				} finally {
					this.state.scanning = false;
				}
			}

			async performScan() {
				const changes = { added: [], updated: [], removed: [], errors: [] };
				const currentFiles = new Map();
				
				const scanDir = async (dirHandle, path = '') => {
					for await (const [name, handle] of dirHandle.entries()) {
						const fullPath = path ? `${path}/${name}` : name;
						
						if (handle.kind === 'file' && name.endsWith('.json')) {
							try {
								const file = await handle.getFile();
								const content = await this.readAndParseTemplate(file, fullPath);
								if (content) {
									currentFiles.set(fullPath, {
										handle, file, content,
										lastModified: file.lastModified
									});
								}
							} catch (error) {
								changes.errors.push({ path: fullPath, error: error.message });
							}
						} else if (handle.kind === 'directory' && this.config.deepScan) {
							await scanDir(handle, fullPath);
						}
					}
				};
				
				await scanDir(this.directoryHandle);
				
				// Обновляем кэш
				for (const [fullPath, fileData] of currentFiles.entries()) {
					const cached = this.cachedTemplates.get(fullPath);
					
					if (!cached) {
						await this.saveTemplateToCache(fullPath, fileData);
						changes.added.push(fileData.content.metadata);
					} else if (fileData.lastModified > cached.lastModified) {
						await this.saveTemplateToCache(fullPath, fileData);
						changes.updated.push(fileData.content.metadata);
					}
				}
				
				// Удаляем старые
				for (const [fullPath, cached] of this.cachedTemplates.entries()) {
					if (!currentFiles.has(fullPath)) {
						await this.storage.deleteTemplate(fullPath);
						this.cachedTemplates.delete(fullPath);
						changes.removed.push(cached);
					}
				}
				
				return changes;
			}

			async readAndParseTemplate(file, fullPath) {
				try {
					const text = await file.text();
					const cleaned = cleanJSON(text);
					const data = JSON.parse(cleaned);
					
					if (!data.test || !data.tasks) {
						throw new Error('Неверный формат шаблона');
					}
					
					return {
						metadata: {
							name: file.name,
							fullPath: fullPath,
							subject: data.test.subject || 'Не указан',
							class: data.test.class || 'Не указан',
							workType: data.test.workType || 'current',
							theme: data.test.theme || 'Без названия',
							taskCount: data.tasks.length,
							lastModified: file.lastModified
						},
						data: data
					};
				} catch (error) {
					console.error(`Ошибка парсинга ${file.name}:`, error);
					return null;
				}
			}

			async saveTemplateToCache(fullPath, fileData) {
				const template = {
					fullPath: fullPath,
					name: fileData.file.name,
					subject: fileData.content.metadata.subject,
					class: fileData.content.metadata.class,
					workType: fileData.content.metadata.workType,
					theme: fileData.content.metadata.theme,
					data: fileData.content.data,
					lastModified: fileData.lastModified,
					taskCount: fileData.content.metadata.taskCount,
					addedDate: Date.now()
				};
				
				await this.storage.saveTemplate(template);
				this.cachedTemplates.set(fullPath, template);
			}

			async loadCachedTemplates() {
				try {
					const templates = await this.storage.getAllTemplates();
					this.cachedTemplates.clear();
					templates.forEach(t => this.cachedTemplates.set(t.fullPath, t));
					
					// Обновляем глобальную переменную для совместимости
					window.templateFilesData = templates.map(t => ({
						file: { name: t.name },
						data: t.data,
						workType: t.workType,
						subject: t.subject,
						class: t.class,
						taskCount: t.taskCount,
						date: t.data.test?.testDate || 'Не указано'
					}));
					
					return templates.length;
				} catch (error) {
					console.error('Ошибка загрузки кэша:', error);
					return 0;
				}
			}

			loadConfig() {
				const saved = localStorage.getItem('templateScannerConfig');
				if (saved) {
					this.config = { ...this.config, ...JSON.parse(saved) };
				}
			}

			saveConfig() {
				localStorage.setItem('templateScannerConfig', JSON.stringify(this.config));
			}

			startWatching() {
				if (this.isWatching) return;
				
				this.isWatching = true;
				this.watchTimer = setInterval(() => {
					if (!this.state.scanning) {
						this.scanNow();
					}
				}, this.watchInterval);
				
				document.addEventListener('visibilitychange', () => {
					if (!document.hidden && !this.state.scanning) {
						setTimeout(() => this.scanNow(), 1000);
					}
				});
			}

			stopWatching() {
				if (!this.isWatching) return;
				
				this.isWatching = false;
				if (this.watchTimer) {
					clearInterval(this.watchTimer);
					this.watchTimer = null;
				}
				
				document.removeEventListener('visibilitychange', this.handleVisibilityChange);
			}

			toggleWatching() {
				if (this.isWatching) {
					this.stopWatching();
					showNotification('?? Наблюдение приостановлено', 'info');
				} else {
					this.startWatching();
					showNotification('??? Наблюдение включено', 'success');
				}
			}

			getCachedTemplatesArray() {
				return Array.from(this.cachedTemplates.values()).map(t => ({
					file: { name: t.name },
					data: t.data,
					workType: t.workType,
					subject: t.subject,
					class: t.class,
					taskCount: t.taskCount,
					date: t.data.test?.testDate || 'Не указано'
				}));
			}

			getStats() {
				return {
					cached: this.cachedTemplates.size,
					lastScan: this.state.lastScanTime,
					isWatching: this.isWatching,
					directory: this.directoryHandle?.name || 'Не выбрана'
				};
			}
		}

		// 3. Глобальный экземпляр сканера
		let templateScanner = null;

		// 4. Инициализация при загрузке страницы
		function initTemplateScanner() {
			templateScanner = new BackgroundTemplateScanner();
			templateScanner.initialize().then(success => {
				if (success) {
					console.log('?? Сканер шаблонов готов к работе');
					
					// Проверяем, была ли ранее выбрана папка
					const folderName = localStorage.getItem('templateFolderName');
					if (folderName) {
						console.log(`?? Ранее использовалась папка: ${folderName}`);
					}
				}
			});
		}		
		
		function scanTemplateFolder() {
			// Если сканер инициализирован, используем его
			if (templateScanner) {
				templateScanner.selectFolder();
			} else {
				// Fallback на старый метод
				const input = document.createElement('input');
				input.type = 'file';
				input.webkitdirectory = true;
				input.accept = '.json';
				
				input.onchange = function(e) {
					const files = Array.from(e.target.files);
					const jsonFiles = files.filter(file => file.name.endsWith('.json'));
					
					if (jsonFiles.length === 0) {
						showNotification('В выбранной папке нет JSON файлов', 'error');
						return;
					}
					
					showTemplateSelection(jsonFiles);
				};
				
				input.click();
			}
		}



		// 6. Модифицируем showTemplateSelection для работы с кэшем
		function showTemplateSelection(files = null) {
			console.log('?? showTemplateSelection вызвана с files:', files);
			
			// Если файлы не переданы и есть глобальная переменная
			if (!files && window.templateFilesData && window.templateFilesData.length > 0) {
				files = window.templateFilesData;
				console.log('?? Использую window.templateFilesData:', files.length, 'файлов');
			}
			
			// Если файлы переданы
			if (files && Array.isArray(files)) {
				// Сохраняем в глобальную переменную для фильтрации
				window.templateFilesData = files;
				
				// Показываем модальное окно
				showTemplateSelectionModal(files);
			} else {
				// Если нет файлов, показываем выбор
				showTemplateSelectionEmpty();
			}
		}
		
		// Выносим логику модального окна в отдельную функцию
		function showTemplateSelectionModal(files) {
			console.log('??? showTemplateSelectionModal вызвана с', files.length, 'файлами');
			
			if (!files || !Array.isArray(files)) {
				console.error('? Ошибка: files не массив или undefined');
				showNotification('Ошибка: нет данных для отображения', 'error');
				return;
			}
			
			let html = `
				<div style="max-width: 800px;">
					<h3>?? Выбор шаблона работы</h3>
					<p>Доступно шаблонов: <strong>${files.length}</strong></p>
					
					<div style="margin: 20px 0;">
						<label><strong>Тип работы:</strong></label>
						<select id="templateWorkType" class="form-control" onchange="filterTemplatesByType()">
							<option value="all">Все типы</option>
			`;
			
			// Проверяем, существует ли workTypes
			if (typeof workTypes !== 'undefined' && workTypes) {
				Object.keys(workTypes).forEach(type => {
					html += `<option value="${type}">${workTypes[type].name}</option>`;
				});
			} else {
				console.warn('?? workTypes не определен, показываю пустой список');
			}
			
			html += `
						</select>
					</div>
					
					<div id="templatesContainer" style="max-height: 400px; overflow-y: auto; margin: 20px 0;">
						<div style="text-align: center; padding: 40px; color: #666;">
							Загрузка шаблонов...
						</div>
					</div>
					
					<div style="margin-top: 20px; padding: 10px; background: #f8f9fa; border-radius: 5px;">
						<small>
							?? Источник: Сервер сайта
							${serverTemplateScanner && serverTemplateScanner.templateFolder ? 
								`(папка: ${serverTemplateScanner.templateFolder})` : ''}
						</small>
					</div>
				</div>
			`;
			
			showModal('Импорт из шаблонов', html);
			
			// Читаем файлы с обработкой ошибок
			let filesData = [];
			let filesProcessed = 0;
			
			// Если файлы уже обработаны (как в случае серверных шаблонов)
			if (files[0] && files[0].data) {
				console.log('?? Файлы уже обработаны, преобразую формат...');
				
				files.forEach(file => {
					try {
						if (file.data && file.data.test && file.data.tasks) {
							filesData.push({
								file: file.file || { name: 'unknown.json' },
								data: file.data,
								workType: file.data.test.workType || file.workType || 'current',
								subject: file.data.test.subject || file.subject || 'Не указан',
								class: file.data.test.class || file.class || 'Не указан',
								taskCount: file.data.tasks.length || file.taskCount || 0,
								date: file.data.test.testDate || file.date || 'Не указано'
							});
						}
					} catch (error) {
						console.error('Ошибка обработки файла:', error);
					}
				});
				
				// Сохраняем в глобальной переменной для фильтрации
				window.templateFilesData = filesData;
				
				// Показываем все шаблоны
				if (typeof renderTemplatesList === 'function') {
					renderTemplatesList(filesData);
				} else {
					console.error('? Функция renderTemplatesList не найдена!');
					document.getElementById('templatesContainer').innerHTML = 
						'<p style="color: #dc3545; text-align: center;">Ошибка: функция отображения не найдена</p>';
				}
				
				return;
			}
			
			// Оригинальная логика для File объектов (локальные файлы)
			files.forEach(file => {
				const reader = new FileReader();
				reader.onload = function(e) {
					try {
						// Используем вашу функцию cleanJSON если она существует
						const cleanedContent = window.cleanJSON ? 
							window.cleanJSON(e.target.result) : e.target.result;
						const data = JSON.parse(cleanedContent);
						
						if (data.test && data.tasks) {
							filesData.push({
								file: file,
								data: data,
								workType: data.test.workType || 'current',
								subject: data.test.subject || 'Не указан',
								class: data.test.class || 'Не указан',
								taskCount: data.tasks.length,
								date: data.test.testDate || 'Не указано'
							});
						}
					} catch (error) {
						console.error('Ошибка чтения файла', file.name, error);
						
						if (files.length === 1) {
							showNotification(`Ошибка в файле ${file.name}: ${error.message}`, 'error');
						}
					}
					
					filesProcessed++;
					
					// Когда все файлы обработаны
					if (filesProcessed === files.length) {
						if (filesData.length === 0) {
							document.getElementById('templatesContainer').innerHTML = 
								'<p style="color: #dc3545; text-align: center; padding: 20px;">Не удалось загрузить ни одного шаблона. Проверьте формат файлов.</p>';
							return;
						}
						
						// Сохраняем в глобальной переменной для фильтрации
						window.templateFilesData = filesData;
						
						// Показываем все шаблоны
						if (typeof renderTemplatesList === 'function') {
							renderTemplatesList(filesData);
						} else {
							document.getElementById('templatesContainer').innerHTML = 
								'<p style="color: #dc3545; text-align: center;">Ошибка: функция отображения не найдена</p>';
						}
					}
				};
				
				reader.onerror = function() {
					console.error('Ошибка чтения файла:', file.name);
					filesProcessed++;
				};
				
				reader.readAsText(file);
			});
		}


		// 7. Новая функция для показа шаблонов из кэша
		function showTemplateSelectionWithCache() {
			const templates = templateScanner.getCachedTemplatesArray();
			const stats = templateScanner.getStats();
			
			let html = `
				<div style="max-width: 800px;">
					<h3>?? Выбор шаблона работы</h3>
					<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
						<div>
							<p style="margin: 0;">Доступно шаблонов: <strong>${templates.length}</strong></p>
							<small style="color: #666;">
								${stats.lastScan ? `Обновлено: ${new Date(stats.lastScan).toLocaleTimeString()}` : ''}
								${stats.directory !== 'Не выбрана' ? ` | Папка: ${stats.directory}` : ''}
							</small>
						</div>
						<div>
							<button class="btn btn-sm btn-outline-info" onclick="templateScanner.scanNow()" style="margin-right: 5px;">
								?? Обновить
							</button>
							<button class="btn btn-sm ${stats.isWatching ? 'btn-warning' : 'btn-success'}" 
									onclick="templateScanner.toggleWatching()">
								${stats.isWatching ? '?? Пауза' : '?? Наблюдать'}
							</button>
						</div>
					</div>
					
					<div style="margin: 20px 0;">
						<label><strong>Тип работы:</strong></label>
						<select id="templateWorkType" class="form-control" onchange="filterTemplatesByType()">
							<option value="all">Все типы</option>
			`;
			
			// Добавляем типы работ
			Object.keys(workTypes).forEach(type => {
				html += `<option value="${type}">${workTypes[type].name}</option>`;
			});
			
			html += `
						</select>
					</div>
					
					<div id="templatesContainer" style="max-height: 400px; overflow-y: auto; margin: 20px 0;">
						<div style="text-align: center; padding: 20px; color: #666;">
							Загрузка шаблонов из кэша...
						</div>
					</div>
					
					<div style="margin-top: 20px; padding: 10px; background: #f8f9fa; border-radius: 5px;">
						<small>
							?? Шаблоны загружены из кэша. 
							<button onclick="showFolderManagement()" class="btn btn-sm btn-outline-secondary" style="margin-left: 5px;">
								Управление папкой
							</button>
						</small>
					</div>
				</div>
			`;
			
			showModal('Импорт из шаблонов', html);
			
			// Устанавливаем глобальную переменную
			window.templateFilesData = templates;
			
			// Показываем шаблоны через 100мс (чтобы DOM успел обновиться)
			setTimeout(() => {
				renderTemplatesList(templates);
			}, 100);
		}

		// 8. Функция для пустого состояния
		function showTemplateSelectionEmpty() {
			const html = `
				<div style="max-width: 600px; text-align: center; padding: 40px 20px;">
					<div style="font-size: 4em; margin-bottom: 20px;">??</div>
					<h3>Шаблоны не загружены</h3>
					<p style="color: #666; margin-bottom: 30px;">
						Выберите источник для загрузки шаблонов
					</p>
					
					<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 30px;">
						<button class="btn btn-primary" onclick="scanLocalFolder()" 
								style="padding: 15px; font-size: 1.1em;">
							?? Локальная папка
						</button>
						<button class="btn btn-success" onclick="scanServerFolder()" 
								style="padding: 15px; font-size: 1.1em;">
							?? Сервер сайта
						</button>
					</div>
					
					<div style="color: #666; font-size: 0.9em;">
						<small>
							?? Для серверных шаблонов создайте папку "templates" 
							в корне сайта и добавьте JSON файлы
						</small>
					</div>
				</div>
			`;
			
			showModal('Загрузка шаблонов', html);
		}

		// 9. Модальное окно управления папкой
		function showFolderManagement() {
			const stats = templateScanner.getStats();
			
			const html = `
				<div style="max-width: 500px;">
					<h3>?? Управление папкой шаблонов</h3>
					
					<div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0;">
						<h4>?? Статистика</h4>
						<p><strong>Шаблонов в кэше:</strong> ${stats.cached}</p>
						<p><strong>Папка:</strong> ${stats.directory}</p>
						<p><strong>Последнее сканирование:</strong> ${stats.lastScan ? new Date(stats.lastScan).toLocaleString() : 'еще не было'}</p>
						<p><strong>Автосканирование:</strong> ${stats.isWatching ? '? Включено' : '? Выключено'}</p>
					</div>
					
					<div style="margin: 20px 0;">
						<h4>Действия</h4>
						<div style="display: flex; flex-direction: column; gap: 10px;">
							<button class="btn btn-info" onclick="templateScanner.scanNow(); hideModal();">
								?? Выполнить сканирование сейчас
							</button>
							
							<button class="btn ${stats.isWatching ? 'btn-warning' : 'btn-success'}" 
									onclick="templateScanner.toggleWatching(); hideModal();">
								${stats.isWatching ? '?? Приостановить автосканирование' : '?? Включить автосканирование'}
							</button>
							
							<button class="btn btn-primary" onclick="templateScanner.selectFolder(); hideModal();">
								?? Сменить папку
							</button>
							
							${stats.cached > 0 ? `
								<button class="btn btn-outline-danger" onclick="clearTemplateCache()" style="margin-top: 10px;">
									??? Очистить кэш шаблонов
								</button>
							` : ''}
						</div>
					</div>
					
					<div style="margin-top: 20px; padding: 10px; background: #fff3cd; border-radius: 5px;">
						<small>
							?? Автосканирование проверяет папку каждые 30 секунд<br>
							и уведомляет о новых, измененных или удаленных шаблонах
						</small>
					</div>
				</div>
			`;
			
			showModal('Управление папкой шаблонов', html);
		}

		// 10. Функция очистки кэша
		function clearTemplateCache() {
			if (confirm('Вы уверены, что хотите очистить кэш шаблонов?\nЭто удалит все сохраненные шаблоны, но не затронет файлы в папке.')) {
				if (templateScanner && templateScanner.storage) {
					templateScanner.storage.clearAll().then(() => {
						templateScanner.cachedTemplates.clear();
						showNotification('? Кэш шаблонов очищен', 'success');
						hideModal();
					}).catch(error => {
						showNotification(`? Ошибка очистки кэша: ${error.message}`, 'error');
					});
				}
			}
		}
		
		let inputListenersInitialized = false;
		
		// Добавьте эту функцию для надежного отслеживания изменений
		function setupInputListeners() {
			if (inputListenersInitialized) return;

			// Используем делегирование: один слушатель на весь документ
			// Он автоматически работает и для будущих элементов
			document.addEventListener('input', function(e) {
				if (e.target.matches('input, select, textarea')) {
					scheduleAutoSave();
				}
			});
			
			document.addEventListener('change', function(e) {
				if (e.target.matches('input, select, textarea')) {
					scheduleAutoSave();
				}
			});
			
			document.addEventListener('click', function(e) {
				if (e.target.matches('input[type="radio"], input[type="checkbox"]')) {
					scheduleAutoSave();
				}
			});

			inputListenersInitialized = true;
			console.log('? Слушатели событий ввода инициализированы (один раз)');
		}

		// Инициализируйте при загрузке
		document.addEventListener('DOMContentLoaded', function() {
			setupInputListeners();
			loadAllData();
			setupTabNavigation();
			
			// Восстанавливаем последнюю активную вкладку
			if (tabState.currentTab) {
				const tabButton = document.querySelector(`[data-tab="${tabState.currentTab}"]`);
				if (tabButton) {
					tabButton.click();
				}
			}
		});

		// 11. Добавляем вызов инициализации при загрузке страницы
		// Находим или создаем блок для инициализации
		document.addEventListener('DOMContentLoaded', function() {
			// Инициализируем сканер
			initTemplateScanner();
			
			// Добавляем опции в существующий блок импорта
			enhanceTemplateImportBlock();
		});

		// 12. Улучшаем блок импорта шаблонов
		function enhanceTemplateImportBlock() {
			// Находим блок импорта
			const importBlock = document.querySelector('div[style*="background: #d6eaf8"]');
			if (!importBlock) return;
			
			// Добавляем дополнительные кнопки
			setTimeout(() => {
				const enhancedHTML = `
					<div style="display: flex; gap: 10px; margin-top: 15px;">
						<button class="btn btn-sm btn-outline-primary" onclick="showTemplateSelection()" style="flex: 1;">
							?? Показать все шаблоны
						</button>
						<button class="btn btn-sm btn-outline-info" onclick="showFolderManagement()" style="flex: 1;">
							?? Управление
						</button>
					</div>
					<div id="templateScannerStatus" style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.7); border-radius: 5px; font-size: 0.85em;">
						<small>Загрузка статуса...</small>
					</div>
				`;
				
				importBlock.insertAdjacentHTML('beforeend', enhancedHTML);
				
				// Обновляем статус каждые 10 секунд
				updateTemplateScannerStatus();
				setInterval(updateTemplateScannerStatus, 10000);
			}, 1000);
		}

		// 13. Функция обновления статуса в UI
		function updateTemplateScannerStatus() {
			const statusEl = document.getElementById('templateScannerStatus');
			if (!statusEl || !templateScanner) return;
			
			const stats = templateScanner.getStats();
			const cachedCount = stats.cached;
			
			let statusHTML = '';
			
			if (stats.directory !== 'Не выбрана') {
				statusHTML = `
					<span style="color: #27ae60;">? Папка выбрана</span> | 
					<strong>${cachedCount}</strong> шаблонов |
					${stats.isWatching ? '??? Авто' : '?? Ручной'}
				`;
			} else if (cachedCount > 0) {
				statusHTML = `
					<span style="color: #3498db;">?? Кэш: ${cachedCount} шаблонов</span> |
					<button onclick="templateScanner.selectFolder()" class="btn btn-xs btn-link" style="padding: 0; vertical-align: baseline;">
						Выбрать папку
					</button>
				`;
			} else {
				statusHTML = '<span style="color: #e74c3c;">? Папка не выбрана</span>';
			}
			
			statusEl.innerHTML = `<small>${statusHTML}</small>`;
		}

		// 14. Модифицируем renderTemplatesList для совместимости
		// Добавляем проверку на кэшированные шаблоны в существующей функции
		function renderTemplatesList(filesData) {
			window.filteredTemplateFiles = filesData;
			const container = document.getElementById('templatesContainer');
			if (!container) {
				console.error('? Контейнер templatesContainer не найден');
				return;
			}
			
			if (!filesData || filesData.length === 0) {
				container.innerHTML = '<p style="text-align: center; padding: 20px; color: #666;">Шаблоны не найдены</p>';
				return;
			}
			
			let html = '<div class="list-group">';
			
			filesData.forEach((file, index) => {
				const workTypeName = workTypes && workTypes[file.workType] ? 
					workTypes[file.workType].name : file.workType || 'Не указан';
				
				html += `
					<a href="#" class="list-group-item list-group-item-action template-item" 
					   data-index="${index}"
					   style="margin-bottom: 8px; border-radius: 5px; cursor: pointer;">
						<div style="display: flex; justify-content: space-between; align-items: center;">
							<div style="flex: 1;">
								<h6 style="margin: 0; color: #2c3e50;">
									${file.file.name || 'Без названия'}
								</h6>
								<div style="margin-top: 5px; font-size: 0.9em; color: #7f8c8d;">
									<span class="badge bg-primary">${workTypeName}</span>
									<span class="badge bg-secondary">${file.subject || 'Не указан'}</span>
									<span class="badge bg-info">${file.class || 'Не указан'}</span>
									<span class="badge bg-success">${file.taskCount} заданий</span>
								</div>
								${file.date && file.date !== 'Не указано' ? 
									`<small style="display: block; margin-top: 5px; color: #95a5a6;">?? ${file.date}</small>` : ''}
							</div>
							<button class="btn btn-sm btn-outline-primary select-template-btn"
									data-index="${index}"
									style="margin-left: 10px;">
								Выбрать
							</button>
						</div>
					</a>
				`;
			});
			
			html += '</div>';
			container.innerHTML = html;
			
			// Привязываем обработчики событий
			const templateItems = container.querySelectorAll('.template-item, .select-template-btn');
			templateItems.forEach(element => {
				element.addEventListener('click', function(e) {
					e.preventDefault();
					e.stopPropagation();
					
					// Получаем индекс из data-атрибута
					const index = this.getAttribute('data-index');
					console.log('?? Выбран шаблон с индексом:', index, 'из', filesData.length);
					
					if (index !== null && index !== undefined) {
						selectTemplate(parseInt(index));
					} else {
						console.error('? Не удалось получить индекс шаблона');
					}
				});
			});
		}

		// ============ ИНТЕГРАЦИЯ С ВАШИМ КОДОМ ============


		class ServerTemplateScanner {
			constructor(baseUrl = '') {
				this.baseUrl = baseUrl || window.location.origin;
				this.templates = new Map();
				this.isScanning = false;
				this.templateFolder = 'templates';
				this.lastScanTime = null;
			}

			async scanServerFolder() {
				this.isScanning = true;
				console.log('?? Начинаю сканирование серверной папки...');
				
				try {
					// Сначала пробуем получить список файлов
					let fileList = [];
					
					// Пробуем разные методы получения списка файлов
					try {
						fileList = await this.getTemplateList();
						console.log('?? Получен список файлов:', fileList);
					} catch (error) {
						console.log('Не удалось получить список файлов, пробуем другие методы');
					}
					
					// Если список пустой, пробуем сканирование
					if (!fileList || fileList.length === 0) {
						fileList = await this.scanViaDirectoryListing();
					}
					
					// Если все еще пусто, пробуем известные файлы
					if (!fileList || fileList.length === 0) {
						console.log('Список файлов пуст, пробую известные имена');
						return await this.scanKnownFiles();
					}
					
					// Загружаем файлы
					const templates = [];
					let loadedCount = 0;
					
					for (const fileName of fileList) {
						if (fileName.endsWith('.json')) {
							try {
								console.log(`?? Загружаю файл: ${fileName}`);
								const template = await this.loadTemplateFile(fileName);
								if (template) {
									templates.push(template);
									loadedCount++;
								}
							} catch (error) {
								console.warn(`Не удалось загрузить ${fileName}:`, error.message);
							}
						}
					}
					
					console.log(`? Загружено ${loadedCount} из ${fileList.length} файлов`);
					
					this.templates = new Map(templates.map(t => [t.name, t]));
					this.lastScanTime = Date.now();
					return templates;
					
				} catch (error) {
					console.error('? Ошибка сканирования сервера:', error);
					throw error;
				} finally {
					this.isScanning = false;
				}
			}

			async getTemplateList() {
				// Пробуем получить список из файла templates.json
				try {
					const response = await fetch('/templates/templates.json');
					if (response.ok) {
						const data = await response.json();
						return data.files || [];
					}
				} catch (error) {
					console.log('Файл templates.json не найден');
				}
				
				// Пробуем получить список через index файл
				try {
					const response = await fetch('/templates/index.json');
					if (response.ok) {
						const data = await response.json();
						return data.files || [];
					}
				} catch (error) {
					console.log('Файл index.json не найден');
				}
				
				return null;
			}

			async scanViaDirectoryListing() {
				console.log('Пробую получить список файлов через директорию');
				
				try {
					const response = await fetch(`/${this.templateFolder}/`);
					
					if (response.ok && response.headers.get('content-type')?.includes('text/html')) {
						const html = await response.text();
						const files = this.parseDirectoryListing(html);
						console.log('Найдено файлов через директорию:', files.length);
						return files;
					}
					
				} catch (error) {
					console.log('Не удалось получить список директории:', error.message);
				}
				
				return [];
			}

			async scanKnownFiles() {
				console.log('Пробую загрузить известные файлы шаблонов');
				
				const knownFiles = [
					'oge_rus.json', 'ege.json', 'vpr.json', 'diagnostika.json',
					'math.json', 'russian.json', 'physics.json',
					'test1.json', 'test2.json', 'template.json',
					'шаблон1.json', 'шаблон2.json','oge_inf.json', 'oge*.json'
				];
				
				const templates = [];
				
				for (const fileName of knownFiles) {
					try {
						const template = await this.loadTemplateFile(fileName);
						if (template) {
							templates.push(template);
							console.log(`? Загружен: ${fileName}`);
						}
					} catch (error) {
						// Файл не найден - это нормально
					}
				}
				
				console.log(`Загружено известных файлов: ${templates.length}`);
				return templates;
			}

			async loadTemplateFile(fileName) {
				try {
					const response = await fetch(`/${this.templateFolder}/${fileName}`);
					
					if (!response.ok) {
						throw new Error(`Файл ${fileName} не найден (${response.status})`);
					}
					
					const text = await response.text();
					
					// Используем вашу существующую функцию cleanJSON
					const cleaned = window.cleanJSON ? window.cleanJSON(text) : text;
					
					let data;
					try {
						data = JSON.parse(cleaned);
					} catch (error) {
						throw new Error(`Ошибка парсинга JSON: ${error.message}`);
					}
					
					// Возвращаем объект в правильном формате
					return {
						name: fileName,
						data: data,
						subject: data.test?.subject || 'Не указан',
						class: data.test?.class || 'Не указан',
						workType: data.test?.workType || 'current',
						theme: data.test?.theme || fileName.replace('.json', ''),
						taskCount: data.tasks?.length || 0,
						lastModified: Date.now()
					};
				} catch (error) {
					console.error(`? Ошибка загрузки ${fileName}:`, error);
					throw error; // Пробрасываем ошибку дальше
				}
			}

			parseDirectoryListing(html) {
				const files = [];
				
				try {
					// Простой парсинг ссылок
					const linkRegex = /<a\s+(?:[^>]*?\s+)?href="([^"]*\.json)"/gi;
					let match;
					
					while ((match = linkRegex.exec(html)) !== null) {
						const fileName = match[1];
						if (!fileName.includes('?') && !fileName.includes('#')) {
							files.push(fileName);
						}
					}
				} catch (error) {
					console.error('Ошибка парсинга директории:', error);
				}
				
				return files;
			}

			getTemplates() {
				return Array.from(this.templates.values());
			}

			getStats() {
				return {
					total: this.templates.size,
					folder: this.templateFolder,
					lastScan: this.lastScanTime,
					serverUrl: this.baseUrl
				};
			}
		}

		// Глобальный экземпляр сканера сервера
		let serverTemplateScanner = null;

		// Инициализация сканера сервера
		function initServerTemplateScanner() {
			serverTemplateScanner = new ServerTemplateScanner();
			
			// Пробуем разные имена папок
			const possibleFolders = [
				'templates', 'template', 'json', 'data', 'tests',
				'шаблоны', 'шаблон', 'test_templates'
			];
			
			// Можно сделать autodiscovery папки
			serverTemplateScanner.templateFolder = possibleFolders[0];
		}

		// Модифицируем функцию сканирования
		function scanTemplateFolder() {
			// Показываем выбор: локальная папка или сервер
			showScanSourceSelection();
		}

		// Диалог выбора источника сканирования
		function showScanSourceSelection() {
			const html = `
				<div style="max-width: 600px;">
					<h3>?? Откуда загрузить шаблоны?</h3>
					
					<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 30px 0;">
						<!-- Локальная папка -->
						<div style="text-align: center; padding: 25px; background: #e8f4fc; border-radius: 10px; cursor: pointer;"
							 onclick="scanLocalFolder()">
							<div style="font-size: 3em; margin-bottom: 15px;">??</div>
							<h4>Локальная папка</h4>
							<p style="color: #666; font-size: 0.9em;">
								Выберите папку на вашем компьютере
							</p>
							<div style="margin-top: 15px;">
								<button class="btn btn-primary">Выбрать папку</button>
							</div>
						</div>
						
						<!-- Серверная папка -->
						<div style="text-align: center; padding: 25px; background: #f0f8e8; border-radius: 10px; cursor: pointer;"
							 onclick="scanServerFolder()">
							<div style="font-size: 3em; margin-bottom: 15px;">??</div>
							<h4>Сервер сайта</h4>
							<p style="color: #666; font-size: 0.9em;">
								Автоматическая загрузка с сайта
							</p>
							<div style="margin-top: 15px;">
								<button class="btn btn-success">Загрузить</button>
							</div>
						</div>
					</div>
					
					<div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-top: 20px;">
						<h4>?? Рекомендация</h4>
						<p style="margin: 0; font-size: 0.9em;">
							<strong>Локальная папка</strong> - для ваших личных шаблонов<br>
							<strong>Сервер сайта</strong> - для общих шаблонов DeepSeek
						</p>
					</div>
				</div>
			`;
			
			showModal('Выбор источника шаблонов', html);
		}

		// Сканирование локальной папки (старая функция)
		function scanLocalFolder() {
			hideModal();
			
			if (window.templateScanner && typeof window.templateScanner.selectFolder === 'function') {
				window.templateScanner.selectFolder();
			} else {
				// Fallback на старый метод
				const input = document.createElement('input');
				input.type = 'file';
				input.webkitdirectory = true;
				input.accept = '.json';
				
				input.onchange = function(e) {
					const files = Array.from(e.target.files);
					const jsonFiles = files.filter(file => file.name.endsWith('.json'));
					
					if (jsonFiles.length === 0) {
						showNotification('В выбранной папке нет JSON файлов', 'error');
						return;
					}
					
					showTemplateSelection(jsonFiles);
				};
				
				input.click();
			}
		}

		// Сканирование серверной папки
		async function scanServerFolder() {
			console.log('?? Вызвана функция scanServerFolder');
			
			showNotification('? Сканирую папку templates на сервере...', 'info');
			
			try {
				// Инициализируем сканер если нужно
				if (!serverTemplateScanner) {
					const initialized = initServerTemplateScanner();
					if (!initialized) {
						throw new Error('Не удалось инициализировать сканер');
					}
				}
				
				// Проверяем, что сканер существует
				if (!serverTemplateScanner || typeof serverTemplateScanner.scanServerFolder !== 'function') {
					throw new Error('Сканер не инициализирован');
				}
				
				console.log('?? Начинаю сканирование...');
				
				// Сканируем
				const templates = await serverTemplateScanner.scanServerFolder();
				
				console.log(`?? Найдено шаблонов: ${templates.length}`);
				
				if (templates.length === 0) {
					showNotification('? На сервере не найдены JSON шаблоны', 'error');
					showServerFolderSetupGuide();
					return;
				}
				
				// Преобразуем в формат для showTemplateSelection
				const templateFiles = templates.map(t => ({
					file: { 
						name: t.name,
						// Добавляем другие необходимые свойства
						lastModified: t.lastModified || Date.now(),
						size: JSON.stringify(t.data).length
					},
					data: t.data,
					workType: t.workType,
					subject: t.subject,
					class: t.class,
					taskCount: t.taskCount,
					date: 'С сервера'
				}));
				
				console.log('?? Подготовленные файлы:', templateFiles);
				
				// Показываем шаблоны используя существующую функцию
				showTemplateSelection(templateFiles);
				
				showNotification(`? Загружено ${templates.length} шаблонов`, 'success');
				
			} catch (error) {
				console.error('? Ошибка сканирования сервера:', error);
				showNotification(`? Ошибка: ${error.message}`, 'error');
				
				// Показываем инструкцию
				showServerFolderSetupGuide();
			}
		}


		// Руководство по настройке папки на сервере
		function showServerFolderSetupGuide() {
			const html = `
				<div style="max-width: 700px;">
					<h3>?? Настройка папки с шаблонами на сервере</h3>
					
					<div style="background: #fff3cd; padding: 20px; border-radius: 10px; margin: 20px 0;">
						<h4>?? Требования к серверу:</h4>
						<ul>
							<li>Создайте папку <code>templates</code> в корне вашего сайта</li>
							<li>Разместите в ней JSON файлы с шаблонами</li>
							<li>Убедитесь, что доступ к папке разрешен</li>
						</ul>
					</div>
					
					<div style="background: #e8f4fc; padding: 20px; border-radius: 10px; margin: 20px 0;">
						<h4>?? Структура файлов:</h4>
						<pre style="background: white; padding: 15px; border-radius: 5px; overflow: auto;">
		ваш-сайт.ру/
		+-- index.html
		+-- templates/           < Создайте эту папку
		¦   +-- ogе.json        < Шаблон ОГЭ
		¦   +-- еgе.json        < Шаблон ЕГЭ
		¦   +-- vpr.json        < Шаблон ВПР
		¦   L-- ...             < Другие шаблоны
		L-- ...</pre>
					</div>
					
					<div style="background: #d4edda; padding: 20px; border-radius: 10px; margin: 20px 0;">
						<h4>? Пример правильного шаблона:</h4>
						<pre style="background: white; padding: 15px; border-radius: 5px; overflow: auto;">
		{
		  "test": {
			"subject": "Математика",
			"class": "9",
			"workType": "oge",
			"theme": "Алгебраические выражения"
		  },
		  "tasks": [
			{
			  "type": "multiple_choice",
			  "description": "Упростите выражение...",
			  "level": "medium",
			  "maxScore": 2
			}
		  ]
		}</pre>
					</div>
					
					<div style="margin-top: 30px; text-align: center;">
						<button class="btn btn-primary" onclick="scanServerFolder()">
							?? Попробовать снова
						</button>
						<button class="btn btn-secondary" onclick="hideModal()">
							Закрыть
						</button>
					</div>
				</div>
			`;
			
			showModal('Настройка серверных шаблонов', html);
		}

		// ============ АВТООБНАВЛЕНИЕ С СЕРВЕРА ============

		// Функция для периодической проверки обновлений на сервере
		class ServerTemplateWatcher {
			constructor() {
				this.interval = 5 * 60 * 1000; // 5 минут
				this.timer = null;
				this.lastCheck = null;
				this.lastVersions = new Map();
			}
			
			startWatching() {
				if (this.timer) return;
				
				this.timer = setInterval(async () => {
					await this.checkForUpdates();
				}, this.interval);
				
				console.log('??? Наблюдение за серверными шаблонами запущено');
			}
			
			stopWatching() {
				if (this.timer) {
					clearInterval(this.timer);
					this.timer = null;
				}
			}
			
			async checkForUpdates() {
				if (!serverTemplateScanner) return;
				
				try {
					const currentTemplates = serverTemplateScanner.getTemplates();
					const newTemplates = await serverTemplateScanner.scanServerFolder();
					
					// Сравниваем версии
					const changes = this.detectChanges(currentTemplates, newTemplates);
					
					if (changes.hasChanges) {
						this.notifyChanges(changes);
					}
					
					this.lastCheck = Date.now();
					
				} catch (error) {
					console.error('Ошибка проверки обновлений:', error);
				}
			}
			
			detectChanges(current, fresh) {
				const changes = {
					hasChanges: false,
					added: [],
					updated: [],
					removed: []
				};
				
				const currentMap = new Map(current.map(t => [t.name, t]));
				const freshMap = new Map(fresh.map(t => [t.name, t]));
				
				// Новые файлы
				for (const [name, template] of freshMap) {
					if (!currentMap.has(name)) {
						changes.added.push(template);
					}
				}
				
				// Удаленные файлы
				for (const [name, template] of currentMap) {
					if (!freshMap.has(name)) {
						changes.removed.push(template);
					}
				}
				
				changes.hasChanges = changes.added.length > 0 || changes.removed.length > 0;
				
				return changes;
			}
			
			notifyChanges(changes) {
				if (!changes.hasChanges) return;
				
				let message = 'Обновлены серверные шаблоны: ';
				const parts = [];
				
				if (changes.added.length) parts.push(`+${changes.added.length}`);
				if (changes.removed.length) parts.push(`-${changes.removed.length}`);
				
				showNotification(message + parts.join(', '), 'info');
				
				// Можно автоматически обновить список шаблонов
				if (document.getElementById('templatesContainer')) {
					setTimeout(() => scanServerFolder(), 2000);
				}
			}
		}

		// Глобальный вотчер
		let serverTemplateWatcher = null;

		function updateTemplateImportBlock() {
			// Найдите блок импорта в вашем коде
			const importBlock = document.querySelector('div[style*="background: #d6eaf8"]');
			
			if (importBlock) {
				// Обновляем HTML
				importBlock.innerHTML = `
					<div style="font-size: 3em; margin-bottom: 10px;">??</div>
					<h4>Импорт шаблонов DeepSeek</h4>
					<p>Загрузите готовые шаблоны работ</p>
					
					<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 15px 0;">
						<button class="btn btn-primary" onclick="scanLocalFolder()" style="padding: 12px;">
							?? Локальная папка
						</button>
						<button class="btn btn-success" onclick="scanServerFolder()" style="padding: 12px;">
							?? Сервер сайта
						</button>
					</div>
					
					<small style="display: block; margin-top: 10px; color: #666;">
						Поддерживает: ОГЭ, ЕГЭ, ВПР, диагностику
					</small>
					
					${hasLastTemplate ? `
					<div style="margin-top: 15px; padding: 10px; background: white; border-radius: 6px;">
						<small>Последний шаблон: <strong>${appData.templates.lastTemplateName || 'Без названия'}</strong></small>
						<button class="btn btn-sm btn-outline-primary" onclick="importLastTemplate()" style="margin-left: 10px;">
							Повторить импорт
						</button>
					</div>
					` : ''}
					
					<!-- Статус серверных шаблонов -->
					<div id="serverTemplateStatus" style="margin-top: 15px; padding: 10px; background: rgba(255,255,255,0.8); border-radius: 6px; font-size: 0.85em;">
						<small>Сервер: не проверен</small>
					</div>
				`;
				
				// Проверяем доступность серверных шаблонов
				checkServerTemplatesAvailability();
			}
		}

		// Проверка доступности серверных шаблонов
		async function checkServerTemplatesAvailability() {
			const statusEl = document.getElementById('serverTemplateStatus');
			if (!statusEl) return;
			
			try {
				initServerTemplateScanner();
				
				// Пробуем загрузить тестовый файл
				const testFiles = ['templates/manifest.json', 'templates/test.json'];
				let available = false;
				
				for (const file of testFiles) {
					try {
						const response = await fetch(file);
						if (response.ok) {
							available = true;
							break;
						}
					} catch (e) {
						// Продолжаем проверку
					}
				}
				
				if (available) {
					statusEl.innerHTML = `
						<small>
							<span style="color: #27ae60;">? Серверные шаблоны доступны</span><br>
							<button onclick="scanServerFolder()" class="btn btn-xs btn-link" style="padding: 0;">
								Загрузить сейчас
							</button>
						</small>
					`;
				} else {
					statusEl.innerHTML = `
						<small>
							<span style="color: #e74c3c;">? Серверные шаблоны не настроены</span><br>
							<button onclick="showServerFolderSetupGuide()" class="btn btn-xs btn-link" style="padding: 0;">
								Инструкция по настройке
							</button>
						</small>
					`;
				}
				
			} catch (error) {
				statusEl.innerHTML = `
					<small style="color: #f39c12;">
						?? Не удалось проверить сервер
					</small>
				`;
			}
		}

		// ============ ИНИЦИАЛИЗАЦИЯ ============

		document.addEventListener('DOMContentLoaded', function() {
			// Инициализируем сканер сервера
			initServerTemplateScanner();
			
			// Обновляем блок импорта
			updateTemplateImportBlock();
			
			// Запускаем проверку доступности
			setTimeout(checkServerTemplatesAvailability, 1000);
			
			// Запускаем вотчер (если пользователь хочет автообновление)
			serverTemplateWatcher = new ServerTemplateWatcher();
			
			// Можно спросить пользователя
			if (confirm('Включить автоматическую проверку обновлений шаблонов с сервера?')) {
				serverTemplateWatcher.startWatching();
			}
		});
		// Добавьте в начало файла или в область видимости
		window.filteredTemplateFiles = [];
		function filterTemplatesByType() {
			const select = document.getElementById('templateWorkType');
			const selectedType = select.value;
			
			if (!window.templateFilesData) {
				console.error('? templateFilesData не определен');
				return;
			}
			
			let filteredFiles;
			
			if (selectedType === 'all') {
				filteredFiles = window.templateFilesData;
			} else {
				filteredFiles = window.templateFilesData.filter(file => 
					file.workType === selectedType
				);
			}
			
			console.log('?? Фильтрация: выбрано', filteredFiles.length, 'из', window.templateFilesData.length);
			
			// Очищаем текущий отфильтрованный массив
			window.filteredTemplateFiles = filteredFiles;
			
			// Рендерим список
			if (typeof renderTemplatesList === 'function') {
				renderTemplatesList(filteredFiles);
			}
		}

		function selectTemplate(index) {
			console.log('?? selectTemplate вызван с индексом:', index);
			
			// Используем отфильтрованные данные, если они есть
			const dataSource = window.filteredTemplateFiles && window.filteredTemplateFiles.length > 0 ?
				window.filteredTemplateFiles : window.templateFilesData;
			
			if (!dataSource || !Array.isArray(dataSource)) {
				console.error('? Данные шаблонов не загружены');
				showNotification('Ошибка: данные шаблонов не загружены', 'error');
				return;
			}
			
			if (index < 0 || index >= dataSource.length) {
				console.error('? Неверный индекс:', index, 'длина массива:', dataSource.length);
				showNotification('Ошибка: неверный выбор шаблона', 'error');
				return;
			}
			
			const selectedTemplate = dataSource[index];
			console.log('?? Выбран шаблон:', selectedTemplate.file.name);
			console.log('?? Данные шаблона:', {
				workType: selectedTemplate.workType,
				subject: selectedTemplate.subject,
				class: selectedTemplate.class,
				taskCount: selectedTemplate.taskCount
			});
			
			// Проверяем, есть ли данные
			if (!selectedTemplate.data) {
				console.error('? У выбранного шаблона нет данных');
				showNotification('Ошибка: у шаблона нет данных', 'error');
				return;
			}
			
			// Закрываем модальное окно
			if (typeof closeModal === 'function') {
				closeModal();
			}
			
			// Загружаем данные в форму
			loadTemplateData(selectedTemplate.data);
			
			showNotification(`Загружен шаблон: ${selectedTemplate.file.name}`, 'success');
		}
		function loadTemplateData(templateData) {
			console.log('?? Загрузка шаблона в форму:', templateData);
			
			try {
				// Проверяем структуру шаблона
				if (!templateData || !templateData.test || !templateData.tasks) {
					throw new Error('Неверная структура шаблона');
				}
				
				// Загружаем основную информацию о тесте
				if (templateData.test) {
					// Предмет
					if (templateData.test.subject) {
						const subjectSelect = document.getElementById('subjectSelect');
						if (subjectSelect) {
							subjectSelect.value = templateData.test.subject;
							if (subjectSelect.onchange) subjectSelect.onchange();
						}
					}
					
					// Класс
					if (templateData.test.class) {
						const classSelect = document.getElementById('classSelect');
						if (classSelect) classSelect.value = templateData.test.class;
					}
					
					// Тип работы
					if (templateData.test.workType) {
						const workTypeSelect = document.getElementById('workTypeSelect');
						if (workTypeSelect) workTypeSelect.value = templateData.test.workType;
					}
					
					// Тема
					if (templateData.test.theme) {
						const themeInput = document.getElementById('themeInput');
						if (themeInput) themeInput.value = templateData.test.theme;
					}
					
					// Дата
					if (templateData.test.testDate) {
						const dateInput = document.getElementById('testDate');
						if (dateInput) dateInput.value = templateData.test.testDate;
					}
				}
				
				// Загружаем задания
				if (templateData.tasks && Array.isArray(templateData.tasks)) {
					// Сначала очищаем существующие задания
					const taskContainer = document.getElementById('taskContainer');
					if (taskContainer) {
						taskContainer.innerHTML = '';
					}
					
					// Добавляем каждое задание
					templateData.tasks.forEach((task, index) => {
						addTaskToForm(task);
					});
					
					console.log(`? Загружено ${templateData.tasks.length} заданий`);
				}
				
				// Обновляем счетчик заданий
				updateTaskCounter();
				
				// Показываем уведомление
				if (typeof showNotification === 'function') {
					showNotification(`Шаблон загружен: ${templateData.tasks?.length || 0} заданий`, 'success');
				}
				
			} catch (error) {
				console.error('? Ошибка загрузки шаблона:', error);
				if (typeof showNotification === 'function') {
					showNotification(`Ошибка загрузки шаблона: ${error.message}`, 'error');
				}
			}
		}

		// Вспомогательная функция для добавления задания в форму
		function addTaskToForm(taskData) {
			// Получаем текущее количество заданий
			const taskContainer = document.getElementById('taskContainer');
			const currentTasks = taskContainer ? taskContainer.querySelectorAll('.task-item') : [];
			const taskNumber = currentTasks.length + 1;
			
			// Создаем уникальный ID для задания
			const taskId = `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
			
			// Создаем HTML для задания
			const taskHtml = `
				<div class="task-item card mb-3" id="${taskId}" data-task-id="${taskId}">
					<div class="card-header d-flex justify-content-between align-items-center">
						<h5 class="mb-0">Задание ${taskNumber}</h5>
						<button type="button" class="btn btn-sm btn-outline-danger" onclick="deleteTask('${taskId}')">
							<i class="bi bi-trash"></i> Удалить
						</button>
					</div>
					<div class="card-body">
						<!-- Тип задания -->
						<div class="row mb-3">
							<div class="col-md-6">
								<label class="form-label">Тип задания:</label>
								<select class="form-control task-type" onchange="updateTaskType(this, '${taskId}')">
									<option value="standard" ${taskData.type === 'standard' ? 'selected' : ''}>Стандартное</option>
									<option value="multiple" ${taskData.type === 'multiple' ? 'selected' : ''}>Множественный выбор</option>
									<option value="matching" ${taskData.type === 'matching' ? 'selected' : ''}>Соответствие</option>
									<option value="open" ${taskData.type === 'open' ? 'selected' : ''}>Открытый ответ</option>
								</select>
							</div>
							<div class="col-md-3">
								<label class="form-label">Уровень сложности:</label>
								<select class="form-control task-level">
									${Object.entries(complexityLevels).map(([level, data]) => 
										`<option value="${level}" ${taskData.level == level ? 'selected' : ''}>
											${level} - ${data.name}
										</option>`
									).join('')}
								</select>
							</div>
							<div class="col-md-3">
								<label class="form-label">Макс. балл:</label>
								<input type="number" class="form-control task-max-score" min="1" max="10" 
									   value="${taskData.maxScore || 1}">
							</div>
						</div>
						
						<!-- Текст задания -->
						<div class="mb-3">
							<label class="form-label">Текст задания:</label>
							<textarea class="form-control task-text" rows="3" 
									  placeholder="Введите текст задания...">${taskData.text || ''}</textarea>
						</div>
						
						<!-- Правильный ответ -->
						<div class="mb-3">
							<label class="form-label">Правильный ответ:</label>
							<input type="text" class="form-control task-answer" 
								   value="${taskData.answer || ''}" 
								   placeholder="Введите правильный ответ...">
						</div>
						
						<!-- Описание (опционально) -->
						<div class="mb-3">
							<label class="form-label">Описание задания (для учителя):</label>
							<textarea class="form-control task-description" rows="2"
									  placeholder="Комментарии, пояснения, критерии оценивания...">${taskData.description || ''}</textarea>
						</div>
						
						<!-- Компетенции (для ВПР/Функциональной грамотности) -->
						${appData.test.workType === 'vpr' || appData.test.workType === 'func_literacy' ? `
							<div class="mb-3">
								<label class="form-label">Компетенция:</label>
								<select class="form-control task-competency">
									<option value="">Выберите компетенцию</option>
									${Object.entries(appData.test.workType === 'vpr' ? vprCompetencies : functionalLiteracyTypes).map(([key, value]) => 
										`<option value="${key}" ${taskData.competency === key ? 'selected' : ''}>
											${typeof value === 'object' ? value.name : value}
										</option>`
									).join('')}
								</select>
							</div>
						` : ''}
					</div>
				</div>
			`;
			
			// Добавляем в контейнер
			if (taskContainer) {
				taskContainer.insertAdjacentHTML('beforeend', taskHtml);
				
				// Добавляем задание в appData.tasks
				const taskObj = {
					id: taskId,
					number: taskNumber,
					text: taskData.text || '',
					answer: taskData.answer || '',
					maxScore: parseInt(taskData.maxScore) || 1,
					level: parseInt(taskData.level) || 1,
					type: taskData.type || 'standard',
					description: taskData.description || '',
					competency: taskData.competency || '',
					errors: taskData.errors || []
				};
				
				appData.tasks.push(taskObj);
				
				// Синхронизируем данные
				robustSyncData();
				
				// Обновляем интерфейс
				updateTaskCounter();
				
				return taskId;
			}
			
			return null;
		}

		// Надежная синхронизация данных
		function robustSyncData() {
			// 1. Гарантируем, что у всех задач есть ID
			appData.tasks.forEach((task, i) => {
				if (!task.id) task.id = `task_${Date.now()}_${i}`;
			});

			// 2. Гарантируем, что у всех студентов есть ID (если вы перейдете на объекты студентов)
			// Пока работаем со строками, поэтому синхронизируем по длине

			// 3. Синхронизация матрицы результатов
			// Удаляем лишние строки (если студентов стало меньше)
			if (appData.results.length > appData.students.length) {
				appData.results = appData.results.slice(0, appData.students.length);
			}

			// Добавляем строки для новых студентов
			while (appData.results.length < appData.students.length) {
				// Создаем массив нулей длиной равной количеству задач
				appData.results.push(new Array(appData.tasks.length).fill(0));
			}

			// 4. Синхронизация столбцов (задач) внутри результатов
			appData.results = appData.results.map(studentScores => {
				// Если оценок меньше чем задач -> добавляем 0
				if (studentScores.length < appData.tasks.length) {
					const diff = appData.tasks.length - studentScores.length;
					return [...studentScores, ...new Array(diff).fill(0)];
				}
				// Если оценок больше чем задач -> обрезаем лишние
				else if (studentScores.length > appData.tasks.length) {
					return studentScores.slice(0, appData.tasks.length);
				}
				return studentScores;
			});
			
			// 5. Принудительное приведение к числам (защита от строковых "5")
			appData.results = appData.results.map(row => 
				row.map(val => parseInt(val) || 0)
			);

			console.log('? Данные синхронизированы и типизированы');
		}
		

		// Функция для экранирования HTML-символов
		function escapeHtml(text) {
			if (!text) return '';
			
			// Преобразуем в строку на всякий случай
			text = String(text);
			
			return text
				.replace(/&/g, "&amp;")
				.replace(/</g, "&lt;")
				.replace(/>/g, "&gt;")
				.replace(/"/g, "&quot;")
				.replace(/'/g, "&#039;")
				.replace(/\n/g, "<br>") // Сохраняем переносы строк
				.replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;"); // Табуляция
		}
		
		function previewTemplate(index) {
			const template = window.templateFilesData[index];
			if (!template) return;
			
			// ИСПРАВЛЯЕМ: используем let вместо const
			let html = `
				<div style="max-width: 700px; max-height: 500px; overflow-y: auto;">
					<h3>??? Предпросмотр: ${escapeHtml(template.data.test.theme || 'Шаблон')}</h3>
					
					<div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0;">
						<h4>?? Основная информация</h4>
						<p><strong>Предмет:</strong> ${escapeHtml(template.subject)}</p>
						<p><strong>Класс:</strong> ${escapeHtml(template.class)}</p>
						<p><strong>Тип работы:</strong> ${escapeHtml(workTypes[template.workType]?.name || template.workType)}</p>
						<p><strong>Тема:</strong> ${escapeHtml(template.data.test.theme || 'Не указана')}</p>
						<p><strong>Цели:</strong> ${escapeHtml(template.data.test.goals || 'Не указаны')}</p>
						<p><strong>Дата:</strong> ${escapeHtml(template.date)}</p>
					</div>
					
					<div style="background: #e8f4f8; padding: 15px; border-radius: 8px; margin: 15px 0;">
						<h4>?? Задания (${template.taskCount})</h4>
						<table class="table" style="font-size: 0.9em;">
							<thead>
								<tr>
									<th>#</th>
									<th>Тип</th>
									<th>Уровень</th>
									<th>Макс. балл</th>
									<th>Описание</th>
								</tr>
							</thead>
							<tbody>
			`;
			
			template.data.tasks.forEach((task, i) => {
				const levelName = complexityLevels[task.level]?.name || task.level;
				const safeDescription = escapeHtml(task.description || '');
				
				html += `
					<tr>
						<td>${i + 1}</td>
						<td>${escapeHtml(task.type)}</td>
						<td><span style="padding: 2px 6px; border-radius: 4px; background: ${complexityLevels[task.level]?.color || '#ccc'}; color: white;">${escapeHtml(levelName)}</span></td>
						<td>${task.maxScore}</td>
						<td style="max-width: 300px; word-wrap: break-word;">${safeDescription}</td>
					</tr>
				`;
			});
			
			html += `
							</tbody>
						</table>
					</div>
					
					<div style="text-align: center; margin-top: 20px;">
						<button class="btn btn-success" onclick="useThisTemplate(${index}); hideModal()">
							? Использовать этот шаблон
						</button>
					</div>
				</div>
			`;
			
			showModal('Предпросмотр шаблона', html);
		}

		// Функция для очистки JSON от проблемных символов
		function cleanJSON(jsonString) {
			if (!jsonString) return '';
			
			// 1. Убираем BOM
			if (jsonString.charCodeAt(0) === 0xFEFF) {
				jsonString = jsonString.slice(1);
			}
			
			// 2. Заменяем проблемные Unicode символы
			const replacements = {
				'\u2013': '-',  // Длинное тире
				'\u2014': '-',  // Тире
				'\u2018': "'",  // Левая кавычка
				'\u2019': "'",  // Правая кавычка  
				'\u201C': '"',  // Левая двойная кавычка
				'\u201D': '"',  // Правая двойная кавычка
				'\u00A0': ' ',  // Неразрывный пробел
				'\u2026': '...', // Многоточие
				'\u00AB': '"',  // Левая угловая кавычка
				'\u00BB': '"',  // Правая угловая кавычка
				'\u201E': '"',  // Нижняя двойная кавычка
				'\u201A': "'",  // Нижняя одинарная кавычка
			};
			
			Object.keys(replacements).forEach(key => {
				const regex = new RegExp(key, 'g');
				jsonString = jsonString.replace(regex, replacements[key]);
			});
			
			// 3. Убираем непечатаемые символы (кроме нормальных пробелов и переносов)
			jsonString = jsonString.replace(/[\x00-\x09\x0B\x0C\x0E-\x1F\x7F]/g, '');
			
			// 4. Нормализуем переносы строк
			jsonString = jsonString.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
			
			// 5. Экранируем обратные кавычки в тексте (очень важно!)
			jsonString = jsonString.replace(/`/g, '\\`');
			
			return jsonString;
		}
		
		
		function showTemplateConfirmation(template) {
			const html = `
				<div style="max-width: 600px;">
					<h3>?? Импорт шаблона</h3>
					
					<div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0;">
						<h4>${template.data.test.theme || 'Шаблон работы'}</h4>
						<p><strong>?? Предмет:</strong> ${template.subject}</p>
						<p><strong>?? Класс:</strong> ${template.class}</p>
						<p><strong>?? Тип работы:</strong> ${workTypes[template.workType]?.name || template.workType}</p>
						<p><strong>?? Заданий:</strong> ${template.taskCount}</p>
						<p><strong>?? Дата создания:</strong> ${template.date}</p>
					</div>
					
					<div style="background: #fff3cd; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #f39c12;">
						<h4>?? Внимание!</h4>
						<p>Текущие данные будут заменены данными из шаблона.</p>
						<p>Вы можете настроить параметры после импорта.</p>
					</div>
					
					<div class="form-group">
						<label>
							<input type="checkbox" id="keepStudents" checked>
							Сохранить текущих учащихся
						</label>
						<small style="display: block; color: #666; margin-left: 20px;">
							Имена учащихся не будут заменены, только их результаты
						</small>
					</div>
					
					<div class="form-group">
						<label>
							<input type="checkbox" id="keepSettings" checked>
							Сохранить настройки класса и даты
						</label>
						<small style="display: block; color: #666; margin-left: 20px;">
							Текущие класс и дата теста останутся без изменений
						</small>
					</div>
				</div>
				
				<div style="margin-top: 20px; display: flex; gap: 10px; justify-content: flex-end;">
					<button class="btn btn-secondary" onclick="previewTemplate(${window.templateFilesData.findIndex(t => t === template)})">
						??? Предпросмотр
					</button>
					<button class="btn btn-danger" onclick="hideModal()">Отмена</button>
					<button class="btn btn-success" onclick="useTemplate('${encodeURIComponent(JSON.stringify(template.data))}', '${template.file.name}')">
						Импортировать шаблон
					</button>
				</div>
			`;
			
			showModal('Подтверждение импорта шаблона', html);
		}
		function addBootstrapStyles() {
			if (!document.getElementById('bootstrap-mini')) {
				const style = document.createElement('style');
				style.id = 'bootstrap-mini';
				style.textContent = `
					.btn {
						display: inline-block;
						font-weight: 400;
						text-align: center;
						white-space: nowrap;
						vertical-align: middle;
						user-select: none;
						border: 1px solid transparent;
						padding: 0.375rem 0.75rem;
						font-size: 1rem;
						line-height: 1.5;
						border-radius: 0.25rem;
						transition: all 0.15s ease-in-out;
						cursor: pointer;
					}
					.btn-success {
						color: #fff;
						background-color: #28a745;
						border-color: #28a745;
					}
					.btn-danger {
						color: #fff;
						background-color: #dc3545;
						border-color: #dc3545;
					}
					.btn-primary {
						color: #fff;
						background-color: #007bff;
						border-color: #007bff;
					}
					.btn-info {
						color: #fff;
						background-color: #17a2b8;
						border-color: #17a2b8;
					}
					.btn-secondary {
						color: #fff;
						background-color: #6c757d;
						border-color: #6c757d;
					}
					.btn-outline-success {
						color: #28a745;
						background-color: transparent;
						border-color: #28a745;
					}
					.btn-outline-danger {
						color: #dc3545;
						background-color: transparent;
						border-color: #dc3545;
					}
					.btn-outline-secondary {
						color: #6c757d;
						background-color: transparent;
						border-color: #6c757d;
					}
					.btn-outline-info {
						color: #17a2b8;
						background-color: transparent;
						border-color: #17a2b8;
					}
					.btn-outline-warning {
						color: #ffc107;
						background-color: transparent;
						border-color: #ffc107;
					}
					.btn-sm {
						padding: 0.25rem 0.5rem;
						font-size: 0.875rem;
						line-height: 1.5;
						border-radius: 0.2rem;
					}
					.btn:hover {
						opacity: 0.8;
					}
					.btn:disabled {
						opacity: 0.65;
						cursor: not-allowed;
					}
					.btn-group {
						position: relative;
						display: inline-flex;
						vertical-align: middle;
					}
					.btn-group > .btn {
						position: relative;
						flex: 1 1 auto;
					}
					.btn-group > .btn:not(:last-child) {
						border-top-right-radius: 0;
						border-bottom-right-radius: 0;
					}
					.btn-group > .btn:not(:first-child) {
						border-top-left-radius: 0;
						border-bottom-left-radius: 0;
						margin-left: -1px;
					}
					.badge {
						display: inline-block;
						padding: 0.25em 0.4em;
						font-size: 75%;
						font-weight: 700;
						line-height: 1;
						text-align: center;
						white-space: nowrap;
						vertical-align: baseline;
						border-radius: 0.25rem;
					}
					.badge-success {
						color: #fff;
						background-color: #28a745;
					}
					.badge-warning {
						color: #212529;
						background-color: #ffc107;
					}
					.badge-secondary {
						color: #fff;
						background-color: #6c757d;
					}
					.badge-light {
						color: #212529;
						background-color: #f8f9fa;
					}
					.form-control {
						display: block;
						width: 100%;
						padding: 0.375rem 0.75rem;
						font-size: 1rem;
						line-height: 1.5;
						color: #495057;
						background-color: #fff;
						background-clip: padding-box;
						border: 1px solid #ced4da;
						border-radius: 0.25rem;
						transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
					}
					.form-control-sm {
						padding: 0.25rem 0.5rem;
						font-size: 0.875rem;
						line-height: 1.5;
						border-radius: 0.2rem;
					}
					.form-control:focus {
						color: #495057;
						background-color: #fff;
						border-color: #80bdff;
						outline: 0;
						box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
					}
					.card {
						position: relative;
						display: flex;
						flex-direction: column;
						min-width: 0;
						word-wrap: break-word;
						background-color: #fff;
						background-clip: border-box;
						border: 1px solid rgba(0, 0, 0, 0.125);
						border-radius: 0.25rem;
					}
					.card-header {
						padding: 0.75rem 1.25rem;
						margin-bottom: 0;
						background-color: rgba(0, 0, 0, 0.03);
						border-bottom: 1px solid rgba(0, 0, 0, 0.125);
					}
					.card-header:first-child {
						border-radius: calc(0.25rem - 1px) calc(0.25rem - 1px) 0 0;
					}
					.card-body {
						flex: 1 1 auto;
						padding: 1.25rem;
					}
					.table {
						width: 100%;
						margin-bottom: 1rem;
						color: #212529;
						border-collapse: collapse;
					}
					.table th,
					.table td {
						padding: 0.75rem;
						vertical-align: top;
						border-top: 1px solid #dee2e6;
					}
					.table thead th {
						vertical-align: bottom;
						border-bottom: 2px solid #dee2e6;
					}
					.table-hover tbody tr:hover {
						color: #212529;
						background-color: rgba(0, 0, 0, 0.075);
					}
					.table-sm th,
					.table-sm td {
						padding: 0.3rem;
					}
					.table-responsive {
						display: block;
						width: 100%;
						overflow-x: auto;
						-webkit-overflow-scrolling: touch;
					}
					.bg-primary {
						background-color: #007bff !important;
					}
					.bg-light {
						background-color: #f8f9fa !important;
					}
					.text-white {
						color: #fff !important;
					}
					.text-muted {
						color: #6c757d !important;
					}
					.alert {
						position: relative;
						padding: 0.75rem 1.25rem;
						margin-bottom: 1rem;
						border: 1px solid transparent;
						border-radius: 0.25rem;
					}
					.alert-info {
						color: #0c5460;
						background-color: #d1ecf1;
						border-color: #bee5eb;
					}
					.progress {
						display: flex;
						height: 1rem;
						overflow: hidden;
						font-size: 0.75rem;
						background-color: #e9ecef;
						border-radius: 0.25rem;
					}
					.progress-bar {
						display: flex;
						flex-direction: column;
						justify-content: center;
						color: #fff;
						text-align: center;
						white-space: nowrap;
						background-color: #007bff;
						transition: width 0.6s ease;
					}
					.bg-success {
						background-color: #28a745 !important;
					}
					.bg-warning {
						background-color: #ffc107 !important;
					}
					.bg-secondary {
						background-color: #6c757d !important;
					}
					.mb-0 { margin-bottom: 0 !important; }
					.mb-2 { margin-bottom: 0.5rem !important; }
					.mb-3 { margin-bottom: 1rem !important; }
					.mb-4 { margin-bottom: 1.5rem !important; }
					.mt-2 { margin-top: 0.5rem !important; }
					.mr-2 { margin-right: 0.5rem !important; }
					.p-2 { padding: 0.5rem !important; }
					.d-flex { display: flex !important; }
					.justify-content-between { justify-content: space-between !important; }
					.align-items-center { align-items: center !important; }
					.align-middle { vertical-align: middle !important; }
					.small { font-size: 80%; }
				`;
				document.head.appendChild(style);
			}
		}
		function useTemplate(encodedData, fileName) {
			try {
				const templateData = JSON.parse(decodeURIComponent(encodedData));
				const keepStudents = document.getElementById('keepStudents')?.checked;
				const keepSettings = document.getElementById('keepSettings')?.checked;
				
				// Сохраняем текущие данные
				const currentStudents = [...appData.students];
				const currentResults = [...appData.results];
				const currentSettings = { 
					class: appData.test.class, 
					testDate: appData.test.testDate 
				};
				
				// Заменяем основные данные
				appData.test = { ...templateData.test };
				appData.tasks = [...templateData.tasks];
				
				// Восстанавливаем настройки если нужно
				if (keepSettings) {
					appData.test.class = currentSettings.class;
					appData.test.testDate = currentSettings.testDate;
				}
				
				// Восстанавливаем учащихся если нужно
				if (keepStudents && currentStudents.length > 0) {
					appData.students = currentStudents;
					appData.results = currentResults.map(studentResults => 
						new Array(appData.tasks.length).fill(0)
					);
				} else {
					appData.students = templateData.students || [];
					appData.results = templateData.results || [];
				}
				
				// Синхронизируем массивы
				robustSyncData();
				
				// Сохраняем информацию о шаблоне
				appData.templates.lastTemplatePath = fileName;
				appData.templates.lastTemplateName = templateData.test.theme;
				
				// Сохраняем и обновляем
				saveData();
				renderAll();
				hideModal();
				
				showNotification(`? Шаблон "${templateData.test.theme}" успешно импортирован!`, 'success');
				
			} catch (error) {
				console.error('Ошибка импорта шаблона:', error);
				showNotification('? Ошибка импорта шаблона: ' + error.message, 'error');
			}
		}

		function useThisTemplate(index) {
			const template = window.templateFilesData[index];
			if (template) {
				useTemplate(encodeURIComponent(JSON.stringify(template.data)), template.file.name);
			}
		}		
		
		function getWorkTypeIcon(workType) {
			const icons = {
				current: '??',
				milestone: '??',
				final: '??',
				oge: '??',
				ege: '??',
				vpr: '??',
				func_literacy: '??',
				diagnostic: '??',
				psychology: '??'
			};
			return icons[workType] || '??';
		}

		// Функция для быстрого импорта последнего шаблона
		function importLastTemplate() {
			if (appData.templates.lastTemplatePath) {
				// Можно реализовать поиск и загрузку последнего использованного шаблона
				showNotification('Функция в разработке', 'info');
			} else {
				showNotification('Нет информации о последнем шаблоне', 'warning');
			}
		}		
		
		// ==================== ЗАЩИТА ОТ ОШИБОК В ВЫЧИСЛЕНИЯХ ====================
		function safeCalculateGrade(totalScore) {
			try {
				if (typeof totalScore !== 'number' || isNaN(totalScore)) {
					return 2;
				}
				
				if (!appData.test || !appData.test.criteria) {
					return 2;
				}
				
				// Ищем подходящую оценку
				for (let grade of [5, 4, 3, 2]) {
					const criteria = appData.test.criteria[grade];
					if (criteria && 
						typeof criteria.min === 'number' && 
						typeof criteria.max === 'number' &&
						totalScore >= criteria.min && 
						totalScore <= criteria.max) {
						return grade;
					}
				}
				
				return 2; // По умолчанию
			} catch (error) {
				console.warn('Ошибка расчета оценки:', error);
				return 2;
			}
		}

		function safeCalculatePercentage(score, max) {
			try {
				if (typeof score !== 'number' || isNaN(score) || 
					typeof max !== 'number' || isNaN(max) || max <= 0) {
					return 0;
				}
				
				const percentage = (score / max) * 100;
				return Math.min(Math.max(percentage, 0), 100); // Ограничиваем 0-100%
			} catch (error) {
				console.warn('Ошибка расчета процента:', error);
				return 0;
			}
		}

		function safeArrayReduce(arr, callback, initialValue) {
			try {
				if (!Array.isArray(arr) || arr.length === 0) {
					return initialValue || 0;
				}
				
				return arr.reduce(callback, initialValue);
			} catch (error) {
				console.warn('Ошибка в reduce:', error);
				return initialValue || 0;
			}
		}

        // 1. АВТОСОХРАНЕНИЕ И РЕЗЕРВНОЕ КОПИРОВАНИЕ

        function scheduleAutoSave() {
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(() => {
                saveData();
                createBackup();
                showNotification('Данные автоматически сохранены', 'success');
            }, 2000);
        }

        function createBackup() {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const backup = {
                data: JSON.parse(JSON.stringify(appData)),
                timestamp: new Date().toLocaleString(),
                version: '1.0'
            };
            
            localStorage.setItem(`backup_${timestamp}`, JSON.stringify(backup));
            
            // Храним только последние 5 резервных копий
            const backups = Object.keys(localStorage)
                .filter(key => key.startsWith('backup_'))
                .sort()
                .reverse()
                .slice(5);
            
            backups.forEach(key => localStorage.removeItem(key));
        }

        function restoreBackupDialog() {
            const backups = Object.keys(localStorage)
                .filter(key => key.startsWith('backup_'))
                .map(key => ({
                    key,
                    data: JSON.parse(localStorage.getItem(key)),
                    date: new Date(key.replace('backup_', '').replace(/-/g, ':'))
                }))
                .sort((a, b) => b.date - a.date);
            
            if (backups.length === 0) {
                alert('Резервные копии не найдены');
                return;
            }
            
            let html = '<h3>Выберите резервную копию для восстановления:</h3>';
            backups.forEach((backup, index) => {
                html += `
                    <div class="backup-item" onclick="restoreBackup('${backup.key}')">
                        <strong>${backup.data.timestamp}</strong><br>
                        <small>${backup.data.data.test.subject} - ${backup.data.data.test.class}</small>
                    </div>
                `;
            });
            
            showModal('Восстановление резервной копии', html);
        }

        function restoreBackup(backupKey) {
            const backup = JSON.parse(localStorage.getItem(backupKey));
            if (backup && confirm('Восстановить эту резервную копию? Текущие данные будут потеряны.')) {
                appData = backup.data;
                saveData();
                renderAll();
                hideModal();
                showNotification('Резервная копия восстановлена', 'success');
            }
        }

        // 2. УВЕДОМЛЕНИЯ И МОДАЛЬНЫЕ ОКНА
        function showNotification(message, type = 'info') {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `notification ${type} show`;
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        function showModal(title, content) {
            const modalOverlay = document.getElementById('modalOverlay');
            const modalContent = document.getElementById('modalContent');
            
            modalContent.innerHTML = `
                <h2>${title}</h2>
                ${content}
                <div style="margin-top: 20px; text-align: right;">
                    <button class="btn" onclick="hideModal()">Закрыть</button>
                </div>
            `;
            
            modalOverlay.classList.add('show');
        }

        function hideModal() {
            document.getElementById('modalOverlay').classList.remove('show');
        }
		
		function renderVisualizationSection() {
			const container = document.getElementById('visualizationContainer');
			if (!container) {
				console.error('Контейнер visualizationContainer не найден!');
				return;
			}
			
			console.log('Отрисовка раздела с графиками...');
			
			container.innerHTML = `
				<div style="margin-bottom: 30px;">
					<h2 style="margin-bottom: 20px;">?? Визуализация результатов</h2>
					
					<div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
						<button class="btn" onclick="updateVisualization()" style="margin-right: 10px;">
							?? Обновить графики
						</button>
						<button class="btn" onclick="exportCharts()" style="margin-right: 10px;">
							?? Экспорт графиков
						</button>
						<button class="btn" onclick="debugCharts()">
							?? Отладка
						</button>
					</div>
					
					<div class="charts-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 20px;">
						<!-- График распределения оценок -->
						<div class="chart-card" style="background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
							<h3 style="margin-top: 0; margin-bottom: 15px; color: #2c3e50;">
								?? Распределение оценок
							</h3>
							<div style="position: relative; height: 300px;">
								<canvas id="gradesChart"></canvas>
							</div>
							<p style="margin-top: 10px; font-size: 12px; color: #666; text-align: center;">
								Распределение учащихся по полученным оценкам
							</p>
						</div>
						
						<!-- График решаемости заданий -->
						<div class="chart-card" style="background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
							<h3 style="margin-top: 0; margin-bottom: 15px; color: #2c3e50;">
								?? Решаемость заданий
							</h3>
							<div style="position: relative; height: 300px;">
								<canvas id="solvabilityChart"></canvas>
							</div>
							<p style="margin-top: 10px; font-size: 12px; color: #666; text-align: center;">
								Процент выполнения каждого задания
							</p>
						</div>
						
						<!-- График связи сложности и решаемости -->
						<div class="chart-card" style="background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
							<h3 style="margin-top: 0; margin-bottom: 15px; color: #2c3e50;">
								?? Сложность vs Решаемость
							</h3>
							<div style="position: relative; height: 300px;">
								<canvas id="complexityChart"></canvas>
							</div>
							<p style="margin-top: 10px; font-size: 12px; color: #666; text-align: center;">
								Зависимость между уровнем сложности и процентом выполнения
							</p>
						</div>
					</div>
					
					<!-- Тепловая карта -->
					<div class="chart-card" style="background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-top: 30px;">
						<h3 style="margin-top: 0; margin-bottom: 15px; color: #2c3e50;">
							?? Тепловая карта результатов
						</h3>
						<div id="heatmapContainer"></div>
					</div>
				</div>
			`;
			
			console.log('Canvas элементы созданы, обновляем графики...');
			
			// Небольшая задержка для гарантии рендеринга DOM
			setTimeout(() => {
				updateVisualization();
				console.log('Графики обновлены');
			}, 200);
		}		
        // 3. ГРУППОВЫЕ ОПЕРАЦИИ С ОЦЕНКАМИ
        function showBulkEditScores() {
            const html = `
                <div class="form-group">
                    <label>Действие:</label>
                    <select id="bulkAction">
                        <option value="set">Установить значение</option>
                        <option value="add">Добавить баллы</option>
                        <option value="multiply">Умножить на коэффициент</option>
                        <option value="round">Округлить оценки</option>
                    </select>
                </div>
                
                <div class="form-group" id="bulkValueContainer">
                    <label>Значение:</label>
                    <input type="number" id="bulkValue" value="0" min="0">
                </div>
                
                <div class="form-group">
                    <label>Для заданий:</label>
                    <select id="bulkTasks" multiple style="height: 100px;">
                        ${appData.tasks.map((task, index) => 
                            `<option value="${index}" selected>${index + 1}. ${task.type} (макс: ${task.maxScore})</option>`
                        ).join('')}
                    </select>
                </div>
                
                <div class="form-group">
                    <label>Для учащихся:</label>
                    <select id="bulkStudents" multiple style="height: 100px;">
                        ${appData.students.map((student, index) => 
                            `<option value="${index}" selected>${student}</option>`
                        ).join('')}
                    </select>
                </div>
                
                <button class="btn btn-warning" onclick="applyBulkEdit()">Применить изменения</button>
                <button class="btn" onclick="previewBulkEdit()">Предпросмотр</button>
            `;
            
            showModal('Массовое редактирование оценок', html);
        }

        function applyBulkEdit() {
            const action = document.getElementById('bulkAction').value;
            const value = parseFloat(document.getElementById('bulkValue').value);
            const selectedTasks = Array.from(document.getElementById('bulkTasks').selectedOptions).map(opt => parseInt(opt.value));
            const selectedStudents = Array.from(document.getElementById('bulkStudents').selectedOptions).map(opt => parseInt(opt.value));
            
            let changes = 0;
            
            selectedStudents.forEach(studentIndex => {
                selectedTasks.forEach(taskIndex => {
                    const oldValue = appData.results[studentIndex][taskIndex];
                    let newValue = oldValue;
                    const maxScore = appData.tasks[taskIndex].maxScore;
                    
                    switch(action) {
                        case 'set':
                            newValue = Math.min(value, maxScore);
                            break;
                        case 'add':
                            newValue = Math.min(oldValue + value, maxScore);
                            break;
                        case 'multiply':
                            newValue = Math.min(oldValue * value, maxScore);
                            break;
                        case 'round':
                            newValue = Math.round(oldValue);
                            break;
                    }
                    
                    if (newValue !== oldValue) {
                        appData.results[studentIndex][taskIndex] = Math.max(0, newValue);
                        changes++;
                    }
                });
            });
            
            saveData();
            renderResults();
            hideModal();
            showNotification(`Изменено ${changes} оценок`, 'success');
        }

        // 4. СРАВНИТЕЛЬНЫЙ АНАЛИЗ И ТРЕНДЫ
        function saveHistoricalData() {
            const snapshot = {
                timestamp: new Date().toISOString(),
                data: JSON.parse(JSON.stringify(appData)),
                summary: generateWorkSummary()
            };
            
            const history = JSON.parse(localStorage.getItem('workHistory') || '[]');
            history.push(snapshot);
            localStorage.setItem('workHistory', JSON.stringify(history.slice(-50)));
        }
		
		// ==================== УПРАВЛЕНИЕ ОШИБКАМИ ====================

		function saveCriteriaSettings() {
			saveData();
			showNotification("Критерии оценивания сохранены!", "success");
		}

		function loadDefaultCriteria() {
			const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0) || 100;
			
			appData.test.criteria = {
				1: { min: 0, max: Math.round(maxPossible * 0.49) },
				2: { min: Math.round(maxPossible * 0.5), max: Math.round(maxPossible * 0.69) },
				3: { min: Math.round(maxPossible * 0.7), max: Math.round(maxPossible * 0.84) },
				4: { min: Math.round(maxPossible * 0.85), max: maxPossible }
			};
			
			renderCriteriaSettings();
			showNotification("Загружены стандартные критерии", "success");
		}

		function generateAutoCriteria() {
			const type = appData.test.criteriaType || 'points';
			const count = appData.test.criteriaCount || 4;
			const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0) || 100;
			
			if (type === 'percentage') {
				const step = 100 / count;
				for (let i = 1; i <= count; i++) {
					appData.test.criteria[i] = {
						min: Math.round((i-1) * step),
						max: Math.round(i * step)
					};
				}
				appData.test.criteria[count].max = 100;
			} else {
				const step = maxPossible / count;
				for (let i = 1; i <= count; i++) {
					appData.test.criteria[i] = {
						min: Math.round((i-1) * step),
						max: Math.round(i * step)
					};
				}
				appData.test.criteria[count].max = maxPossible;
			}
			
			renderCriteriaSettings();
			showNotification("Критерии сгенерированы автоматически", "success");
		}

		// Функция для отображения оценки в интерфейсе
		function getGradeDisplay(gradeValue) {
			console.log('getGradeDisplay called with:', gradeValue, typeof gradeValue);
			
			// Если gradeValue - строка (например, из customCriteria.name), возвращаем как есть
			if (typeof gradeValue === 'string') {
				return gradeValue;
			}
			
			// Если gradeValue - число
			const numericGrade = Number(gradeValue);
			const system = appData.test.criteriaSystem;
			
			// Для кастомной системы, если grade - число, пытаемся найти соответствующее название
			if (system === 'custom' && appData.test.customCriteria) {
				const criterion = appData.test.customCriteria[numericGrade - 1];
				if (criterion && criterion.name) {
					return criterion.name;
				}
			}
			
			// Для числовых систем добавляем описание
			const gradeDescriptions = {
				'1': '1 (Неудовлетворительно)',
				'2': '2 (Неудовлетворительно)',
				'3': '3 (Удовлетворительно)',
				'4': '4 (Хорошо)',
				'5': '5 (Отлично)',
				'6': '6 (Хорошо)',
				'7': '7 (Очень хорошо)',
				'8': '8 (Отлично)',
				'9': '9 (Превосходно)',
				'10': '10 (Безупречно)'
			};
			
			const displayValue = gradeDescriptions[String(numericGrade)] || String(numericGrade);
			console.log('Display value:', displayValue);
			return displayValue;
		}

		// 1. ФУНКЦИЯ ДЛЯ УДАЛЕНИЯ ОШИБКИ
		function deleteError(errorIndex) {
			if (errorIndex >= 0 && errorIndex < appData.errors.length) {
				const error = appData.errors[errorIndex];
				const studentName = appData.students[error.studentIndex] || `Учащийся ${error.studentIndex + 1}`;
				const taskNumber = error.taskIndex + 1;
				
				if (confirm(`Удалить ошибку?\n\nУчащийся: ${studentName}\nЗадание: ${taskNumber}\nТип: ${errorTypes[error.type]?.name || error.type}`)) {
					appData.errors.splice(errorIndex, 1);
					saveData();
					renderResults();
					showNotification('Ошибка удалена', 'success');
				}
			}
		}

		// 2. ФУНКЦИЯ ДЛЯ РЕДАКТИРОВАНИЯ ОШИБКИ
		function editError(errorIndex) {
			if (errorIndex >= 0 && errorIndex < appData.errors.length) {
				const error = appData.errors[errorIndex];
				
				const html = `
					<h3>?? Редактирование ошибки</h3>
					
					<div class="form-group">
						<label>Учащийся:</label>
						<select id="editErrorStudent">
							${appData.students.map((student, index) => 
								`<option value="${index}" ${index === error.studentIndex ? 'selected' : ''}>
									${student}
								</option>`
							).join('')}
						</select>
					</div>
					
					<div class="form-group">
						<label>Задание:</label>
						<select id="editErrorTask">
							${appData.tasks.map((task, index) => 
								`<option value="${index}" ${index === error.taskIndex ? 'selected' : ''}>
									${index + 1}. ${task.type}
								</option>`
							).join('')}
						</select>
					</div>
					
					<div class="form-group">
						<label>Тип ошибки:</label>
						<select id="editErrorType">
							${Object.entries(errorTypes).map(([key, data]) => 
								`<option value="${key}" ${key === error.type ? 'selected' : ''}>
									${data.name}
								</option>`
							).join('')}
						</select>
					</div>
					
					<div class="form-group">
						<label>Описание ошибки:</label>
						<textarea id="editErrorDescription" rows="3">${error.description || ''}</textarea>
					</div>
					
					<div class="form-group">
						<label>Количество повторений:</label>
						<input type="number" id="editErrorCount" min="1" value="${error.count || 1}">
					</div>
				`;
				
				showModal('Редактирование ошибки', html + `
					<div style="margin-top: 20px; display: flex; gap: 10px; justify-content: flex-end;">
						<button class="btn btn-danger" onclick="deleteError(${errorIndex}); hideModal()">??? Удалить</button>
						<button class="btn" onclick="hideModal()">Отмена</button>
						<button class="btn btn-success" onclick="saveEditedError(${errorIndex})">?? Сохранить</button>
					</div>
				`);
			}
		}

		// 3. СОХРАНЕНИЕ ОТРЕДАКТИРОВАННОЙ ОШИБКИ
		function saveEditedError(errorIndex) {
			const studentIndex = parseInt(document.getElementById('editErrorStudent').value);
			const taskIndex = parseInt(document.getElementById('editErrorTask').value);
			const type = document.getElementById('editErrorType').value;
			const description = document.getElementById('editErrorDescription').value;
			const count = parseInt(document.getElementById('editErrorCount').value) || 1;
			
			if (!description.trim()) {
				showNotification("Введите описание ошибки!", "error");
				return;
			}
			
			appData.errors[errorIndex] = {
				studentIndex,
				taskIndex,
				type,
				description,
				count
			};
			
			saveData();
			renderResults();
			hideModal();
			showNotification("Ошибка отредактирована", "success");
		}

		// 4. МАССОВОЕ УДАЛЕНИЕ ОШИБОК
		function showBulkDeleteErrors() {
			if (appData.errors.length === 0) {
				showNotification("Нет ошибок для удаления", "info");
				return;
			}
			
			let html = `
				<h3>??? Массовое удаление ошибок</h3>
				<p>Выберите ошибки для удаления:</p>
				
				<div style="max-height: 400px; overflow-y: auto; margin: 15px 0;">
					<table style="width: 100%; font-size: 12px;">
						<thead>
							<tr>
								<th><input type="checkbox" id="selectAllErrors" onclick="toggleAllErrors()"></th>
								<th>№</th>
								<th>Учащийся</th>
								<th>Задание</th>
								<th>Тип ошибки</th>
								<th>Описание</th>
							</tr>
						</thead>
						<tbody>
			`;
			
			appData.errors.forEach((error, index) => {
				const studentName = appData.students[error.studentIndex] || `Уч. ${error.studentIndex + 1}`;
				const taskInfo = appData.tasks[error.taskIndex] ? `№${error.taskIndex + 1}` : 'Задание';
				const errorType = errorTypes[error.type]?.name || error.type;
				
				html += `
					<tr>
						<td><input type="checkbox" class="error-checkbox" value="${index}"></td>
						<td>${index + 1}</td>
						<td>${studentName}</td>
						<td>${taskInfo}</td>
						<td><span class="error-type error-${error.type}">${errorType}</span></td>
						<td>${error.description || ''}</td>
					</tr>
				`;
			});
			
			html += `
						</tbody>
					</table>
				</div>
				
				<div style="margin-top: 15px;">
					<p>Выбрано: <span id="selectedCount">0</span> из ${appData.errors.length} ошибок</p>
				</div>
				
				<div class="form-group">
					<label>Фильтр для быстрого выбора:</label>
					<div style="display: flex; gap: 10px; flex-wrap: wrap;">
						<button class="btn btn-sm" onclick="selectByType('calculation')">Вычислительные</button>
						<button class="btn btn-sm" onclick="selectByType('conceptual')">Концептуальные</button>
						<button class="btn btn-sm" onclick="selectByType('attention')">Внимательности</button>
						<button class="btn btn-sm" onclick="selectAllErrors()">Выбрать все</button>
						<button class="btn btn-sm" onclick="deselectAllErrors()">Снять все</button>
					</div>
				</div>
				
				<div class="form-group">
					<label>Удалить ошибки для учащегося:</label>
					<select id="filterStudent" onchange="selectByStudent()">
						<option value="">Все учащиеся</option>
						${appData.students.map((student, index) => 
							`<option value="${index}">${student}</option>`
						).join('')}
					</select>
				</div>
			`;
			
			showModal('Массовое удаление ошибок', html + `
				<div style="margin-top: 20px; display: flex; gap: 10px; justify-content: flex-end;">
					<button class="btn" onclick="hideModal()">Отмена</button>
					<button class="btn btn-danger" onclick="deleteSelectedErrors()">??? Удалить выбранные</button>
				</div>
			`);
			
			// Обновляем счетчик при изменении выбора
			document.querySelectorAll('.error-checkbox').forEach(checkbox => {
				checkbox.addEventListener('change', updateSelectedCount);
			});
		}

		// 5. ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ДЛЯ МАССОВОГО УДАЛЕНИЯ
		function toggleAllErrors() {
			const selectAll = document.getElementById('selectAllErrors');
			const checkboxes = document.querySelectorAll('.error-checkbox');
			
			checkboxes.forEach(checkbox => {
				checkbox.checked = selectAll.checked;
			});
			
			updateSelectedCount();
		}

		function selectAllErrors() {
			document.querySelectorAll('.error-checkbox').forEach(checkbox => {
				checkbox.checked = true;
			});
			document.getElementById('selectAllErrors').checked = true;
			updateSelectedCount();
		}

		function deselectAllErrors() {
			document.querySelectorAll('.error-checkbox').forEach(checkbox => {
				checkbox.checked = false;
			});
			document.getElementById('selectAllErrors').checked = false;
			updateSelectedCount();
		}

		function selectByType(errorType) {
			appData.errors.forEach((error, index) => {
				if (error.type === errorType) {
					const checkbox = document.querySelector(`.error-checkbox[value="${index}"]`);
					if (checkbox) checkbox.checked = true;
				}
			});
			updateSelectedCount();
		}

		function selectByStudent() {
			const studentIndex = parseInt(document.getElementById('filterStudent').value);
			
			if (isNaN(studentIndex)) {
				selectAllErrors();
				return;
			}
			
			// Сначала снимаем все
			deselectAllErrors();
			
			// Выбираем только ошибки этого ученика
			appData.errors.forEach((error, index) => {
				if (error.studentIndex === studentIndex) {
					const checkbox = document.querySelector(`.error-checkbox[value="${index}"]`);
					if (checkbox) checkbox.checked = true;
				}
			});
			
			updateSelectedCount();
		}

		function updateSelectedCount() {
			const selected = document.querySelectorAll('.error-checkbox:checked').length;
			document.getElementById('selectedCount').textContent = selected;
		}

		function deleteSelectedErrors() {
			const checkboxes = document.querySelectorAll('.error-checkbox:checked');
			const indexesToDelete = Array.from(checkboxes).map(cb => parseInt(cb.value)).sort((a, b) => b - a);
			
			if (indexesToDelete.length === 0) {
				showNotification("Не выбрано ни одной ошибки", "warning");
				return;
			}
			
			const count = indexesToDelete.length;
			if (!confirm(`Удалить ${count} ошибок? Это действие нельзя отменить.`)) {
				return;
			}
			
			// Удаляем в обратном порядке (чтобы индексы не сдвигались)
			indexesToDelete.forEach(index => {
				appData.errors.splice(index, 1);
			});
			
			saveData();
			renderResults();
			hideModal();
			showNotification(`Удалено ${count} ошибок`, "success");
		}

		// 6. УДАЛЕНИЕ ВСЕХ ОШИБОК УЧАЩЕГОСЯ
		function deleteAllStudentErrors(studentIndex) {
			const studentName = appData.students[studentIndex];
			const studentErrors = appData.errors.filter(e => e.studentIndex === studentIndex);
			
			if (studentErrors.length === 0) {
				showNotification(`У учащегося ${studentName} нет ошибок`, "info");
				return;
			}
			
			if (confirm(`Удалить все ошибки учащегося ${studentName}? (${studentErrors.length} ошибок)`)) {
				appData.errors = appData.errors.filter(e => e.studentIndex !== studentIndex);
				saveData();
				renderResults();
				showNotification(`Удалены все ошибки учащегося ${studentName}`, "success");
			}
		}

		// 7. УДАЛЕНИЕ ВСЕХ ОШИБОК ПО ТИПУ
		function deleteAllErrorsByType(errorType) {
			const typeName = errorTypes[errorType]?.name || errorType;
			const typeErrors = appData.errors.filter(e => e.type === errorType);
			
			if (typeErrors.length === 0) {
				showNotification(`Нет ошибок типа "${typeName}"`, "info");
				return;
			}
			
			if (confirm(`Удалить все ошибки типа "${typeName}"? (${typeErrors.length} ошибок)`)) {
				appData.errors = appData.errors.filter(e => e.type !== errorType);
				saveData();
				renderResults();
				showNotification(`Удалены все ошибки типа "${typeName}"`, "success");
			}
		}

		// 8. МЕНЮ УПРАВЛЕНИЯ ОШИБКАМИ
		function showErrorsManagement() {
			let html = `
				<h3>?? Управление ошибками</h3>
				
				<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
					<div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
						<h4>?? По учащимся</h4>
						<select id="studentForErrors" onchange="updateStudentErrorsInfo()" style="width: 100%; margin-bottom: 10px;">
							<option value="">Выберите учащегося</option>
							${appData.students.map((student, index) => 
								`<option value="${index}">${student}</option>`
							).join('')}
						</select>
						<div id="studentErrorsInfo" style="min-height: 60px;"></div>
						<button class="btn btn-danger btn-sm" onclick="deleteAllStudentErrors(parseInt(document.getElementById('studentForErrors').value))" disabled id="deleteStudentErrorsBtn">
							??? Удалить все ошибки
						</button>
					</div>
					
					<div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
						<h4>?? По типам ошибок</h4>
						<select id="errorTypeFilter" onchange="updateTypeErrorsInfo()" style="width: 100%; margin-bottom: 10px;">
							<option value="">Выберите тип ошибки</option>
							${Object.entries(errorTypes).map(([key, data]) => 
								`<option value="${key}">${data.name}</option>`
							).join('')}
						</select>
						<div id="typeErrorsInfo" style="min-height: 60px;"></div>
						<button class="btn btn-danger btn-sm" onclick="deleteAllErrorsByType(document.getElementById('errorTypeFilter').value)" disabled id="deleteTypeErrorsBtn">
							??? Удалить все ошибки
						</button>
					</div>
				</div>
				
				<div style="background: #fff3cd; padding: 15px; border-radius: 8px; margin: 15px 0;">
					<h4>?? Статистика ошибок</h4>
					<p>Всего ошибок: ${appData.errors.length}</p>
					<p>Учащихся с ошибками: ${new Set(appData.errors.map(e => e.studentIndex)).size}</p>
					<p>Заданий с ошибками: ${new Set(appData.errors.map(e => e.taskIndex)).size}</p>
				</div>
				
				<div style="margin-top: 20px;">
					<button class="btn btn-warning" onclick="showBulkDeleteErrors()">
						??? Массовое удаление ошибок
					</button>
					<button class="btn btn-danger" onclick="deleteAllErrors()" style="margin-left: 10px;">
						?? Удалить все ошибки
					</button>
				</div>
			`;
			
			showModal('Управление ошибками', html + `
				<div style="margin-top: 20px;">
					<button class="btn" onclick="hideModal()">Закрыть</button>
				</div>
			`);
			
			// Инициализация информации
			updateStudentErrorsInfo();
			updateTypeErrorsInfo();
		}

		function updateStudentErrorsInfo() {
			const studentIndex = parseInt(document.getElementById('studentForErrors').value);
			const infoDiv = document.getElementById('studentErrorsInfo');
			const deleteBtn = document.getElementById('deleteStudentErrorsBtn');
			
			if (isNaN(studentIndex)) {
				infoDiv.innerHTML = '<p>Выберите учащегося</p>';
				deleteBtn.disabled = true;
				return;
			}
			
			const studentName = appData.students[studentIndex];
			const studentErrors = appData.errors.filter(e => e.studentIndex === studentIndex);
			
			if (studentErrors.length === 0) {
				infoDiv.innerHTML = `<p>У учащегося <strong>${studentName}</strong> нет ошибок</p>`;
				deleteBtn.disabled = true;
			} else {
				const errorTypesCount = {};
				studentErrors.forEach(error => {
					errorTypesCount[error.type] = (errorTypesCount[error.type] || 0) + 1;
				});
				
				const typesList = Object.entries(errorTypesCount)
					.map(([type, count]) => `${errorTypes[type]?.name}: ${count}`)
					.join(', ');
				
				infoDiv.innerHTML = `
					<p>Учащийся: <strong>${studentName}</strong></p>
					<p>Ошибок: ${studentErrors.length}</p>
					<small>${typesList}</small>
				`;
				deleteBtn.disabled = false;
			}
		}

		function updateTypeErrorsInfo() {
			const errorType = document.getElementById('errorTypeFilter').value;
			const infoDiv = document.getElementById('typeErrorsInfo');
			const deleteBtn = document.getElementById('deleteTypeErrorsBtn');
			
			if (!errorType) {
				infoDiv.innerHTML = '<p>Выберите тип ошибки</p>';
				deleteBtn.disabled = true;
				return;
			}
			
			const typeName = errorTypes[errorType]?.name || errorType;
			const typeErrors = appData.errors.filter(e => e.type === errorType);
			
			if (typeErrors.length === 0) {
				infoDiv.innerHTML = `<p>Нет ошибок типа <strong>${typeName}</strong></p>`;
				deleteBtn.disabled = true;
			} else {
				const studentsWithErrors = new Set(typeErrors.map(e => e.studentIndex)).size;
				
				infoDiv.innerHTML = `
					<p>Тип ошибки: <strong>${typeName}</strong></p>
					<p>Всего ошибок: ${typeErrors.length}</p>
					<p>Учащихся с такими ошибками: ${studentsWithErrors}</p>
				`;
				deleteBtn.disabled = false;
			}
		}

		// 9. УДАЛЕНИЕ ВСЕХ ОШИБОК
		function deleteAllErrors() {
			if (appData.errors.length === 0) {
				showNotification("Нет ошибок для удаления", "info");
				return;
			}
			
			if (confirm(`Удалить ВСЕ ошибки? (${appData.errors.length} ошибок)\nЭто действие нельзя отменить.`)) {
				appData.errors = [];
				saveData();
				renderResults();
				hideModal();
				showNotification("Все ошибки удалены", "success");
			}
		}

		// 10. ОБНОВЛЕННАЯ ФУНКЦИЯ renderResults() С КНОПКАМИ УПРАВЛЕНИЯ
		function renderResults() {
			const container = document.getElementById('resultsContainer');
			container.innerHTML = '';
			
			// Кнопки управления ошибками
			const errorControls = document.createElement('div');
			errorControls.style.marginBottom = '20px';
			errorControls.style.padding = '15px';
			errorControls.style.background = '#f8f9fa';
			errorControls.style.borderRadius = '8px';
			errorControls.innerHTML = `
				<h4>?? Управление ошибками</h4>
				<div style="display: flex; gap: 10px; flex-wrap: wrap;">
					<button class="btn btn-success" onclick="showErrorsManagement()">
						?? Управление ошибками
					</button>
					<button class="btn btn-warning" onclick="showBulkDeleteErrors()">
						??? Массовое удаление
					</button>
					<button class="btn" onclick="exportErrorsToCSV()">
						?? Экспорт ошибок
					</button>
					${appData.errors.length > 0 ? `
						<button class="btn btn-danger" onclick="deleteAllErrors()">
							?? Удалить все ошибки
						</button>
					` : ''}
				</div>
				<p style="margin-top: 10px; color: #666; font-size: 13px;">
					Всего ошибок: ${appData.errors.length} | 
					Учащихся с ошибками: ${new Set(appData.errors.map(e => e.studentIndex)).size}
				</p>
			`;
			
			container.appendChild(errorControls);
				
			if (appData.results.length === 0) {
				for (let i = 0; i < appData.test.presentStudents; i++) {
					appData.results.push(new Array(appData.tasks.length).fill(0));
				}
			}
			
			let html = '<div class="table-container"><table>';
			
			html += '<thead><tr><th>Учащийся</th>';
			for (let i = 0; i < appData.tasks.length; i++) {
				const task = appData.tasks[i];
				html += `<th title="Ур. ${task.level}: ${task.type}">${i+1}</th>`;
			}
			html += '<th>?</th><th>Оценка</th><th>Анализ ошибок</th><th>Действия</th></tr></thead><tbody>';
			
			appData.students.forEach((student, studentIndex) => {
				const scores = appData.results[studentIndex] || [];
				const totalScore = scores.reduce((sum, score) => sum + score, 0);
				const grade = calculateGrade(totalScore);
				console.log(`Student ${studentIndex}: totalScore=${totalScore}, grade=${grade}`);
				const gradeClass = typeof grade === 'string' ? grade.replace(/\s+/g, '-').toLowerCase() : `grade-${grade}`;
				const studentErrors = appData.errors.filter(e => e.studentIndex === studentIndex);
				
				html += `<tr>
					<td><strong>${student}</strong></td>`;
				
				for (let taskIndex = 0; taskIndex < appData.tasks.length; taskIndex++) {
					const maxScore = appData.tasks[taskIndex].maxScore;
					const score = scores[taskIndex] || 0;
					const percentage = (score / maxScore) * 100;
					const heatmapClass = `heatmap-${Math.floor(percentage / 20) * 20}`;
					
					html += `<td class="heatmap-cell ${heatmapClass}">
						<input type="number" min="0" max="${maxScore}" value="${score}" 
							   style="width: 50px; text-align: center; border: none; background: transparent;"
							   onchange="updateResult(${studentIndex}, ${taskIndex}, parseInt(this.value))">
					</td>`;
				}
				
				html += `<td><strong>${totalScore}</strong></td>`;
				//	<td class="grade-${grade}"><strong>${grade}</strong></td>`;
				//html += `<td class="grade-${grade}"><strong>${getGradeDisplay(grade)}</strong></td>`; //добавил тут для теста
				html += `<td class="${gradeClass}"><strong>${getGradeDisplay(grade)}</strong><small style="display: block; font-size: 10px; color: #666;">${totalScore} баллов</small></td>`;
				// Колонка с ошибками
				html += `<td><small>`;
				if (studentErrors.length > 0) {
					studentErrors.forEach((error, errorIndex) => {
						html += `
							<span class="error-type error-${error.type}" 
								  title="${error.description || errorTypes[error.type].desc}"
								  onclick="editError(${appData.errors.indexOf(error)})"
								  style="cursor: pointer; margin: 2px; display: inline-block;">
								${errorTypes[error.type].name}
								<small style="font-size: 9px;">[${error.taskIndex + 1}]</small>
							</span>
						`;
					});
				} else {
					html += '—';
				}
				html += `</small></td>`;
				
				// Колонка с действиями
				html += `<td>
					<button class="btn btn-sm" onclick="showStudentErrors(${studentIndex})" title="Ошибки учащегося">
						??
					</button>
					${studentErrors.length > 0 ? `
						<button class="btn btn-sm btn-danger" onclick="deleteAllStudentErrors(${studentIndex})" title="Удалить все ошибки">
							???
						</button>
					` : ''}
				</td></tr>`;
			});
			
			html += '</tbody></table></div>';
			
			// Форма добавления ошибок
			html += `
				<div class="chart-container">
					<h3>? Добавить анализ ошибок</h3>
					<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
						<div>
							<div class="form-group">
								<label>Учащийся:</label>
								<select id="errorStudent">
									${appData.students.map((student, index) => 
										`<option value="${index}">${student}</option>`
									).join('')}
								</select>
							</div>
							<div class="form-group">
								<label>Задание:</label>
								<select id="errorTask">
									${appData.tasks.map((task, index) => 
										`<option value="${index}">${index + 1}. ${task.type}</option>`
									).join('')}
								</select>
							</div>
						</div>
						<div>
							<div class="form-group">
								<label>Тип ошибки:</label>
								<select id="errorType">
									${Object.entries(errorTypes).map(([key, data]) => 
										`<option value="${key}">${data.name}</option>`
									).join('')}
								</select>
							</div>
							<div class="form-group">
								<label>Описание ошибки:</label>
								<input type="text" id="errorDescription" placeholder="Конкретное описание ошибки...">
							</div>
						</div>
					</div>
					<button class="btn btn-warning" onclick="addError()">? Добавить ошибку</button>
					<button class="btn" onclick="showQuickErrorAdd()" style="margin-left: 10px;">? Быстрое добавление</button>
				</div>
			`;
			
			container.innerHTML += html;
		}
		
		function generateCriteriaSummary() {
			const type = appData.test.criteriaType;
			const system = appData.test.criteriaSystem;
			const count = appData.test.criteriaCount;
			
			let html = '<div class="recommendation-card">';
			html += '<h4>?? Используемые критерии оценивания</h4>';
			
			if (type === 'percentage') {
				html += '<p><strong>Система:</strong> Процентная</p>';
				html += '<table style="width: 100%; font-size: 11pt;">';
				html += '<tr><th>Уровень</th><th>Диапазон</th><th>Описание</th></tr>';
				
				for (let i = 1; i <= count; i++) {
					const criteria = appData.test.criteria[i];
					const customInfo = appData.test.customCriteria[i-1];
					const levelName = system === 'custom' && customInfo ? customInfo.name : 
									system === 'standard' ? (i === 1 ? '2' : i+1) :
									system === 'five_point' ? i :
									system === 'ten_point' ? i : `Уровень ${i}`;
					
					html += `<tr>
						<td><strong>${levelName}</strong></td>
						<td>${criteria?.min || 0}% - ${criteria?.max || 0}%</td>
						<td>${customInfo?.description || ''}</td>
					</tr>`;
				}
				
				html += '</table>';
			} else if (type === 'points') {
				const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0);
				html += `<p><strong>Система:</strong> Балльная (максимум: ${maxPossible} баллов)</p>`;
				html += '<table style="width: 100%; font-size: 11pt;">';
				html += '<tr><th>Уровень</th><th>Диапазон</th><th>В процентах</th><th>Описание</th></tr>';
				
				for (let i = 1; i <= count; i++) {
					const criteria = appData.test.criteria[i];
					const customInfo = appData.test.customCriteria[i-1];
					const levelName = system === 'custom' && customInfo ? customInfo.name : 
									system === 'standard' ? (i === 1 ? '2' : i+1) :
									system === 'five_point' ? i :
									system === 'ten_point' ? i : `Уровень ${i}`;
					
					const minPercent = maxPossible > 0 ? Math.round((criteria?.min || 0) / maxPossible * 100) : 0;
					const maxPercent = maxPossible > 0 ? Math.round((criteria?.max || 0) / maxPossible * 100) : 0;
					
					html += `<tr>
						<td><strong>${levelName}</strong></td>
						<td>${criteria?.min || 0} - ${criteria?.max || 0} баллов</td>
						<td>${minPercent}% - ${maxPercent}%</td>
						<td>${customInfo?.description || ''}</td>
					</tr>`;
				}
				
				html += '</table>';
			} else if (type === 'custom') {
				html += '<p><strong>Система:</strong> Пользовательская шкала</p>';
				html += '<table style="width: 100%; font-size: 11pt;">';
				html += '<tr><th>Уровень</th><th>Диапазон</th><th>Цвет</th><th>Описание</th></tr>';
				
				appData.test.customCriteria.forEach((criterion, index) => {
					html += `<tr>
						<td><strong>${criterion.name}</strong></td>
						<td>${criterion.min} - ${criterion.max} ${criterion.type === 'percentage' ? '%' : 'баллов'}</td>
						<td><div style="width: 20px; height: 20px; background: ${criterion.color}; border: 1px solid #ccc;"></div></td>
						<td>${criterion.description}</td>
					</tr>`;
				});
				
				html += '</table>';
			}
			
			html += '</div>';
			return html;
		}		
		
		// 11. ПРОСМОТР ОШИБОК УЧАЩЕГОСЯ
		function showStudentErrors(studentIndex) {
			const studentName = appData.students[studentIndex];
			const studentErrors = appData.errors.filter(e => e.studentIndex === studentIndex);
			
			if (studentErrors.length === 0) {
				showNotification(`У учащегося ${studentName} нет ошибок`, "info");
				return;
			}
			
			let html = `
				<h3>?? Ошибки учащегося: ${studentName}</h3>
				<p>Всего ошибок: ${studentErrors.length}</p>
				
				<div style="max-height: 400px; overflow-y: auto; margin: 15px 0;">
					<table style="width: 100%; font-size: 12px;">
						<thead>
							<tr>
								<th>№</th>
								<th>Задание</th>
								<th>Тип ошибки</th>
								<th>Описание</th>
								<th>Действия</th>
							</tr>
						</thead>
						<tbody>
			`;
			
			studentErrors.forEach((error, index) => {
				const taskInfo = appData.tasks[error.taskIndex] ? 
					`№${error.taskIndex + 1}. ${appData.tasks[error.taskIndex].type}` : 
					`Задание ${error.taskIndex + 1}`;
				const errorType = errorTypes[error.type]?.name || error.type;
				const globalErrorIndex = appData.errors.indexOf(error);
				
				html += `
					<tr>
						<td>${index + 1}</td>
						<td>${taskInfo}</td>
						<td><span class="error-type error-${error.type}">${errorType}</span></td>
						<td>${error.description || '—'}</td>
						<td>
							<button class="btn btn-sm" onclick="editError(${globalErrorIndex})" title="Редактировать">
								??
							</button>
							<button class="btn btn-sm btn-danger" onclick="deleteError(${globalErrorIndex})" title="Удалить">
								???
							</button>
						</td>
					</tr>
				`;
			});
			
			html += `
						</tbody>
					</table>
				</div>
				
				<div style="margin-top: 20px;">
					<button class="btn btn-danger" onclick="deleteAllStudentErrors(${studentIndex})">
						??? Удалить все ошибки учащегося
					</button>
					<button class="btn" onclick="hideModal()" style="margin-left: 10px;">Закрыть</button>
				</div>
			`;
			
			showModal(`Ошибки учащегося: ${studentName}`, html);
		}

		// 12. БЫСТРОЕ ДОБАВЛЕНИЕ ОШИБОК
		function showQuickErrorAdd() {
			const html = `
				<h3>? Быстрое добавление ошибок</h3>
				<p>Выберите несколько учащихся и заданий для быстрого добавления одинаковых ошибок</p>
				
				<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
					<div>
						<h4>?? Учащиеся:</h4>
						<div style="max-height: 200px; overflow-y: auto; border: 1px solid #ddd; padding: 10px;">
							${appData.students.map((student, index) => `
								<label style="display: block; margin: 5px 0;">
									<input type="checkbox" class="quick-student" value="${index}">
									${student}
								</label>
							`).join('')}
						</div>
						<button class="btn btn-sm" onclick="selectAllQuickStudents()" style="margin-top: 5px;">Выбрать всех</button>
					</div>
					
					<div>
						<h4>?? Задания:</h4>
						<div style="max-height: 200px; overflow-y: auto; border: 1px solid #ddd; padding: 10px;">
							${appData.tasks.map((task, index) => `
								<label style="display: block; margin: 5px 0;">
									<input type="checkbox" class="quick-task" value="${index}">
									${index + 1}. ${task.type}
								</label>
							`).join('')}
						</div>
						<button class="btn btn-sm" onclick="selectAllQuickTasks()" style="margin-top: 5px;">Выбрать все</button>
					</div>
				</div>
				
				<div class="form-group">
					<label>Тип ошибки:</label>
					<select id="quickErrorType">
						${Object.entries(errorTypes).map(([key, data]) => 
							`<option value="${key}">${data.name}</option>`
						).join('')}
					</select>
				</div>
				
				<div class="form-group">
					<label>Описание ошибки:</label>
					<input type="text" id="quickErrorDescription" placeholder="Общее описание для всех ошибок...">
				</div>
			`;
			
			showModal('Быстрое добавление ошибок', html + `
				<div style="margin-top: 20px; display: flex; gap: 10px; justify-content: flex-end;">
					<button class="btn" onclick="hideModal()">Отмена</button>
					<button class="btn btn-success" onclick="addQuickErrors()">? Добавить ошибки</button>
				</div>
			`);
		}

		function selectAllQuickStudents() {
			document.querySelectorAll('.quick-student').forEach(cb => cb.checked = true);
		}

		function selectAllQuickTasks() {
			document.querySelectorAll('.quick-task').forEach(cb => cb.checked = true);
		}

		function addQuickErrors() {
			const selectedStudents = Array.from(document.querySelectorAll('.quick-student:checked'))
				.map(cb => parseInt(cb.value));
			const selectedTasks = Array.from(document.querySelectorAll('.quick-task:checked'))
				.map(cb => parseInt(cb.value));
			const type = document.getElementById('quickErrorType').value;
			const description = document.getElementById('quickErrorDescription').value;
			
			if (selectedStudents.length === 0 || selectedTasks.length === 0) {
				showNotification("Выберите хотя бы одного учащегося и одно задание", "error");
				return;
			}
			
			if (!description.trim()) {
				showNotification("Введите описание ошибки", "error");
				return;
			}
			
			let addedCount = 0;
			
			selectedStudents.forEach(studentIndex => {
				selectedTasks.forEach(taskIndex => {
					// Проверяем, нет ли уже такой ошибки
					const exists = appData.errors.some(e => 
						e.studentIndex === studentIndex && 
						e.taskIndex === taskIndex && 
						e.type === type
					);
					
					if (!exists) {
						appData.errors.push({
							studentIndex,
							taskIndex,
							type,
							description,
							count: 1
						});
						addedCount++;
					}
				});
			});
			
			saveData();
			renderResults();
			hideModal();
			showNotification(`Добавлено ${addedCount} ошибок`, "success");
		}

		// 13. ЭКСПОРТ ОШИБОК В CSV
		function exportErrorsToCSV() {
			if (appData.errors.length === 0) {
				showNotification("Нет ошибок для экспорта", "info");
				return;
			}
			
			let csvContent = "Учащийся;Задание;Тип ошибки;Описание;Количество\n";
			
			appData.errors.forEach(error => {
				const studentName = appData.students[error.studentIndex] || `Уч. ${error.studentIndex + 1}`;
				const taskInfo = appData.tasks[error.taskIndex] ? 
					`№${error.taskIndex + 1}. ${appData.tasks[error.taskIndex].type}` : 
					`Задание ${error.taskIndex + 1}`;
				const errorType = errorTypes[error.type]?.name || error.type;
				const description = error.description || '';
				const count = error.count || 1;
				
				// Экранируем точку с запятой и кавычки
				const safeDescription = description.replace(/;/g, ',').replace(/"/g, "'");
				
				csvContent += `"${studentName}";"${taskInfo}";"${errorType}";"${safeDescription}";${count}\n`;
			});
			
			const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
			const url = URL.createObjectURL(blob);
			const link = document.createElement('a');
			link.href = url;
			link.download = `ошибки_${appData.test.subject || 'предмет'}_${new Date().toISOString().slice(0, 10)}.csv`;
			document.body.appendChild(link);
			link.click();
			document.body.removeChild(link);
			URL.revokeObjectURL(url);
			
			showNotification(`Экспортировано ${appData.errors.length} ошибок в CSV`, "success");
		}

		// 14. ОБНОВИТЬ СТИЛИ CSS ДЛЯ КНОПОК
		const additionalStyles = `
			.btn-sm {
				padding: 4px 8px !important;
				font-size: 12px !important;
			}
			
			.error-type {
				cursor: pointer !important;
				transition: opacity 0.2s !important;
			}
			
			.error-type:hover {
				opacity: 0.8 !important;
				transform: translateY(-1px) !important;
			}
			
			.error-management-panel {
				background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%) !important;
				border-radius: 10px !important;
				padding: 15px !important;
				margin-bottom: 20px !important;
				border-left: 4px solid #3498db !important;
			}
		`;

		// Добавляем стили в head
		const styleSheet = document.createElement("style");
		styleSheet.type = "text/css";
		styleSheet.innerText = additionalStyles;
		document.head.appendChild(styleSheet);		
		
		
        function generateWorkSummary() {
            const totalScores = appData.results.map(scores => scores.reduce((sum, score) => sum + score, 0));
            const grades = totalScores.map(score => calculateGrade(score));
            
            return {
                subject: appData.test.subject,
                class: appData.test.class,
                theme: appData.test.theme,
                date: appData.test.testDate,
                avgScore: totalScores.reduce((sum, score) => sum + score, 0) / totalScores.length,
                successRate: (grades.filter(grade => grade >= 3).length / grades.length * 100),
                qualityRate: (grades.filter(grade => grade >= 4).length / grades.length * 100),
                totalStudents: appData.students.length
            };
        }

        function showComparativeAnalysis() {
            const history = JSON.parse(localStorage.getItem('workHistory') || '[]')
                .filter(item => item.data.test.subject === appData.test.subject && item.data.test.class === appData.test.class)
                .sort((a, b) => new Date(a.data.test.testDate) - new Date(b.data.test.testDate));
            
            if (history.length < 2) {
                alert('Недостаточно данных для сравнительного анализа');
                return;
            }
            
            const currentSummary = generateWorkSummary();
            const previousSummary = history[history.length - 2].summary;
            
            const html = `
                <div class="comparative-grid">
                    <div class="comparative-card">
                        <h4>?? Динамика среднего балла</h4>
                        <div class="comparative-value ${currentSummary.avgScore > previousSummary.avgScore ? 'positive' : 'negative'}">
                            ${currentSummary.avgScore.toFixed(1)} 
                            <span class="trend">${currentSummary.avgScore > previousSummary.avgScore ? '?' : '?'}</span>
                        </div>
                        <div class="comparative-previous">Предыдущий: ${previousSummary.avgScore.toFixed(1)}</div>
                        <div class="comparative-diff ${currentSummary.avgScore > previousSummary.avgScore ? 'positive' : 'negative'}">
                            ${(currentSummary.avgScore - previousSummary.avgScore).toFixed(1)}
                        </div>
                    </div>
                    
                    <div class="comparative-card">
                        <h4>?? Динамика успеваемости</h4>
                        <div class="comparative-value ${currentSummary.successRate > previousSummary.successRate ? 'positive' : 'negative'}">
                            ${currentSummary.successRate.toFixed(1)}%
                            <span class="trend">${currentSummary.successRate > previousSummary.successRate ? '?' : '?'}</span>
                        </div>
                        <div class="comparative-previous">Предыдущий: ${previousSummary.successRate.toFixed(1)}%</div>
                        <div class="comparative-diff ${currentSummary.successRate > previousSummary.successRate ? 'positive' : 'negative'}">
                            ${(currentSummary.successRate - previousSummary.successRate).toFixed(1)}%
                        </div>
                    </div>
                    
                    <div class="comparative-card">
                        <h4>? Динамика качества</h4>
                        <div class="comparative-value ${currentSummary.qualityRate > previousSummary.qualityRate ? 'positive' : 'negative'}">
                            ${currentSummary.qualityRate.toFixed(1)}%
                            <span class="trend">${currentSummary.qualityRate > previousSummary.qualityRate ? '?' : '?'}</span>
                        </div>
                        <div class="comparative-previous">Предыдущий: ${previousSummary.qualityRate.toFixed(1)}%</div>
                        <div class="comparative-diff ${currentSummary.qualityRate > previousSummary.qualityRate ? 'positive' : 'negative'}">
                            ${(currentSummary.qualityRate - previousSummary.qualityRate).toFixed(1)}%
                        </div>
                    </div>
                </div>
                
                <div class="chart-container">
                    <canvas id="trendChart" height="200"></canvas>
                </div>
            `;
            
            showModal('Сравнительный анализ', html);
            
            setTimeout(() => initTrendChart(history), 100);
        }

        function initTrendChart(history) {
            if (window.trendChartInstance) {
                window.trendChartInstance.destroy();
            }
            
            const ctx = document.getElementById('trendChart').getContext('2d');
            const labels = history.map(item => new Date(item.data.test.testDate).toLocaleDateString());
            const avgScores = history.map(item => item.summary.avgScore);
            const successRates = history.map(item => item.summary.successRate);
            
            window.trendChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Средний балл',
                            data: avgScores,
                            borderColor: '#3498db',
                            backgroundColor: 'rgba(52, 152, 219, 0.1)',
                            tension: 0.4,
                            yAxisID: 'y'
                        },
                        {
                            label: 'Успеваемость %',
                            data: successRates,
                            borderColor: '#27ae60',
                            backgroundColor: 'rgba(39, 174, 96, 0.1)',
                            tension: 0.4,
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    scales: {
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            grid: {
                                drawOnChartArea: false,
                            },
                            ticks: {
                                callback: function(value) {
                                    return value + '%';
                                }
                            }
                        },
                    }
                }
            });
        }

        // 5. РАСШИРЕННЫЙ ЭКСПОРТ
        function exportToExcel() {
            try {
                const wb = XLSX.utils.book_new();
                
                // Лист с результатами
                const resultsData = [
                    ['Учащийся', ...appData.tasks.map((t, i) => `Задание ${i+1}`), 'Сумма', 'Оценка']
                ];
                
                appData.students.forEach((student, index) => {
                    const scores = appData.results[index];
                    const total = scores.reduce((sum, score) => sum + score, 0);
                    const grade = calculateGrade(total);
                    resultsData.push([student, ...scores, total, grade]);
                });
                
                const wsResults = XLSX.utils.aoa_to_sheet(resultsData);
                XLSX.utils.book_append_sheet(wb, wsResults, 'Результаты');
                
                // Лист с анализом
                const analysisData = [
                    ['Показатель', 'Значение'],
                    ['Средний балл', calculateAverageScore()],
                    ['Успеваемость', calculateSuccessRate() + '%'],
                    ['Качество знаний', calculateQualityRate() + '%'],
                    ['СОУ', calculateSou() + '%']
                ];
                
                const wsAnalysis = XLSX.utils.aoa_to_sheet(analysisData);
                XLSX.utils.book_append_sheet(wb, wsAnalysis, 'Аналитика');
                
                XLSX.writeFile(wb, `анализ_${appData.test.subject}_${appData.test.class}_${new Date().toLocaleDateString()}.xlsx`);
                showNotification('Excel файл успешно экспортирован', 'success');
            } catch (error) {
                showNotification('Ошибка при экспорте в Excel: ' + error.message, 'error');
            }
        }

		// Резервное решение - создание PDF через canvas
		function exportToPDFCanvas() {
			try {
				// Создаем временный div для рендеринга содержимого
				const tempDiv = document.createElement('div');
				tempDiv.style.cssText = `
					position: fixed;
					left: -10000px;
					top: -10000px;
					width: 210mm;
					padding: 20mm;
					background: white;
					font-family: Arial, sans-serif;
					font-size: 12pt;
					line-height: 1.4;
				`;
				
				// Генерируем содержимое для PDF
				tempDiv.innerHTML = generatePDFContent();
				document.body.appendChild(tempDiv);
				
				// Используем html2canvas для создания изображения
				html2canvas(tempDiv).then(canvas => {
					const imgData = canvas.toDataURL('image/png');
					const { jsPDF } = window.jspdf;
					const pdf = new jsPDF('p', 'mm', 'a4');
					
					const imgWidth = 210;
					const pageHeight = 295;
					const imgHeight = canvas.height * imgWidth / canvas.width;
					let heightLeft = imgHeight;
					let position = 0;
					
					pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
					heightLeft -= pageHeight;
					
					while (heightLeft >= 0) {
						position = heightLeft - imgHeight;
						pdf.addPage();
						pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
						heightLeft -= pageHeight;
					}
					
					pdf.save(`отчет_${appData.test.subject}_${new Date().toLocaleDateString()}.pdf`);
					document.body.removeChild(tempDiv);
					showNotification('PDF файл успешно экспортирован', 'success');
				});
				
			} catch (error) {
				console.error('Ошибка при экспорте в PDF:', error);
				showNotification('Ошибка при экспорте в PDF: ' + error.message, 'error');
			}
		}

		function generatePDFContent() {
			const totalScores = appData.results.map(scores => scores.reduce((sum, score) => sum + score, 0));
			const grades = totalScores.map(score => calculateGrade(score));
			const avgScore = totalScores.reduce((sum, score) => sum + score, 0) / totalScores.length;
			const successRate = (grades.filter(grade => grade >= 3).length / grades.length * 100);
			const qualityRate = (grades.filter(grade => grade >= 4).length / grades.length * 100);
			
			const gradeCounts = {5: 0, 4: 0, 3: 0, 2: 0};
			grades.forEach(grade => gradeCounts[grade]++);
			
			return `
				<div style="text-align: center; margin-bottom: 20px;">
					<h1>Аналитический отчет по диагностической работе</h1>
					<h2>${appData.test.subject}, ${appData.test.class}</h2>
					<p><strong>Тема:</strong> ${appData.test.theme}</p>
					<p><strong>Дата:</strong> ${new Date(appData.test.testDate).toLocaleDateString()}</p>
				</div>
				
				<div style="margin-bottom: 20px;">
					<h3>Ключевые показатели</h3>
					<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
						<div style="background: #667eea; color: white; padding: 15px; border-radius: 8px; text-align: center;">
							<div style="font-size: 1.6em; font-weight: bold;">${avgScore.toFixed(1)}</div>
							<div>Средний балл</div>
						</div>
						<div style="background: #764ba2; color: white; padding: 15px; border-radius: 8px; text-align: center;">
							<div style="font-size: 1.6em; font-weight: bold;">${successRate.toFixed(1)}%</div>
							<div>Успеваемость</div>
						</div>
					</div>
				</div>
				
				<div style="margin-bottom: 20px;">
					<h3>Распределение оценок</h3>
					<div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px;">
						<div style="background: #f8f9fa; padding: 10px; border-radius: 6px; text-align: center; border-left: 4px solid #27ae60;">
							<div style="font-size: 1.4em; font-weight: bold;">${gradeCounts[5]}</div>
							<div>Оценка 5</div>
						</div>
						<div style="background: #f8f9fa; padding: 10px; border-radius: 6px; text-align: center; border-left: 4px solid #3498db;">
							<div style="font-size: 1.4em; font-weight: bold;">${gradeCounts[4]}</div>
							<div>Оценка 4</div>
						</div>
						<div style="background: #f8f9fa; padding: 10px; border-radius: 6px; text-align: center; border-left: 4px solid #f39c12;">
							<div style="font-size: 1.4em; font-weight: bold;">${gradeCounts[3]}</div>
							<div>Оценка 3</div>
						</div>
						<div style="background: #f8f9fa; padding: 10px; border-radius: 6px; text-align: center; border-left: 4px solid #e74c3c;">
							<div style="font-size: 1.4em; font-weight: bold;">${gradeCounts[2]}</div>
							<div>Оценка 2</div>
						</div>
					</div>
				</div>
				
				<div style="margin-bottom: 20px;">
					<h3>Ключевые выводы</h3>
					<div style="background: #e8f4fc; padding: 15px; border-radius: 6px; border-left: 4px solid #3498db;">
						${generateKeyConclusionsText()}
					</div>
				</div>
				
				<div style="text-align: center; color: #7f8c8d; font-size: 10pt; margin-top: 30px;">
					<p>Отчет сгенерирован ${new Date().toLocaleDateString()}</p>
					<p>Система анализа образовательных результатов</p>
				</div>
			`;
		}

		// Альтернативное решение с использованием pdfmake (если jsPDF продолжает работать плохо)
		function exportToPDFWithPDFMake() {
			// Эта функция требует подключения pdfmake
			if (typeof pdfMake === 'undefined') {
				showNotification('Библиотека pdfmake не подключена', 'error');
				return;
			}
			
			try {
				const totalScores = appData.results.map(scores => scores.reduce((sum, score) => sum + score, 0));
				const grades = totalScores.map(score => calculateGrade(score));
				const avgScore = totalScores.reduce((sum, score) => sum + score, 0) / totalScores.length;
				const successRate = (grades.filter(grade => grade >= 3).length / grades.length * 100);
				const qualityRate = (grades.filter(grade => grade >= 4).length / grades.length * 100);
				
				const gradeCounts = {5: 0, 4: 0, 3: 0, 2: 0};
				grades.forEach(grade => gradeCounts[grade]++);
				
				// Анализ заданий для таблицы
				const taskAnalysis = appData.tasks.map((task, index) => {
					const completion = calculateTaskCompletion(index);
					let zone = '';
					if (completion >= 90) zone = 'Отличная';
					else if (completion >= 60) zone = 'Зеленая';
					else if (completion >= 30) zone = 'Желтая';
					else zone = 'Красная';
					
					return [
						(index + 1).toString(),
						task.type,
						`${task.level}. ${complexityLevels[task.level].name}`,
						`${completion.toFixed(1)}%`,
						zone
					];
				});
				
				const documentDefinition = {
					content: [
						{
							text: 'Аналитический отчет по диагностической работе',
							style: 'header'
						},
						{
							text: `${appData.test.subject}, ${appData.test.class}`,
							style: 'subheader'
						},
						{
							text: `Тема: ${appData.test.theme}`,
							style: 'normal'
						},
						{
							text: `Дата: ${new Date(appData.test.testDate).toLocaleDateString()}`,
							style: 'normal'
						},
						{
							text: ' ',
							style: 'spacer'
						},
						{
							text: 'Ключевые показатели:',
							style: 'sectionHeader'
						},
						{
							ul: [
								`Средний балл: ${avgScore.toFixed(1)}`,
								`Успеваемость: ${successRate.toFixed(1)}%`,
								`Качество знаний: ${qualityRate.toFixed(1)}%`,
								`Оценка 5: ${gradeCounts[5]} учащихся`,
								`Оценка 4: ${gradeCounts[4]} учащихся`, 
								`Оценка 3: ${gradeCounts[3]} учащихся`,
								`Оценка 2: ${gradeCounts[2]} учащихся`
							],
							style: 'list'
						},
						{
							text: ' ',
							style: 'spacer'
						},
						{
							text: 'Анализ выполнения заданий:',
							style: 'sectionHeader'
						},
						{
							table: {
								headerRows: 1,
								widths: [15, '*', 40, 40, 40],
								body: [
									[
										{text: '№', style: 'tableHeader'},
										{text: 'Тип задания', style: 'tableHeader'},
										{text: 'Уровень', style: 'tableHeader'},
										{text: 'Выполнение', style: 'tableHeader'},
										{text: 'Зона', style: 'tableHeader'}
									],
									...taskAnalysis
								]
							}
						},
						{
							text: ' ',
							style: 'spacer'
						},
						{
							text: 'Ключевые выводы и рекомендации:',
							style: 'sectionHeader'
						},
						{
							text: generateKeyConclusionsText(),
							style: 'conclusions'
						},
						{
							text: ' ',
							style: 'spacer'
						},
						{
							text: 'Рекомендации:',
							style: 'sectionHeader'
						},
						{
							ul: [
								'Провести работу над ошибками в течение недели',
								'Организовать дополнительные консультации для отстающих учащихся',
								'Разработать индивидуальные задания по проблемным темам',
								'Проинформировать родителей о результатах работы',
								'Провести повторный контроль через 2 недели'
							],
							style: 'list'
						}
					],
					styles: {
						header: {
							fontSize: 18,
							bold: true,
							alignment: 'center',
							margin: [0, 0, 0, 10]
						},
						subheader: {
							fontSize: 14,
							bold: true,
							alignment: 'center',
							margin: [0, 0, 0, 10]
						},
						sectionHeader: {
							fontSize: 12,
							bold: true,
							margin: [0, 10, 0, 5]
						},
						normal: {
							fontSize: 10,
							margin: [0, 2, 0, 2]
						},
						list: {
							fontSize: 10,
							margin: [0, 5, 0, 5]
						},
						conclusions: {
							fontSize: 10,
							margin: [0, 5, 0, 5],
							lineHeight: 1.3
						},
						tableHeader: {
							bold: true,
							fontSize: 8,
							fillColor: '#34495e',
							color: 'white'
						},
						spacer: {
							margin: [0, 10, 0, 0]
						}
					},
					defaultStyle: {
						font: 'Helvetica'
					}
				};
				
				pdfMake.createPdf(documentDefinition).download(`отчет_${appData.test.subject}_${new Date().toLocaleDateString()}.pdf`);
				showNotification('PDF файл успешно экспортирован', 'success');
				
			} catch (error) {
				console.error('Ошибка при экспорте в PDF:', error);
				showNotification('Ошибка при экспорте в PDF: ' + error.message, 'error');
			}
		}


        function exportToPDF() {
			try {
				// Проверяем, что jsPDF загружен
				if (typeof jspdf === 'undefined') {
					showNotification('Библиотека jsPDF не загружена', 'error');
					return;
				}

				const { jsPDF } = window.jspdf;
				const doc = new jsPDF();
				
				// Добавляем поддержку кириллицы
				doc.setFont('helvetica');
				
				// Заголовок
				doc.setFontSize(16);
				doc.text(`Аналитический отчет: ${appData.test.subject}, ${appData.test.class}`, 20, 20);
				doc.setFontSize(12);
				doc.text(`Тема: ${appData.test.theme}`, 20, 30);
				doc.text(`Дата: ${new Date(appData.test.testDate).toLocaleDateString()}`, 20, 37);
				
				// Статистика
				let y = 50;
				doc.setFontSize(14);
				doc.text('Ключевые показатели:', 20, y);
				y += 10;
				
				doc.setFontSize(10);
				
				// Рассчитываем показатели
				const totalScores = appData.results.map(scores => scores.reduce((sum, score) => sum + score, 0));
				const grades = totalScores.map(score => calculateGrade(score));
				const avgScore = totalScores.reduce((sum, score) => sum + score, 0) / totalScores.length;
				const successRate = (grades.filter(grade => grade >= 3).length / grades.length * 100);
				const qualityRate = (grades.filter(grade => grade >= 4).length / grades.length * 100);
				
				doc.text(`• Средний балл: ${avgScore.toFixed(1)}`, 25, y); y += 7;
				doc.text(`• Успеваемость: ${successRate.toFixed(1)}%`, 25, y); y += 7;
				doc.text(`• Качество знаний: ${qualityRate.toFixed(1)}%`, 25, y); y += 7;
				
				// Распределение оценок
				const gradeCounts = {5: 0, 4: 0, 3: 0, 2: 0};
				grades.forEach(grade => gradeCounts[grade]++);
				
				doc.text(`• Оценка 5: ${gradeCounts[5]} учащихся`, 25, y); y += 7;
				doc.text(`• Оценка 4: ${gradeCounts[4]} учащихся`, 25, y); y += 7;
				doc.text(`• Оценка 3: ${gradeCounts[3]} учащихся`, 25, y); y += 7;
				doc.text(`• Оценка 2: ${gradeCounts[2]} учащихся`, 25, y); y += 7;
				
				// Добавляем новую страницу для детальной информации
				if (y > 250) {
					doc.addPage();
					y = 20;
				}
				
				// Анализ заданий
				doc.setFontSize(14);
				doc.text('Анализ выполнения заданий:', 20, y);
				y += 10;
				
				doc.setFontSize(8); // Уменьшаем шрифт для таблицы
				
				// Заголовок таблицы
				doc.text('№', 25, y);
				doc.text('Тип задания', 35, y);
				doc.text('Уровень', 100, y);
				doc.text('Выполнение', 140, y);
				doc.text('Зона', 180, y);
				
				y += 5;
				doc.line(20, y, 190, y);
				y += 5;
				
				// Данные заданий
				appData.tasks.forEach((task, index) => {
					if (y > 270) {
						doc.addPage();
						y = 20;
						// Повторяем заголовок на новой странице
						doc.setFontSize(8);
						doc.text('№', 25, y);
						doc.text('Тип задания', 35, y);
						doc.text('Уровень', 100, y);
						doc.text('Выполнение', 140, y);
						doc.text('Зона', 180, y);
						y += 5;
						doc.line(20, y, 190, y);
						y += 5;
					}
					
					const completion = calculateTaskCompletion(index);
					let zone = '';
					if (completion >= 90) zone = 'Отличная';
					else if (completion >= 60) zone = 'Зеленая';
					else if (completion >= 30) zone = 'Желтая';
					else zone = 'Красная';
					
					doc.text(`${index + 1}`, 25, y);
					
					// Обрезаем длинные названия заданий
					let taskType = task.type;
					if (taskType.length > 25) {
						taskType = taskType.substring(0, 22) + '...';
					}
					doc.text(taskType, 35, y);
					
					doc.text(`${task.level}. ${complexityLevels[task.level].name}`, 100, y);
					doc.text(`${completion.toFixed(1)}%`, 140, y);
					doc.text(zone, 180, y);
					
					y += 6;
				});
				
				// Добавляем страницу с рекомендациями
				doc.addPage();
				y = 20;
				
				doc.setFontSize(14);
				doc.text('Ключевые выводы и рекомендации:', 20, y);
				y += 15;
				
				doc.setFontSize(10);
				
				// Генерируем выводы
				const conclusions = generateKeyConclusionsText();
				const conclusionLines = doc.splitTextToSize(conclusions, 170);
				conclusionLines.forEach(line => {
					if (y > 270) {
						doc.addPage();
						y = 20;
					}
					doc.text(line, 20, y);
					y += 7;
				});
				
				y += 10;
				
				// Рекомендации
				doc.setFontSize(12);
				doc.text('Рекомендации:', 20, y);
				y += 10;
				
				doc.setFontSize(10);
				const recommendations = [
					'• Провести работу над ошибками в течение недели',
					'• Организовать дополнительные консультации',
					'• Разработать индивидуальные задания',
					'• Проинформировать родителей о результатах',
					'• Провести повторный контроль через 2 недели'
				];
				
				recommendations.forEach(rec => {
					if (y > 270) {
						doc.addPage();
						y = 20;
					}
					doc.text(rec, 25, y);
					y += 7;
				});
				
				// Футер
				doc.setFontSize(8);
				doc.text(`Отчет сгенерирован ${new Date().toLocaleDateString()}`, 20, 280);
				doc.text('Система анализа образовательных результатов', 120, 280);
				
				// Сохраняем PDF
				doc.save(`отчет_${appData.test.subject}_${new Date().toLocaleDateString()}.pdf`);
				showNotification('PDF файл успешно экспортирован', 'success');
			} catch (error) {
				console.error('Ошибка при экспорте в PDF:', error);
				showNotification('Ошибка при экспорте в PDF: ' + error.message, 'error');
			}
		}

        // 2. ИСПРАВЛЕННАЯ ФУНКЦИЯ showSmartRecommendations
		function showSmartRecommendations() {
			const recommendations = generateSmartRecommendations();
			
			let html = '<h3>?? Умные рекомендации</h3>';
			
			if (recommendations.length === 0) {
				html += '<div class="recommendation-card"><p>? Все показатели в норме. Продолжайте в том же духе!</p></div>';
			} else {
				recommendations.forEach(rec => {
					html += `
						<div class="smart-recommendation recommendation-${rec.type}">
							<strong>${rec.title}</strong>
							<p>${rec.message}</p>
							<small>Рекомендуемое действие: ${getActionDescription(rec.action)}</small>
						</div>
					`;
				});
			}
			
			document.getElementById('smartRecommendationsContainer').innerHTML = html;
		}

        // ИСПРАВЛЕННАЯ ФУНКЦИЯ generateSmartRecommendations
		function generateSmartRecommendations() {
			const analysis = analyzePerformancePatterns();
			const totalErrors = appData.errors.length;
			
			// ПРОВЕРЯЕМ, ЕСТЬ ЛИ ОШИБКИ
			let recommendations = [];
			
			// Анализ проблемных зон
			if (analysis.lowCompletionTasks && analysis.lowCompletionTasks.length > 0) {
				recommendations.push({
					type: 'critical',
					title: 'Проблемные задания',
					message: `Задания ${analysis.lowCompletionTasks.map(t => t.index + 1).join(', ')} требуют повторного объяснения (выполнение < 50%)`,
					action: 'review_content'
				});
			}
			
			// Анализ группы риска
			if (analysis.atRiskStudents && analysis.atRiskStudents.length > 0) {
				recommendations.push({
					type: 'warning',
					title: 'Группа риска',
					message: `${analysis.atRiskStudents.length} учащихся требуют индивидуального подхода`,
					action: 'individual_work'
				});
			}
			
			// Анализ ошибок (ТЕПЕРЬ С ПРОВЕРКОЙ)
			if (analysis.commonErrors && analysis.commonErrors.length > 0 && totalErrors > 0) {
				const topError = analysis.commonErrors[0];
				const percentage = Math.round((topError.count / totalErrors) * 100);
				
				recommendations.push({
					type: 'info',
					title: 'Типичные ошибки',
					message: `Преобладают ${errorTypes[topError.type]?.name?.toLowerCase() || topError.type} (${topError.count} случаев, ${percentage}% всех ошибок)`,
					action: 'error_analysis'
				});
			}
			
			return recommendations;
		}

        // 3. ИСПРАВЛЕННАЯ ФУНКЦИЯ analyzePerformancePatterns
		function analyzePerformancePatterns() {
			const result = {
				lowCompletionTasks: [],
				atRiskStudents: [],
				commonErrors: []
			};
			
			// Анализ заданий с низкой решаемостью
			if (appData.tasks && appData.tasks.length > 0) {
				result.lowCompletionTasks = appData.tasks
					.map((task, index) => ({ 
						task, 
						index, 
						completion: calculateTaskCompletion(index) 
					}))
					.filter(t => t.completion < 50)
					.slice(0, 3);
			}
			
			// Анализ учащихся группы риска
			if (appData.results && appData.results.length > 0) {
				const totalScores = appData.results.map(scores => 
					scores.reduce((sum, score) => sum + score, 0)
				);
				
				result.atRiskStudents = appData.students
					.map((student, index) => ({ 
						student, 
						index, 
						score: totalScores[index] 
					}))
					.filter(s => s.score < appData.test.criteria[3].min)
					.slice(0, 5);
			}
			
			// Анализ ошибок (С ЗАЩИТОЙ ОТ ПУСТОГО МАССИВА)
			if (appData.errors && appData.errors.length > 0) {
				const errorStats = {};
				
				appData.errors.forEach(error => {
					if (error && error.type) {
						errorStats[error.type] = (errorStats[error.type] || 0) + 1;
					}
				});
				
				result.commonErrors = Object.entries(errorStats)
					.sort(([,a], [,b]) => b - a)
					.slice(0, 2)
					.map(([type, count]) => ({ type, count }));
			}
			
			return result;
		}


		// ДОБАВЬТЕ ЭТУ ФУНКЦИЮ ДЛЯ БЕЗОПАСНОГО ДОСТУПА К ДАННЫМ
		function safeGet(object, path, defaultValue = null) {
			try {
				const value = path.split('.').reduce((obj, key) => 
					obj && obj[key] !== undefined ? obj[key] : undefined, 
					object
				);
				return value !== undefined ? value : defaultValue;
			} catch (error) {
				console.warn('Ошибка безопасного доступа:', error);
				return defaultValue;
			}
		}

		// ПЕРЕПИШЕМ НЕКОТОРЫЕ КРИТИЧЕСКИЕ ФУНКЦИИ С ЗАЩИТОЙ:
        function getActionDescription(action) {
            const actions = {
                'review_content': 'Повторное объяснение материала',
                'individual_work': 'Индивидуальная работа с учащимися',
                'error_analysis': 'Анализ и разбор типичных ошибок'
            };
            return actions[action] || action;
        }

        // 7. ПОИСК И ФИЛЬТРАЦИЯ
        function initAdvancedSearch() {
            const html = `
                <div class="search-filters">
                    <div class="form-group">
                        <label>Поиск по учащимся:</label>
                        <input type="text" id="studentSearch" placeholder="Фамилия или имя..." onkeyup="filterStudents()">
                    </div>
                    
                    <div class="form-group">
                        <label>Оценка:</label>
                        <select id="gradeFilter" onchange="filterStudents()">
                            <option value="">Все оценки</option>
                            <option value="5">5</option>
                            <option value="4">4</option>
                            <option value="3">3</option>
                            <option value="2">2</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label>Уровень выполнения:</label>
                        <select id="performanceFilter" onchange="filterStudents()">
                            <option value="">Все</option>
                            <option value="high">Высокий (&gt;80%)</option>
                            <option value="medium">Средний (50-80%)</option>
                            <option value="low">Низкий (&lt;50%)</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label>Типы ошибок:</label>
                        <select id="errorFilter" onchange="filterStudents()">
                            <option value="">Все</option>
                            ${Object.entries(errorTypes).map(([key, data]) => 
                                `<option value="${key}">${data.name}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
                
                <div id="filteredResults" style="max-height: 400px; overflow-y: auto;"></div>
            `;
            
            showModal('Расширенный поиск', html);
            filterStudents();
        }

        function filterStudents() {
            const searchText = document.getElementById('studentSearch').value.toLowerCase();
            const gradeFilter = document.getElementById('gradeFilter').value;
            const performanceFilter = document.getElementById('performanceFilter').value;
            const errorFilter = document.getElementById('errorFilter').value;
            
            const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0);
            
            const filtered = appData.students
                .map((student, index) => {
                    const totalScore = appData.results[index].reduce((sum, score) => sum + score, 0);
                    const grade = calculateGrade(totalScore);
                    const percentage = (totalScore / maxPossible) * 100;
                    const studentErrors = appData.errors.filter(e => e.studentIndex === index);
                    
                    return { student, index, totalScore, grade, percentage, studentErrors };
                })
                .filter(data => {
                    // Фильтр по тексту
                    if (searchText && !data.student.toLowerCase().includes(searchText)) return false;
                    
                    // Фильтр по оценке
                    if (gradeFilter && data.grade != gradeFilter) return false;
                    
                    // Фильтр по уровню выполнения
                    if (performanceFilter === 'high' && data.percentage < 80) return false;
                    if (performanceFilter === 'medium' && (data.percentage < 50 || data.percentage >= 80)) return false;
                    if (performanceFilter === 'low' && data.percentage >= 50) return false;
                    
                    // Фильтр по ошибкам
                    if (errorFilter && !data.studentErrors.some(e => e.type === errorFilter)) return false;
                    
                    return true;
                });
            
            displayFilteredResults(filtered);
        }

        function displayFilteredResults(filtered) {
            const container = document.getElementById('filteredResults');
            
            if (filtered.length === 0) {
                container.innerHTML = '<p>Учащиеся не найдены</p>';
                return;
            }
            
            let html = '<table style="width: 100%;"><thead><tr><th>Учащийся</th><th>Баллы</th><th>Оценка</th><th>% выполнения</th><th>Ошибки</th></tr></thead><tbody>';
            
            filtered.forEach(data => {
                html += `
                    <tr>
                        <td><strong>${data.student}</strong></td>
                        <td>${data.totalScore}</td>
                        <td class="grade-${data.grade}">${data.grade}</td>
                        <td>${data.percentage.toFixed(1)}%</td>
                        <td>${data.studentErrors.length > 0 ? 
                            data.studentErrors.map(e => `<span class="error-type error-${e.type}">${errorTypes[e.type].name}</span>`).join(' ') : 
                            '—'}</td>
                    </tr>
                `;
            });
            
            html += '</tbody></table>';
            container.innerHTML = html;
        }

        // 8. ИНТЕГРАЦИЯ С ВНЕШНИМИ СИСТЕМАМИ
        function exportForEJournal() {
            const data = {
                subject: appData.test.subject,
                class: appData.test.class,
                workTheme: appData.test.theme,
                workDate: appData.test.testDate,
                results: appData.students.map((student, index) => ({
                    student: student,
                    score: appData.results[index].reduce((sum, score) => sum + score, 0),
                    grade: calculateGrade(appData.results[index].reduce((sum, score) => sum + score, 0)),
                    comment: generateStudentComment(index)
                }))
            };
            
            const dataStr = JSON.stringify(data, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `электронный_дневник_${appData.test.subject}_${new Date().toLocaleDateString()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            showNotification('Данные для электронного дневника экспортированы', 'success');
        }

        function generateStudentComment(studentIndex) {
            const totalScore = appData.results[studentIndex].reduce((sum, score) => sum + score, 0);
            const grade = calculateGrade(totalScore);
            const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0);
            const percentage = (totalScore / maxPossible) * 100;
            
            if (percentage >= 80) return 'Отличный результат';
            if (percentage >= 60) return 'Хороший результат';
            if (percentage >= 40) return 'Удовлетворительный результат';
            return 'Требуется дополнительная работа';
        }

        // ==================== ОСНОВНОЙ ФУНКЦИОНАЛ ====================


        // Навигация по вкладкам
        function showTab(tabName) {
            // Скрываем все вкладки
			document.querySelectorAll('.tab-content').forEach(tab => {
				tab.classList.remove('active');
			});
			
			// Убираем активный класс у всех кнопок
			document.querySelectorAll('.tab-btn').forEach(btn => {
				btn.classList.remove('active');
			});
			
			// Показываем выбранную вкладку
			document.getElementById(tabName).classList.add('active');
			
			// Добавляем активный класс нажатой кнопке
			event.target.classList.add('active');
			
			// Обновляем содержимое вкладок при переключении
			if (tabName === 'analytics') {
				updateAnalytics();
			} else if (tabName === 'visualization') {
				updateVisualization();
			} else if (tabName === 'recommendations') {
				updateRecommendations();
			} else if (tabName === 'export') {
				updateReportPreview();
			}
			
        }
		function useTemplate(encodedData, fileName) {
			try {
				const templateData = JSON.parse(decodeURIComponent(encodedData));
				const keepStudents = document.getElementById('keepStudents')?.checked;
				const keepSettings = document.getElementById('keepSettings')?.checked;
				
				// Сохраняем текущие данные
				const currentStudents = [...appData.students];
				const currentResults = [...appData.results];
				const currentSettings = { 
					class: appData.test.class, 
					testDate: appData.test.testDate 
				};
				
				// Заменяем основные данные
				appData.test = { ...templateData.test };
				appData.tasks = [...templateData.tasks];
				
				// Восстанавливаем настройки если нужно
				if (keepSettings) {
					appData.test.class = currentSettings.class;
					appData.test.testDate = currentSettings.testDate;
				}
				
				// Восстанавливаем учащихся если нужно
				if (keepStudents && currentStudents.length > 0) {
					appData.students = currentStudents;
					appData.results = currentResults.map(studentResults => 
						new Array(appData.tasks.length).fill(0)
					);
				} else {
					appData.students = templateData.students || [];
					appData.results = templateData.results || [];
				}
				
				// Синхронизируем массивы
				robustSyncData();
				
				// Гарантируем, что templates существует
				if (!appData.templates) {
					appData.templates = {
						loadedTemplates: [],
						lastTemplatePath: "",
						lastTemplateName: "",
						availableSubjects: []
					};
				}
				
				// Сохраняем информацию о шаблоне
				appData.templates.lastTemplatePath = fileName;
				appData.templates.lastTemplateName = templateData.test.theme || "Шаблон без названия";
				
				// Сохраняем и обновляем
				saveData();
				renderAll();
				hideModal();
				
				showNotification(`? Шаблон "${templateData.test.theme || 'Без названия'}" успешно импортирован!`, 'success');
				
			} catch (error) {
				console.error('Ошибка импорта шаблона:', error);
				showNotification('? Ошибка импорта шаблона: ' + error.message, 'error');
			}
		}
		
		// Безопасная проверка наличия последнего шаблона
		function hasLastTemplate() {
			return appData.templates && 
				   appData.templates.lastTemplatePath && 
				   appData.templates.lastTemplatePath.trim() !== "";
		}

		// Получить имя последнего шаблона безопасно
		function getLastTemplateName() {
			if (appData.templates && appData.templates.lastTemplateName) {
				return appData.templates.lastTemplateName;
			}
			return "";
		}
		
        // Сохранение данных
		function saveData() {
			// Гарантируем, что templates существует перед сохранением
			if (!appData.templates) {
				appData.templates = {
					loadedTemplates: [],
					lastTemplatePath: "",
					lastTemplateName: "",
					availableSubjects: []
				};
			}
			localStorage.setItem('testAnalyticsData', JSON.stringify(appData));
		}

        // Загрузка данных
        function loadData() {
			try {
				const saved = localStorage.getItem('testAnalyticsData');
				if (saved) {
					const parsed = JSON.parse(saved);
					
					// Объединяем сохраненные данные с дефолтными, чтобы новые поля не потерялись
					appData = {
						...appData, // дефолтные значения
						...parsed,  // сохраненные значения
						test: {
							...appData.test, // дефолтные значения теста
							...parsed.test   // сохраненные значения теста
						}
					};
					
					// Убедимся, что все необходимые поля существуют
					if (!appData.test.criteriaType) appData.test.criteriaType = 'points';
					if (!appData.test.criteriaSystem) appData.test.criteriaSystem = 'standard';
					if (!appData.test.customCriteria) appData.test.customCriteria = [];
					if (!appData.test.criteriaCount) appData.test.criteriaCount = 4;
					if (!appData.test.criteriaScale) appData.test.criteriaScale = '2-5';
					if (!appData.psychologyFeatures) appData.psychologyFeatures = [];
					
					console.log('Данные успешно загружены из localStorage');
				}
			} catch (error) {
				console.error('Ошибка при загрузке данных:', error);
			}
		}

        // Обновление интерфейса при смене типа работы
        function updateWorkType() {
            appData.test.workType = document.getElementById('workType').value;
            updateCriteriaForWorkType();
            appData.tasks = [];
            saveData();
            renderAll();
        }

        // Обновление критериев оценивания для разных типов работ
        function updateCriteriaForWorkType() {
            const criteria = appData.test.criteria;
			const workType = appData.test.workType;
            
            switch(appData.test.workType) {
                case 'oge':
                    criteria[5] = { min: 22, max: 32 };
                    criteria[4] = { min: 15, max: 21 };
                    criteria[3] = { min: 8, max: 14 };
                    criteria[2] = { min: 0, max: 7 };
                    break;
                case 'ege':
                    criteria[5] = { min: 27, max: 31 };
                    criteria[4] = { min: 20, max: 26 };
                    criteria[3] = { min: 12, max: 19 };
                    criteria[2] = { min: 0, max: 11 };
                    break;
                case 'vpr':
                    criteria[5] = { min: 18, max: 20 };
                    criteria[4] = { min: 15, max: 17 };
                    criteria[3] = { min: 10, max: 14 };
                    criteria[2] = { min: 0, max: 9 };
                    break;
                case 'func_literacy':
                    criteria[5] = { min: 90, max: 100 };
                    criteria[4] = { min: 75, max: 89 };
                    criteria[3] = { min: 50, max: 74 };
                    criteria[2] = { min: 0, max: 49 };
                    break;
				case 'psychology':
					// Психология может использовать разные шкалы
					appData.test.criteriaScale = 'points'; // или 'percentage', 'levels'
					appData.test.criteriaSystem = 'custom'; // или 'standard'
					
					// Гибкие настройки отображения
					if (!appData.test.psychologySettings) {
						appData.test.psychologySettings = {
							scaleType: '1-5', // '1-5', '1-10', 'percentage', 'levels'
							levels: [
								{ name: "Низкий уровень", min: 0, max: 25, color: "#e74c3c" },
								{ name: "Средний уровень", min: 26, max: 50, color: "#f39c12" },
								{ name: "Выше среднего", min: 51, max: 75, color: "#3498db" },
								{ name: "Высокий уровень", min: 76, max: 100, color: "#27ae60" }
							],
							usePercentages: true,
							customLabels: {
								2: "Низкий",
								3: "Средний", 
								4: "Выше среднего",
								5: "Высокий"
							}
						};
					}
					break;
                default:
                    break;
            }
            
            renderTestSettings();
        }

		function renderPsychologyCriteria() {
			return `
				<h3 class="section-title">?? Шкала оценивания (психология)</h3>
				
				<div class="form-group">
					<label>Тип шкалы:</label>
					<select id="psychologyScaleType" onchange="updatePsychologyScale()">
						<option value="1-5">Баллы 1-5</option>
						<option value="1-10">Баллы 1-10</option>
						<option value="percentage">Проценты (%)</option>
						<option value="levels">Уровни (низкий/средний/высокий)</option>
						<option value="stens">Стены (стандартные 10)</option>
						<option value="t-scores">Т-баллы</option>
						<option value="custom">Произвольная шкала</option>
					</select>
				</div>
				
				<div id="psychologyCriteriaContainer">
					<!-- Динамически меняется в зависимости от выбора -->
				</div>
				
				<div class="form-group">
					<label>Метод интерпретации:</label>
					<select id="interpretationMethod">
						<option value="normative">Нормативный (сравнение с нормой)</option>
						<option value="ipsative">Ипсативный (сравнение с самим собой)</option>
						<option value="criterion">Критериальный (достижение цели)</option>
					</select>
				</div>
				
				<div class="form-group">
					<label>Нормативная выборка (если есть):</label>
					<input type="text" id="normGroup" placeholder="Например: подростки 14-16 лет, n=150">
				</div>
			`;
		}

		function updatePsychologyScale() {
			const scaleType = document.getElementById('psychologyScaleType').value;
			let html = '';
			
			switch(scaleType) {
				case '1-5':
					html = `
						<div class="criteria-grid">
							${[1,2,3,4,5].map(level => `
								<div class="criteria-item">
									<label>Уровень ${level}:</label>
									<input type="number" id="psychologyMin${level}" placeholder="Мин" value="${(level-1)*20}">
									<input type="number" id="psychologyMax${level}" placeholder="Макс" value="${level*20}">
									<input type="text" id="psychologyLabel${level}" placeholder="Интерпретация" 
										   value="${['Очень низкий', 'Низкий', 'Средний', 'Высокий', 'Очень высокий'][level-1]}">
								</div>
							`).join('')}
						</div>
					`;
					break;
					
				case 'percentage':
					html = `
						<div class="criteria-grid">
							<div class="criteria-item">
								<label>Критически низкий (&lt;10%):</label>
								<input type="number" max="100" value="10" readonly>
							</div>
							<div class="criteria-item">
								<label>Низкий (10-25%):</label>
								<input type="number" max="100" value="10" min="0">
								<input type="number" max="100" value="25" min="0">
							</div>
							<div class="criteria-item">
								<label>Средний (25-75%):</label>
								<input type="number" max="100" value="25" min="0">
								<input type="number" max="100" value="75" min="0">
							</div>
							<div class="criteria-item">
								<label>Высокий (&gt;75%):</label>
								<input type="number" max="100" value="75" readonly>
							</div>
						</div>
					`;
					break;
					
				case 'levels':
					html = `
						<div class="criteria-grid">
							<div class="criteria-item">
								<label>?? Низкий уровень:</label>
								<input type="number" placeholder="Мин %" value="0">
								<input type="number" placeholder="Макс %" value="30">
							</div>
							<div class="criteria-item">
								<label>?? Средний уровень:</label>
								<input type="number" placeholder="Мин %" value="31">
								<input type="number" placeholder="Макс %" value="70">
							</div>
							<div class="criteria-item">
								<label>?? Высокий уровень:</label>
								<input type="number" placeholder="Мин %" value="71">
								<input type="number" placeholder="Макс %" value="100">
							</div>
						</div>
					`;
					break;
					
				case 'stens':
					html = `
						<p><strong>Стандартная шкала стенов (1-10):</strong></p>
						<div class="criteria-grid">
							${[1,2,3,4,5,6,7,8,9,10].map(sten => `
								<div class="criteria-item">
									<label>Стен ${sten}:</label>
									<input type="number" value="${(sten-1)*10}" readonly>
									<input type="number" value="${sten*10}" readonly>
									<small>${getStenInterpretation(sten)}</small>
								</div>
							`).join('')}
						</div>
					`;
					break;
			}
			
			document.getElementById('psychologyCriteriaContainer').innerHTML = html;
		}

		function updatePsychologyAnalysis() {
			let html = '<h3 class="section-title">?? Психологический анализ результатов</h3>';
			
			// Статистика по психологическим показателям
			html += `
				<div class="stats-grid">
					<div class="stat-card">
						<div class="stat-value">${calculatePsychologyAverage()}</div>
						<div class="stat-label">Средний показатель</div>
					</div>
					<div class="stat-card">
						<div class="stat-value">${calculateStandardDeviation()}?</div>
						<div class="stat-label">Станд. отклонение</div>
					</div>
					<div class="stat-card">
						<div class="stat-value">${calculatePsychologyReliability()}</div>
						<div class="stat-label">Надежность теста</div>
					</div>
					<div class="stat-card">
						<div class="stat-value">${identifyExtremeScores().length}</div>
						<div class="stat-label">Экстремальные значения</div>
					</div>
				</div>
			`;
			
			// Распределение по уровням
			html += generatePsychologyLevelsDistribution();
			
			// Профиль группы
			html += generateGroupProfile();
			
			// Индивидуальные профили
			html += generateIndividualProfiles();
			
			// Рекомендации
			html += generatePsychologyRecommendations();
			
			document.getElementById('specializedAnalysis').innerHTML = html;
		}

		function generatePsychologyLevelsDistribution() {
			const levels = appData.test.psychologySettings?.levels || [
				{ name: "Низкий", min: 0, max: 40, color: "#e74c3c" },
				{ name: "Средний", min: 41, max: 70, color: "#f39c12" },
				{ name: "Высокий", min: 71, max: 100, color: "#27ae60" }
			];
			
			const totalScores = appData.results.map(scores => {
				const total = scores.reduce((sum, score) => sum + score, 0);
				const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0);
				return (total / maxPossible) * 100;
			});
			
			const levelCounts = {};
			levels.forEach(level => {
				levelCounts[level.name] = totalScores.filter(score => 
					score >= level.min && score <= level.max
				).length;
			});
			
			let html = '<h4>?? Распределение по уровням</h4>';
			html += '<div class="kpi-grid">';
			
			Object.entries(levelCounts).forEach(([name, count]) => {
				const level = levels.find(l => l.name === name);
				const percentage = (count / totalScores.length) * 100;
				
				html += `
					<div class="kpi-card" style="border-left-color: ${level.color}">
						<div class="kpi-value">${count}</div>
						<div class="kpi-label">${name}</div>
						<small>${percentage.toFixed(1)}% группы</small>
					</div>
				`;
			});
			
			html += '</div>';
			
			return html;
		}

		function updatePsychologyVisualization() {
			let html = `
				<div class="chart-row">
					<div class="chart-container" style="height: 400px;">
						<h3>?? Профиль психологических показателей группы</h3>
						<canvas id="psychologyProfileChart"></canvas>
						<div class="chart-legend">
							<div class="legend-item">
								<div class="legend-color" style="background-color: #c0392b"></div>
								<span>Очень низкий (&lt;30%)</span>
							</div>
							<div class="legend-item">
								<div class="legend-color" style="background-color: #f39c12"></div>
								<span>Средний (50-70%)</span>
							</div>
							<div class="legend-item">
								<div class="legend-color" style="background-color: #27ae60"></div>
								<span>Очень высокий (&gt;85%)</span>
							</div>
						</div>
					</div>
					
					<div class="chart-container" style="height: 400px;">
						<h3>?? Распределение результатов группы</h3>
						<canvas id="normDistributionChart"></canvas>
						<div class="chart-legend">
							<div class="legend-item">
								<div class="legend-color" style="background-color: rgba(52, 152, 219, 0.7)"></div>
								<span>Фактическое распределение</span>
							</div>
							<div class="legend-item">
								<div class="legend-color" style="background-color: rgba(231, 76, 60, 0.8)"></div>
								<span>Нормальное распределение</span>
							</div>
						</div>
					</div>
				</div>
				
				<div class="chart-container" style="height: 500px;">
					<h3>?? Сравнение профилей (топ-3 и низкие результаты)</h3>
					<canvas id="psychologyRadarChart"></canvas>
					<small>Сплошные линии - лучшие результаты, пунктирные - низкие результаты</small>
				</div>
				
				<div class="chart-container">
					<h3>?? Индивидуальные профили развития</h3>
					<div id="individualProfiles" style="max-height: 400px; overflow-y: auto; padding: 10px; background: #f8f9fa; border-radius: 8px;">
						<!-- Индивидуальные профили будут сгенерированы динамически -->
					</div>
				</div>
			`;
			
			document.getElementById('specializedCharts').innerHTML = html;
			
			// Инициализируем графики после рендеринга HTML
			setTimeout(() => {
				initPsychologyCharts();
				updateIndividualProfiles();
			}, 100);
		}

		function updateIndividualProfiles() {
			const container = document.getElementById('individualProfiles');
			if (!container) return;
			
			// Рассчитываем общие баллы
			const totalScores = appData.results.map((scores, index) => {
				const total = scores.reduce((sum, score) => sum + score, 0);
				const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0);
				const percentage = (total / maxPossible) * 100;
				
				// Определяем уровень
				const levels = appData.test.psychologySettings?.levels || [];
				let levelName = 'Не определен';
				let levelColor = '#7f8c8d';
				
				for (let level of levels) {
					if (percentage >= level.min && percentage <= level.max) {
						levelName = level.name;
						levelColor = level.color;
						break;
					}
				}
				
				// Находим особенности
				const features = (appData.psychologyFeatures || []).filter(f => f.studentIndex === index);
				
				return {
					name: appData.students[index],
					percentage: percentage,
					levelName: levelName,
					levelColor: levelColor,
					features: features
				};
			});
			
			// Сортируем по убыванию
			totalScores.sort((a, b) => b.percentage - a.percentage);
			
			let html = '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 15px;">';
			
			totalScores.forEach(student => {
				html += `
					<div style="background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); border-left: 4px solid ${student.levelColor};">
						<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
							<strong>${student.name}</strong>
							<span style="background: ${student.levelColor}; color: white; padding: 3px 8px; border-radius: 12px; font-size: 12px;">
								${student.levelName}
							</span>
						</div>
						
						<div style="margin: 10px 0;">
							<div style="display: flex; justify-content: space-between; font-size: 12px; color: #666;">
								<span>Общий показатель:</span>
								<strong>${student.percentage.toFixed(1)}%</strong>
							</div>
							<div style="height: 8px; background: #ecf0f1; border-radius: 4px; margin-top: 5px; overflow: hidden;">
								<div style="height: 100%; width: ${student.percentage}%; background: ${student.levelColor}; border-radius: 4px;"></div>
							</div>
						</div>
						
						${student.features.length > 0 ? `
							<div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #eee;">
								<small style="color: #666; display: block; margin-bottom: 5px;">Особенности:</small>
								${student.features.map(feature => `
									<span style="display: inline-block; background: #e8f4fc; color: #3498db; font-size: 11px; padding: 2px 6px; border-radius: 10px; margin: 2px;">
										${feature.name}
									</span>
								`).join('')}
							</div>
						` : ''}
					</div>
				`;
			});
			
			html += '</div>';
			container.innerHTML = html;
		}

		function initPsychologyCharts() {
			// Уничтожаем старые графики, если есть
			if (window.psychologyProfileChartInstance) {
				window.psychologyProfileChartInstance.destroy();
			}
			if (window.normDistributionChartInstance) {
				window.normDistributionChartInstance.destroy();
			}
			if (window.radarChartInstance) {
				window.radarChartInstance.destroy();
			}
			
			// 1. График профиля психологических показателей
			const profileCtx = document.getElementById('psychologyProfileChart').getContext('2d');
			
			// Рассчитываем средние значения по измерениям
			const dimensions = appData.test.psychologySettings?.dimensions || [
				{ id: 'dim1', name: 'Измерение 1' },
				{ id: 'dim2', name: 'Измерение 2' },
				{ id: 'dim3', name: 'Измерение 3' },
				{ id: 'dim4', name: 'Измерение 4' }
			];
			
			const dimensionAverages = dimensions.map(dimension => {
				// Находим задания этого измерения
				const dimensionTasks = appData.tasks.filter(task => task.dimension === dimension.id);
				if (dimensionTasks.length === 0) return 0;
				
				let totalScore = 0;
				let totalMax = 0;
				
				dimensionTasks.forEach(task => {
					const taskIndex = appData.tasks.indexOf(task);
					const maxScore = task.maxScore;
					const actualScores = appData.results.map(student => student[taskIndex] || 0);
					const actualTotal = actualScores.reduce((sum, score) => sum + score, 0);
					
					totalScore += actualTotal;
					totalMax += maxScore * appData.results.length;
				});
				
				return totalMax > 0 ? (totalScore / totalMax) * 100 : 0;
			});
			
			// Цвета для измерений
			const dimensionColors = [
				'rgba(255, 99, 132, 0.8)',
				'rgba(54, 162, 235, 0.8)',
				'rgba(255, 206, 86, 0.8)',
				'rgba(75, 192, 192, 0.8)',
				'rgba(153, 102, 255, 0.8)'
			];
			
			window.psychologyProfileChartInstance = new Chart(profileCtx, {
				type: 'bar',
				data: {
					labels: dimensions.map(d => d.name),
					datasets: [{
						label: 'Средний показатель группы (%)',
						data: dimensionAverages,
						backgroundColor: dimensionColors.slice(0, dimensions.length),
						borderColor: dimensionColors.slice(0, dimensions.length).map(color => color.replace('0.8', '1')),
						borderWidth: 2,
						borderRadius: 6,
						barPercentage: 0.6
					}]
				},
				options: {
					responsive: true,
					maintainAspectRatio: true,
					plugins: {
						legend: {
							display: true,
							position: 'top'
						},
						tooltip: {
							callbacks: {
								label: function(context) {
									const dimension = dimensions[context.dataIndex];
									const value = context.raw;
									let interpretation = '';
									
									if (value < 30) interpretation = ' (Очень низкий)';
									else if (value < 50) interpretation = ' (Низкий)';
									else if (value < 70) interpretation = ' (Средний)';
									else if (value < 85) interpretation = ' (Высокий)';
									else interpretation = ' (Очень высокий)';
									
									return `${dimension.name}: ${value.toFixed(1)}%${interpretation}`;
								},
								afterLabel: function(context) {
									const dimension = dimensions[context.dataIndex];
									return dimension.description || '';
								}
							}
						}
					},
					scales: {
						y: {
							beginAtZero: true,
							max: 100,
							title: {
								display: true,
								text: 'Уровень развития (%)',
								font: {
									size: 14,
									weight: 'bold'
								}
							},
							ticks: {
								callback: function(value) {
									return value + '%';
								},
								font: {
									size: 12
								}
							},
							grid: {
								color: function(context) {
									const value = context.tick.value;
									if (value === 30 || value === 50 || value === 70 || value === 85) {
										return 'rgba(0, 0, 0, 0.3)';
									}
									return 'rgba(0, 0, 0, 0.1)';
								},
								lineWidth: function(context) {
									const value = context.tick.value;
									if (value === 30 || value === 50 || value === 70 || value === 85) {
										return 2;
									}
									return 1;
								}
							}
						},
						x: {
							title: {
								display: true,
								text: 'Психологические измерения',
								font: {
									size: 14,
									weight: 'bold'
								}
							},
							ticks: {
								font: {
									size: 12
								}
							}
						}
					},
					animation: {
						duration: 1000,
						easing: 'easeOutQuart'
					}
				}
			});
			
			// 2. График нормального распределения
			const normCtx = document.getElementById('normDistributionChart').getContext('2d');
			
			// Рассчитываем общие баллы всех учащихся в процентах
			const totalScores = appData.results.map(scores => {
				const total = scores.reduce((sum, score) => sum + score, 0);
				const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0);
				return (total / maxPossible) * 100;
			});
			
			// Создаем гистограмму
			const bins = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100];
			const histogramData = new Array(bins.length - 1).fill(0);
			
			totalScores.forEach(score => {
				for (let i = 0; i < bins.length - 1; i++) {
					if (score >= bins[i] && score < bins[i + 1]) {
						histogramData[i]++;
						break;
					}
				}
			});
			
			// Генерация нормального распределения для сравнения
			const mean = totalScores.reduce((a, b) => a + b, 0) / totalScores.length;
			const std = Math.sqrt(totalScores.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / totalScores.length);
			
			const normalDistribution = bins.map(bin => {
				return totalScores.length * 0.1 * (1 / (std * Math.sqrt(2 * Math.PI))) * 
					   Math.exp(-0.5 * Math.pow((bin - mean) / std, 2));
			});
			
			window.normDistributionChartInstance = new Chart(normCtx, {
				type: 'bar',
				data: {
					labels: ['0-10%', '10-20%', '20-30%', '30-40%', '40-50%', '50-60%', '60-70%', '70-80%', '80-90%', '90-100%'],
					datasets: [
						{
							label: 'Распределение группы',
							data: histogramData,
							backgroundColor: 'rgba(52, 152, 219, 0.7)',
							borderColor: 'rgba(52, 152, 219, 1)',
							borderWidth: 1,
							borderRadius: 4
						},
						{
							label: 'Нормальное распределение',
							data: normalDistribution,
							type: 'line',
							fill: false,
							borderColor: 'rgba(231, 76, 60, 0.8)',
							borderWidth: 3,
							pointRadius: 0,
							tension: 0.4
						}
					]
				},
				options: {
					responsive: true,
					maintainAspectRatio: true,
					plugins: {
						legend: {
							display: true,
							position: 'top'
						},
						tooltip: {
							callbacks: {
								title: function(context) {
									return `Диапазон: ${context[0].label}`;
								},
								label: function(context) {
									if (context.datasetIndex === 0) {
										const count = context.raw;
										const percentage = (count / totalScores.length) * 100;
										return `Учащихся: ${count} (${percentage.toFixed(1)}%)`;
									} else {
										return `Теоретическое распределение: ${context.raw.toFixed(2)}`;
									}
								}
							}
						},
						annotation: {
							annotations: {
								meanLine: {
									type: 'line',
									yMin: 0,
									yMax: Math.max(...histogramData) * 1.1,
									xMin: mean / 10,
									xMax: mean / 10,
									borderColor: 'rgba(46, 204, 113, 0.8)',
									borderWidth: 2,
									borderDash: [5, 5],
									label: {
										display: true,
										content: `Среднее: ${mean.toFixed(1)}%`,
										position: 'center',
										backgroundColor: 'rgba(46, 204, 113, 0.8)',
										color: 'white',
										font: {
											size: 12,
											weight: 'bold'
										}
									}
								}
							}
						}
					},
					scales: {
						y: {
							beginAtZero: true,
							title: {
								display: true,
								text: 'Количество учащихся',
								font: {
									size: 14,
									weight: 'bold'
								}
							},
							ticks: {
								font: {
									size: 12
								}
							}
						},
						x: {
							title: {
								display: true,
								text: 'Уровень развития (%)',
								font: {
									size: 14,
									weight: 'bold'
								}
							},
							ticks: {
								font: {
									size: 12
								}
							}
						}
					}
				}
			});
			
			// 3. Радарная диаграмма для топ-3 и низких учащихся (если есть элемент radarChart)
			const radarCanvas = document.getElementById('psychologyRadarChart');
			if (radarCanvas) {
				const radarCtx = radarCanvas.getContext('2d');
				
				// Выбираем 3 лучших и 3 худших учащихся
				const studentScores = totalScores.map((score, index) => ({
					name: appData.students[index],
					score: score,
					index: index
				}));
				
				studentScores.sort((a, b) => b.score - a.score);
				const topStudents = studentScores.slice(0, 3);
				const bottomStudents = studentScores.slice(-3);
				
				// Собираем данные для каждого измерения
				const radarLabels = dimensions.map(d => d.name);
				
				const topStudentData = topStudents.map(student => {
					return dimensions.map(dimension => {
						const dimensionTasks = appData.tasks.filter(task => task.dimension === dimension.id);
						if (dimensionTasks.length === 0) return 0;
						
						let studentScore = 0;
						let maxScore = 0;
						
						dimensionTasks.forEach(task => {
							const taskIndex = appData.tasks.indexOf(task);
							studentScore += appData.results[student.index][taskIndex] || 0;
							maxScore += task.maxScore;
						});
						
						return maxScore > 0 ? (studentScore / maxScore) * 100 : 0;
					});
				});
				
				const bottomStudentData = bottomStudents.map(student => {
					return dimensions.map(dimension => {
						const dimensionTasks = appData.tasks.filter(task => task.dimension === dimension.id);
						if (dimensionTasks.length === 0) return 0;
						
						let studentScore = 0;
						let maxScore = 0;
						
						dimensionTasks.forEach(task => {
							const taskIndex = appData.tasks.indexOf(task);
							studentScore += appData.results[student.index][taskIndex] || 0;
							maxScore += task.maxScore;
						});
						
						return maxScore > 0 ? (studentScore / maxScore) * 100 : 0;
					});
				});
				
				const radarDatasets = [
					...topStudentData.map((data, i) => ({
						label: `Топ ${i+1}: ${topStudents[i].name}`,
						data: data,
						backgroundColor: `rgba(39, 174, 96, ${0.2 + i * 0.1})`,
						borderColor: `rgba(39, 174, 96, ${0.8})`,
						pointBackgroundColor: `rgba(39, 174, 96, 1)`,
						pointBorderColor: '#fff',
						pointHoverRadius: 8,
						borderWidth: 2
					})),
					...bottomStudentData.map((data, i) => ({
						label: `Низкий ${i+1}: ${bottomStudents[i].name}`,
						data: data,
						backgroundColor: `rgba(231, 76, 60, ${0.2 + i * 0.1})`,
						borderColor: `rgba(231, 76, 60, ${0.8})`,
						pointBackgroundColor: `rgba(231, 76, 60, 1)`,
						pointBorderColor: '#fff',
						pointHoverRadius: 8,
						borderWidth: 2,
						borderDash: [5, 5]
					}))
				];
				
				window.radarChartInstance = new Chart(radarCtx, {
					type: 'radar',
					data: {
						labels: radarLabels,
						datasets: radarDatasets
					},
					options: {
						responsive: true,
						maintainAspectRatio: true,
						plugins: {
							legend: {
								position: 'top',
								labels: {
									font: {
										size: 11
									}
								}
							},
							tooltip: {
								callbacks: {
									label: function(context) {
										return `${context.dataset.label}: ${context.raw.toFixed(1)}%`;
									}
								}
							}
						},
						scales: {
							r: {
								beginAtZero: true,
								max: 100,
								ticks: {
									callback: function(value) {
										return value + '%';
									},
									stepSize: 20
								},
								pointLabels: {
									font: {
										size: 11
									}
								}
							}
						}
					}
				});
			}
			
			// 4. Обновляем размеры canvas при изменении размера окна
			window.addEventListener('resize', function() {
				if (window.psychologyProfileChartInstance) {
					window.psychologyProfileChartInstance.resize();
				}
				if (window.normDistributionChartInstance) {
					window.normDistributionChartInstance.resize();
				}
				if (window.radarChartInstance) {
					window.radarChartInstance.resize();
				}
			});
		}

		function generatePsychologyRecommendations() {
			return `
				<div class="recommendation-card">
					<h4>?? Психолого-педагогические рекомендации</h4>
					
					<p><strong>Интерпретация результатов:</strong></p>
					<ul>
						<li>Учитывать контекст проведения диагностики</li>
						<li>Соотносить с возрастными нормами</li>
						<li>Учитывать социально-культурные особенности</li>
						<li>Интерпретировать в комплексе с другими данными</li>
					</ul>
					
					<p><strong>Рекомендации:</strong></p>
					<ul>
						<li>Для учащихся с низкими показателями: индивидуальные консультации</li>
						<li>Для группы: развивающие занятия</li>
						<li>Для педагогов: методические рекомендации</li>
						<li>Для родителей: информационные беседы</li>
					</ul>
				</div>
			`;
		}

		function generatePsychologyReport() {
			return `
				<div class="section">
					<h3>?? Психологическое заключение</h3>
					
					<div class="recommendation-card">
						<p><strong>Цель диагностики:</strong> ${appData.test.goals || 'Не указана'}</p>
						<p><strong>Методика:</strong> ${appData.test.theme || 'Не указана'}</p>
						<p><strong>Дата проведения:</strong> ${new Date(appData.test.testDate).toLocaleDateString()}</p>
						<p><strong>Выборка:</strong> ${appData.students.length} человек, ${appData.test.class}</p>
					</div>
					
					<h4>Ключевые выводы:</h4>
					${generatePsychologyConclusions()}
					
					<h4>Рекомендации:</h4>
					${generateDetailedPsychologyRecommendations()}
				</div>
			`;
		}
		
		function calculatePsychologyGrade(totalScore) {
			const settings = appData.test.psychologySettings;
			if (!settings) return calculateGrade(totalScore); // fallback
			
			const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0);
			const percentage = (totalScore / maxPossible) * 100;
			
			switch(settings.scaleType) {
				case '1-5':
					for (let i = 1; i <= 5; i++) {
						if (percentage >= settings[`min${i}`] && percentage <= settings[`max${i}`]) {
							return i;
						}
					}
					break;
					
				case 'percentage':
					if (percentage < 25) return 'Низкий';
					if (percentage < 50) return 'Ниже среднего';
					if (percentage < 75) return 'Средний';
					if (percentage < 90) return 'Выше среднего';
					return 'Высокий';
					
				case 'levels':
					const levels = settings.levels || [];
					for (let level of levels) {
						if (percentage >= level.min && percentage <= level.max) {
							return level.name;
						}
					}
					break;
			}
			
			return 'Не определено';
		}		

        // Загрузка примера данных
        function loadSampleData() {
            const workType = document.getElementById('workType').value;
            
            if (workType === 'vpr') {
                loadVPRSample();
            } else if (workType === 'func_literacy') {
                loadLiteracySample();
            } else if (workType === 'oge') {
                loadOGESample();
            } else if (workType === 'psychology') {
                loadPsychologySample();
			} else if (workType === 'ege') {
                loadEGESample();
            } else {
                loadStandardSample();
            }
        }
		
		function loadPsychologySample() {
			appData = {
				test: {
					subject: "Психология",
					class: "10А",
					testDate: new Date().toISOString().split('T')[0],
					theme: "Диагностика эмоционального интеллекта (тест MSCEIT)",
					goals: "Оценка уровня развития эмоционального интеллекта по 4 ветвям: восприятие эмоций, использование эмоций, понимание эмоций, управление эмоциями",
					workType: "psychology",
					workFormat: "test",
					timeLimit: 40,
					totalStudents: 25,
					presentStudents: 22,
					absentReason: "3 учащихся - участие в олимпиаде",
					criteria: {
						5: { min: 85, max: 100, label: "Очень высокий" },
						4: { min: 70, max: 84, label: "Высокий" },
						3: { min: 50, max: 69, label: "Средний" },
						2: { min: 30, max: 49, label: "Низкий" },
						1: { min: 0, max: 29, label: "Очень низкий" }
					},
					psychologySettings: {
						scaleType: '1-5',
						usePercentages: true,
						interpretationMethod: "normative",
						normGroup: "Подростки 15-17 лет, n=500",
						reliability: 0.87,
						validity: "Содержательная и конструктная",
						levels: [
							{ 
								id: 1, 
								name: "Очень низкий", 
								min: 0, 
								max: 29, 
								color: "#c0392b",
								interpretation: "Требуется развитие базовых навыков",
								recommendation: "Индивидуальная коррекционная работа"
							},
							{ 
								id: 2, 
								name: "Низкий", 
								min: 30, 
								max: 49, 
								color: "#e74c3c",
								interpretation: "Выраженные трудности в данной сфере",
								recommendation: "Групповые тренинговые занятия"
							},
							{ 
								id: 3, 
								name: "Средний", 
								min: 50, 
								max: 69, 
								color: "#f39c12",
								interpretation: "Соответствует возрастной норме",
								recommendation: "Поддерживающие занятия"
							},
							{ 
								id: 4, 
								name: "Высокий", 
								min: 70, 
								max: 84, 
								color: "#3498db",
								interpretation: "Хорошо развитые способности",
								recommendation: "Развитие и применение навыков"
							},
							{ 
								id: 5, 
								name: "Очень высокий", 
								min: 85, 
								max: 100, 
								color: "#27ae60",
								interpretation: "Выдающиеся способности",
								recommendation: "Профильное развитие"
							}
						],
						dimensions: [
							{
								id: "perception",
								name: "Восприятие эмоций",
								description: "Способность точно воспринимать эмоции"
							},
							{
								id: "use",
								name: "Использование эмоций",
								description: "Способность использовать эмоции для повышения эффективности мышления"
							},
							{
								id: "understanding",
								name: "Понимание эмоций",
								description: "Способность понимать сложные эмоции и их переходы"
							},
							{
								id: "management",
								name: "Управление эмоциями",
								description: "Способность управлять эмоциями для достижения целей"
							}
						],
						reportSections: [
							"Общая характеристика выборки",
							"Профиль эмоционального интеллекта",
							"Сравнение с нормой",
							"Индивидуальные особенности",
							"Рекомендации"
						]
					}
				},
				tasks: [
					{ 
						type: "Распознавание эмоций по фото", 
						maxScore: 10, 
						level: 1, 
						knowledge: "Восприятие эмоций",
						dimension: "perception",
						subscale: "Лицевые выражения",
						number: 1 
					},
					{ 
						type: "Идентификация эмоций в истории", 
						maxScore: 8, 
						level: 2, 
						knowledge: "Восприятие эмоций",
						dimension: "perception",
						subscale: "Эмоции в контексте",
						number: 2 
					},
					{ 
						type: "Эмоции и цвета", 
						maxScore: 6, 
						level: 1, 
						knowledge: "Использование эмоций",
						dimension: "use",
						subscale: "Ассоциации",
						number: 3 
					},
					{ 
						type: "Эмоции и решения", 
						maxScore: 12, 
						level: 3, 
						knowledge: "Использование эмоций",
						dimension: "use",
						subscale: "Принятие решений",
						number: 4 
					},
					{ 
						type: "Сложные эмоции", 
						maxScore: 15, 
						level: 3, 
						knowledge: "Понимание эмоций",
						dimension: "understanding",
						subscale: "Дифференциация",
						number: 5 
					},
					{ 
						type: "Эмоциональные переходы", 
						maxScore: 10, 
						level: 4, 
						knowledge: "Понимание эмоций",
						dimension: "understanding",
						subscale: "Динамика",
						number: 6 
					},
					{ 
						type: "Управление гневом", 
						maxScore: 12, 
						level: 2, 
						knowledge: "Управление эмоциями",
						dimension: "management",
						subscale: "Регуляция",
						number: 7 
					},
					{ 
						type: "Эмпатический ответ", 
						maxScore: 17, 
						level: 4, 
						knowledge: "Управление эмоциями",
						dimension: "management",
						subscale: "Эмпатия",
						number: 8 
					}
				],
				students: [
					"Иванова Анна", "Петров Максим", "Сидорова Екатерина",
					"Козлов Артем", "Николаева София", "Федоров Дмитрий",
					"Морозова Виктория", "Волков Кирилл", "Лебедева Анастасия",
					"Семенов Илья", "Кузнецова Мария", "Павлов Александр",
					"Орлова Дарья", "Жуков Никита", "Тихонова Елена",
					"Белов Роман", "Громова Алиса", "Ларин Михаил",
					"Ефимова Полина", "Сорокин Иван", "Данилова Ольга",
					"Комаров Георгий"
				],
				results: [
					// Иванова Анна
					[8, 6, 4, 9, 12, 8, 9, 14],
					// Петров Максим
					[6, 5, 3, 7, 8, 6, 7, 10],
					// Сидорова Екатерина
					[9, 7, 5, 10, 14, 9, 11, 16],
					// Козлов Артем
					[7, 5, 4, 8, 10, 7, 8, 12],
					// Николаева София
					[5, 4, 2, 6, 7, 5, 6, 9],
					// Федоров Дмитрий
					[10, 8, 6, 12, 15, 10, 12, 17],
					// Морозова Виктория
					[8, 6, 5, 9, 13, 8, 10, 15],
					// Волков Кирилл
					[4, 3, 2, 5, 6, 4, 5, 8],
					// Лебедева Анастасия
					[7, 6, 4, 8, 11, 7, 9, 13],
					// Семенов Илья
					[9, 7, 5, 11, 14, 9, 11, 16],
					// Кузнецова Мария
					[6, 5, 3, 7, 9, 6, 7, 11],
					// Павлов Александр
					[8, 6, 4, 9, 12, 8, 10, 14],
					// Орлова Дарья
					[5, 4, 2, 6, 8, 5, 6, 9],
					// Жуков Никита
					[10, 8, 6, 12, 15, 10, 12, 17],
					// Тихонова Елена
					[7, 5, 4, 8, 11, 7, 9, 13],
					// Белов Роман
					[8, 6, 5, 9, 13, 8, 10, 15],
					// Громова Алиса
					[6, 5, 3, 7, 10, 6, 8, 12],
					// Ларин Михаил
					[9, 7, 5, 10, 14, 9, 11, 16],
					// Ефимова Полина
					[4, 3, 2, 5, 7, 4, 5, 8],
					// Сорокин Иван
					[8, 6, 4, 9, 12, 8, 9, 14],
					// Данилова Ольга
					[7, 5, 4, 8, 11, 7, 9, 13],
					// Комаров Георгий
					[6, 5, 3, 7, 9, 6, 7, 11]
				],
				errors: []
			};
			
			// Генерация психологических ошибок/особенностей
			generatePsychologyFeatures();
			
			saveData();
			renderAll();
			showNotification("Пример данных по психологии загружен! Проверьте настройки критериев оценивания.", "success");
		}

		function generatePsychologyFeatures() {
			const features = [
				{ type: "perception_bias", name: "Склонность к негативной интерпретации", color: "#9b59b6" },
				{ type: "emotional_avoidance", name: "Избегание эмоциональных ситуаций", color: "#e67e22" },
				{ type: "overcontrol", name: "Чрезмерный контроль эмоций", color: "#3498db" },
				{ type: "empathy_deficit", name: "Дефицит эмпатии", color: "#e74c3c" },
				{ type: "emotional_awareness", name: "Высокая эмоциональная осведомленность", color: "#27ae60" },
				{ type: "stress_tolerance", name: "Высокая стрессоустойчивость", color: "#2ecc71" }
			];
			
			appData.psychologyFeatures = [];
			
			features.forEach(feature => {
				const randomStudents = [];
				const count = Math.floor(Math.random() * 4) + 2; // 2-5 учащихся
				
				for (let i = 0; i < count; i++) {
					const studentIndex = Math.floor(Math.random() * appData.students.length);
					if (!randomStudents.includes(studentIndex)) {
						randomStudents.push(studentIndex);
						
						appData.psychologyFeatures.push({
							studentIndex: studentIndex,
							type: feature.type,
							name: feature.name,
							severity: Math.floor(Math.random() * 3) + 1, // 1-3
							description: `Проявляется в заданиях ${getRandomTasks()}`,
							recommendation: getFeatureRecommendation(feature.type)
						});
					}
				}
			});
		}

		function getRandomTasks() {
			const tasks = [];
			const count = Math.floor(Math.random() * 3) + 1;
			for (let i = 0; i < count; i++) {
				tasks.push(Math.floor(Math.random() * appData.tasks.length) + 1);
			}
			return tasks.join(', ');
		}

		function getFeatureRecommendation(featureType) {
			const recommendations = {
				"perception_bias": "Когнитивно-поведенческая коррекция",
				"emotional_avoidance": "Экспозиционная терапия",
				"overcontrol": "Тренинг эмоциональной экспрессии",
				"empathy_deficit": "Тренинг развития эмпатии",
				"emotional_awareness": "Развитие рефлексивных навыков",
				"stress_tolerance": "Обучение техникам релаксации"
			};
			return recommendations[featureType] || "Индивидуальная консультация";
		}

        function loadStandardSample() {
            appData = {
                test: {
                    subject: "Математика",
                    class: "5А",
                    testDate: new Date().toISOString().split('T')[0],
                    theme: "Дроби и проценты",
                    goals: "1. Сложение и вычитание дробей\n2. Умножение и деление дробей\n3. Нахождение процентов от числа\n4. Решение текстовых задач на проценты",
                    workType: "current",
                    workFormat: "mixed",
                    timeLimit: 45,
                    totalStudents: 25,
                    presentStudents: 23,
                    absentReason: "2 учащихся - болезнь",
                    criteria: {
                        5: { min: 22, max: 24 },
                        4: { min: 18, max: 21 },
                        3: { min: 12, max: 17 },
                        2: { min: 0, max: 11 }
                    }
                },
                tasks: [
                    { type: "Сложение дробей", maxScore: 3, level: 1, knowledge: "правила сложения дробей" },
                    { type: "Вычитание дробей", maxScore: 2, level: 1, knowledge: "правила вычитания дробей" },
                    { type: "Умножение дробей", maxScore: 4, level: 2, knowledge: "умножение дробей" },
                    { type: "Деление дробей", maxScore: 3, level: 2, knowledge: "деление дробей" },
                    { type: "Проценты от числа", maxScore: 2, level: 2, knowledge: "нахождение процентов" },
                    { type: "Нахождение числа по %", maxScore: 3, level: 3, knowledge: "обратные задачи на проценты" },
                    { type: "Задачи на проценты", maxScore: 4, level: 3, knowledge: "текстовые задачи" },
                    { type: "Сложные задачи", maxScore: 3, level: 4, knowledge: "комбинированные задачи" }
                ],
                students: [
                    "Иванов Алексей", "Петрова Мария", "Сидоров Дмитрий",
                    "Козлова Анна", "Николаев Иван", "Федорова Елена",
                    "Морозов Павел", "Васнецова Ольга", "Лебедев Сергей",
                    "Семенова Ирина", "Кузнецов Андрей", "Павлова Наталья",
                    "Орлов Максим", "Жукова Виктория", "Тихонов Артем",
                    "Белова София", "Громов Кирилл", "Ларина Дарья",
                    "Ефимов Роман", "Сорокина Алиса", "Данилов Марк",
                    "Комарова Полина", "Новиков Глеб"
                ],
                results: [
                    [3, 2, 4, 3, 2, 3, 4, 3],
                    [2, 1, 3, 2, 2, 2, 3, 2],
                    [3, 2, 4, 3, 1, 3, 4, 3],
                    [1, 1, 2, 1, 1, 1, 2, 1],
                    [3, 2, 3, 3, 2, 3, 3, 3],
                    [2, 2, 3, 2, 2, 2, 3, 2],
                    [3, 1, 4, 3, 2, 3, 4, 3],
                    [2, 2, 3, 2, 1, 2, 3, 2],
                    [3, 2, 4, 3, 2, 3, 4, 3],
                    [1, 1, 2, 1, 1, 1, 2, 1],
                    [3, 2, 3, 3, 2, 3, 3, 3],
                    [2, 2, 3, 2, 2, 2, 3, 2],
                    [3, 2, 4, 3, 2, 3, 4, 2],
                    [2, 2, 3, 2, 2, 2, 3, 1],
                    [3, 1, 4, 3, 1, 3, 3, 2],
                    [2, 2, 3, 2, 2, 2, 2, 1],
                    [3, 2, 3, 3, 2, 2, 3, 2],
                    [2, 1, 3, 2, 1, 2, 2, 1],
                    [3, 2, 4, 3, 2, 3, 3, 2],
                    [2, 2, 3, 2, 2, 2, 3, 1],
                    [3, 1, 3, 3, 1, 2, 2, 1],
                    [2, 2, 2, 2, 2, 1, 2, 0],
                    [1, 1, 2, 1, 1, 1, 1, 0]
                ],
                errors: []
            };
            
            generateSampleErrors();
            
            saveData();
            renderAll();
            showNotification("Пример данных загружен! Можете перейти в раздел Аналитика для просмотра отчетов.", "success");
        }

        // Остальные функции загрузки примеров (VPR, Literacy, OGE, EGE) остаются без изменений
        function loadVPRSample() {
            appData = {
                test: {
                    subject: "Математика",
                    class: "5А",
                    testDate: new Date().toISOString().split('T')[0],
                    theme: "ВПР по математике",
                    goals: "Проверка базовых математических компетенций учащихся",
                    workType: "vpr",
                    workFormat: "test",
                    timeLimit: 45,
                    totalStudents: 25,
                    presentStudents: 23,
                    absentReason: "2 учащихся - болезнь",
                    criteria: {
                        5: { min: 18, max: 20 },
                        4: { min: 15, max: 17 },
                        3: { min: 10, max: 14 },
                        2: { min: 0, max: 9 }
                    }
                },
                tasks: [
                    { type: "Арифметические действия", maxScore: 1, level: 1, knowledge: "вычисления", competence: "calculations", vprLevel: 1, number: 1 },
                    { type: "Текстовая задача", maxScore: 1, level: 1, knowledge: "решение задач", competence: "text_work", vprLevel: 1, number: 2 },
                    { type: "Геометрическая задача", maxScore: 1, level: 1, knowledge: "геометрия", competence: "graphics", vprLevel: 1, number: 3 },
                    { type: "Работа с таблицей", maxScore: 2, level: 2, knowledge: "анализ данных", competence: "data_work", vprLevel: 2, number: 4 },
                    { type: "Логическая задача", maxScore: 2, level: 2, knowledge: "логика", competence: "logic", vprLevel: 2, number: 5 }
                ],
                students: ["Иванов А.", "Петрова М.", "Сидоров Д.", "Козлова А.", "Николаев И."],
                results: [
                    [1, 1, 1, 2, 2],
                    [1, 1, 1, 1, 1],
                    [1, 1, 1, 2, 1],
                    [0, 1, 1, 1, 0],
                    [1, 1, 0, 1, 1]
                ],
                errors: []
            };
            
            generateSampleErrors();
            saveData();
            renderAll();
            showNotification("Пример данных ВПР загружен!", "success");
        }

        function loadLiteracySample() {
            appData = {
                test: {
                    subject: "Межпредметная",
                    class: "6А", 
                    testDate: new Date().toISOString().split('T')[0],
                    theme: "Комплексная работа по функциональной грамотности",
                    goals: "Оценка уровня сформированности функциональной грамотности",
                    workType: "func_literacy",
                    workFormat: "mixed",
                    timeLimit: 60,
                    totalStudents: 25,
                    presentStudents: 23,
                    absentReason: "2 учащихся - болезнь",
                    criteria: {
                        5: { min: 90, max: 100 },
                        4: { min: 75, max: 89 },
                        3: { min: 50, max: 74 },
                        2: { min: 0, max: 49 }
                    }
                },
                tasks: [
                    { type: "Чтение инструкции", maxScore: 2, level: 1, knowledge: "понимание текста", literacyType: "reading", skill: "Понимание инструкций", context: "personal", number: 1 },
                    { type: "Расчет бюджета", maxScore: 3, level: 2, knowledge: "финансовая грамотность", literacyType: "financial", skill: "Планирование расходов", context: "personal", number: 2 },
                    { type: "Анализ графика", maxScore: 2, level: 2, knowledge: "работа с данными", literacyType: "math", skill: "Чтение графиков", context: "social", number: 3 },
                    { type: "Оценка новости", maxScore: 3, level: 3, knowledge: "критическое мышление", literacyType: "digital", skill: "Критическое мышление", context: "global", number: 4 }
                ],
                students: ["Иванов А.", "Петрова М.", "Сидоров Д.", "Козлова А.", "Николаев И."],
                results: [
                    [2, 3, 2, 3],
                    [2, 2, 1, 2],
                    [1, 3, 2, 2],
                    [1, 1, 1, 1],
                    [2, 2, 2, 2]
                ],
                errors: []
            };
            
            generateSampleErrors();
            saveData();
            renderAll();
            showNotification("Пример данных по функциональной грамотности загружен!", "success");
        }

        function loadOGESample() {
            appData = {
                test: {
                    subject: "Математика",
                    class: "9А", 
                    testDate: new Date().toISOString().split('T')[0],
                    theme: "Пробный ОГЭ по математике",
                    goals: "Подготовка к государственной итоговой аттестации",
                    workType: "oge",
                    workFormat: "mixed",
                    timeLimit: 235,
                    totalStudents: 25,
                    presentStudents: 23,
                    absentReason: "2 учащихся - болезнь",
                    criteria: {
                        5: { min: 22, max: 32 },
                        4: { min: 15, max: 21 },
                        3: { min: 8, max: 14 },
                        2: { min: 0, max: 7 }
                    }
                },
                tasks: [
                    { type: "Преобразование выражений", maxScore: 1, level: 1, knowledge: "алгебра", kes: "1.1", pu: "Вычисления", answerType: "short", number: 1 },
                    { type: "Уравнения", maxScore: 1, level: 1, knowledge: "алгебра", kes: "1.2", pu: "Решение уравнений", answerType: "short", number: 2 },
                    { type: "Геометрическая задача", maxScore: 1, level: 2, knowledge: "геометрия", kes: "2.1", pu: "Решение геометрических задач", answerType: "short", number: 3 },
                    { type: "Текстовая задача", maxScore: 2, level: 2, knowledge: "алгебра", kes: "1.3", pu: "Решение текстовых задач", answerType: "detailed", number: 4 }
                ],
                students: ["Иванов А.", "Петрова М.", "Сидоров Д.", "Козлова А.", "Николаев И."],
                results: [
                    [1, 1, 1, 2],
                    [1, 1, 0, 1],
                    [1, 1, 1, 2],
                    [0, 1, 1, 1],
                    [1, 1, 1, 1]
                ],
                errors: []
            };
            
            generateSampleErrors();
            saveData();
            renderAll();
            showNotification("Пример данных ОГЭ загружен!", "success");
        }

        function loadEGESample() {
            appData = {
                test: {
                    subject: "Математика",
                    class: "11А", 
                    testDate: new Date().toISOString().split('T')[0],
                    theme: "Пробный ЕГЭ по математике (профиль)",
                    goals: "Подготовка к единому государственному экзамену",
                    workType: "ege",
                    workFormat: "mixed",
                    timeLimit: 235,
                    totalStudents: 25,
                    presentStudents: 23,
                    absentReason: "2 учащихся - болезнь",
                    criteria: {
                        5: { min: 27, max: 31 },
                        4: { min: 20, max: 26 },
                        3: { min: 12, max: 19 },
                        2: { min: 0, max: 11 }
                    }
                },
                tasks: [
                    { type: "Простейшие уравнения", maxScore: 1, level: 1, knowledge: "алгебра", kes: "1.1", pu: "Решение уравнений", answerType: "short", number: 1 },
                    { type: "Стереометрия", maxScore: 1, level: 2, knowledge: "геометрия", kes: "2.1", pu: "Решение стереометрических задач", answerType: "short", number: 2 },
                    { type: "Экономическая задача", maxScore: 2, level: 3, knowledge: "алгебра", kes: "1.4", pu: "Решение прикладных задач", answerType: "detailed", number: 3 },
                    { type: "Задача с параметром", maxScore: 4, level: 4, knowledge: "алгебра", kes: "1.5", pu: "Исследование функций", answerType: "detailed", number: 4 }
                ],
                students: ["Иванов А.", "Петрова М.", "Сидоров Д.", "Козлова А.", "Николаев И."],
                results: [
                    [1, 1, 2, 3],
                    [1, 1, 1, 1],
                    [1, 1, 2, 2],
                    [0, 1, 1, 0],
                    [1, 0, 1, 1]
                ],
                errors: []
            };
            
            generateSampleErrors();
            saveData();
            renderAll();
            showNotification("Пример данных ЕГЭ загружен!", "success");
        }

        // Генерация примеров ошибок
        function generateSampleErrors() {
            const errorDistribution = {
                factual: 2,
                conceptual: 4,
                application: 3,
                calculation: 6,
                logical: 3,
                attention: 5,
                technical: 2
            };
            
            appData.errors = [];
            Object.keys(errorDistribution).forEach(errorType => {
                for (let i = 0; i < errorDistribution[errorType]; i++) {
                    const randomTask = Math.floor(Math.random() * appData.tasks.length);
                    const randomStudent = Math.floor(Math.random() * appData.students.length);
                    
                    appData.errors.push({
                        studentIndex: randomStudent,
                        taskIndex: randomTask,
                        type: errorType,
                        description: `Пример ${errorTypes[errorType].name.toLowerCase()} в задании ${randomTask + 1}`,
                        count: Math.floor(Math.random() * 3) + 1
                    });
                }
            });
        }
		function validateGradeCalculation() {
			console.log('=== VALIDATION ===');
			console.log('Test data:', appData.test);
			console.log('Tasks:', appData.tasks);
			
			// Проверка на тестовых данных
			const testScores = [0, 10, 50, 75, 90, 100];
			const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0);
			
			console.log('\nTest calculations:');
			testScores.forEach(score => {
				const grade = calculateGrade(score);
				console.log(`${score} баллов > ${grade} (${getGradeDisplay(grade)})`);
			});
		}
		// Сохранение настроек теста
		function saveTestSettings() {
			console.log('=== СОХРАНЕНИЕ НАСТРОЕК ТЕСТА ===');
			
			// Сохраняем основные настройки
			appData.test.subject = document.getElementById('subject').value;
			appData.test.class = document.getElementById('class').value;
			appData.test.testDate = document.getElementById('testDate').value;
			appData.test.theme = document.getElementById('testTheme').value;
			appData.test.goals = document.getElementById('testGoals').value;
			appData.test.workType = document.getElementById('workType').value;
			appData.test.workFormat = document.getElementById('workFormat').value;
			appData.test.timeLimit = parseInt(document.getElementById('timeLimit').value);
			appData.test.totalStudents = parseInt(document.getElementById('totalStudents').value);
			appData.test.presentStudents = parseInt(document.getElementById('presentStudents').value);
			appData.test.absentReason = document.getElementById('absentReason').value;
			
			// Сохраняем настройки критериев
			appData.test.criteriaType = document.getElementById('criteriaType').value;
			appData.test.criteriaSystem = document.getElementById('criteriaSystem').value;
			
			let criteriaCount = parseInt(document.getElementById('criteriaCount').value) || 4;
			
			// Для стандартной системы фиксируем 4 уровня
			if (appData.test.criteriaSystem === 'standard') {
				criteriaCount = 4;
			}
			
			appData.test.criteriaCount = criteriaCount;
			
			console.log('Тип критериев:', appData.test.criteriaType);
			console.log('Система:', appData.test.criteriaSystem);
			console.log('Количество уровней:', criteriaCount);
			
			// Обновляем количество студентов если изменилось
			const newStudentCount = parseInt(document.getElementById('presentStudents').value);
			const currentStudentCount = appData.students.length;
			
			if (newStudentCount !== currentStudentCount) {
				setStudentsCount(newStudentCount);
			}
			
			// Сохраняем значения критериев
			appData.test.criteria = {}; // Очищаем старые
			
			const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0);
			console.log('Максимальный балл:', maxPossible);
			
			for (let i = 1; i <= criteriaCount; i++) {
				const minElement = document.getElementById(`criteria${i}min`);
				const maxElement = document.getElementById(`criteria${i}max`);
				
				if (minElement && maxElement) {
					const minValue = parseInt(minElement.value) || 0;
					const maxValue = parseInt(maxElement.value) || 0;
					
					// Автоматическая коррекция если min > max
					if (minValue > maxValue) {
						appData.test.criteria[i] = {
							min: maxValue,
							max: minValue
						};
						console.log(`Критерий ${i}: скорректирован (${maxValue}-${minValue})`);
					} else {
						appData.test.criteria[i] = {
							min: minValue,
							max: maxValue
						};
						console.log(`Критерий ${i}: ${minValue}-${maxValue}`);
					}
				} else {
					// Если поля не найдены, создаем по умолчанию
					console.warn(`Поля для критерия ${i} не найдены! Создаем по умолчанию.`);
					
					if (appData.test.criteriaType === 'percentage') {
						const step = 100 / criteriaCount;
						appData.test.criteria[i] = {
							min: Math.round((i - 1) * step),
							max: Math.round(i * step)
						};
					} else {
						const step = maxPossible / criteriaCount;
						appData.test.criteria[i] = {
							min: Math.round((i - 1) * step),
							max: Math.round(i * step)
						};
					}
				}
			}
			
			console.log('Итоговые критерии:', appData.test.criteria);
			
			saveData();
			renderAll();
			showNotification("Настройки теста сохранены!", "success");
			debugCriteria();
		}

        // Рендер всех интерфейсов
        function renderAll() {
            renderTestSettings();
            renderTasks();
			
            renderStudents();
            renderResults();
			renderCriteriaSettings(); // Добавляем эту строку
        }

        // Рендер настроек теста
        function renderTestSettings() {
			try {
				// Безопасно устанавливаем значения только если элементы существуют
				safeSetValue('subject', appData.test.subject);
				safeSetValue('class', appData.test.class);
				safeSetValue('testDate', appData.test.testDate);
				safeSetValue('testTheme', appData.test.theme);
				safeSetValue('testGoals', appData.test.goals);
				safeSetValue('workType', appData.test.workType);
				safeSetValue('workFormat', appData.test.workFormat);
				safeSetValue('timeLimit', appData.test.timeLimit);
				safeSetValue('totalStudents', appData.test.totalStudents);
				safeSetValue('presentStudents', appData.test.presentStudents);
				safeSetValue('absentReason', appData.test.absentReason);
				
				// Критерии - проверяем наличие элементов перед установкой
				if (appData.test.criteria) {
					safeSetValue('criteria5min', appData.test.criteria[5]?.min || 0);
					safeSetValue('criteria5max', appData.test.criteria[5]?.max || 0);
					safeSetValue('criteria4min', appData.test.criteria[4]?.min || 0);
					safeSetValue('criteria4max', appData.test.criteria[4]?.max || 0);
					safeSetValue('criteria3min', appData.test.criteria[3]?.min || 0);
					safeSetValue('criteria3max', appData.test.criteria[3]?.max || 0);
					safeSetValue('criteria2min', appData.test.criteria[2]?.min || 0);
					safeSetValue('criteria2max', appData.test.criteria[2]?.max || 0);
				}
			} catch (error) {
				console.error('Ошибка в renderTestSettings:', error);
			}
        }

		// Вспомогательная функция для безопасной установки значений
		function safeSetValue(elementId, value) {
			try {
				const element = document.getElementById(elementId);
				if (element) {
					element.value = value || '';
				}
			} catch (error) {
				console.warn(`Не удалось установить значение для элемента ${elementId}:`, error);
			}
		}

        // Функция для определения количества заданий по умолчанию
        function getDefaultTaskCount() {
            switch(appData.test.workType) {
                case 'oge': return 15;
                case 'ege': return 19;
                case 'vpr': return 12;
                case 'func_literacy': return 8;
                default: return 8;
            }
        }

        // Рендер заданий с таксономией
		function renderTasks() {
			const container = document.getElementById('tasksContainer');
			if (!container) return;
			
			let html = `
				<div id="tasksList" style="margin-bottom: 20px;">
					<h3 style="display: flex; justify-content: space-between; align-items: center;">
						?? Задания
						<button class="btn btn-info" onclick="showTasksMenu()">
							?? Управление заданиями
						</button>
						<button class="btn btn-success" onclick="addNewTask()">
							+ Добавить задание
						</button>
					</h3>
					<div style="background: #f8f9fa; padding: 10px; border-radius: 8px; margin-bottom: 15px;">
						<small>?? Перетаскивайте задания за заголовок для изменения порядка</small>
					</div>
			`;
			
			if (appData.tasks.length === 0) {
				html += `
					<div style="text-align: center; padding: 40px; color: #666;">
						<div style="font-size: 3em;">??</div>
						<p>Задания ещё не добавлены</p>
						<button class="btn btn-primary" onclick="addNewTask()">
							Добавить первое задание
						</button>
					</div>
				`;
			} else {
				appData.tasks.forEach((task, index) => {
					const levelName = complexityLevels[task.level]?.name || `Уровень ${task.level}`;
					const levelColor = complexityLevels[task.level]?.color || '#ccc';
					
					// Значения с fallback
					const codeKES = task.codeKES || '';
					const codePU = task.codePU || '';
					const contentElement = task.contentElement || '';
					const answerType = task.answerType || 'Краткий ответ';
					const description = task.description || '';
					const competency = task.competency || '';
					
					html += `
						<div class="task-card" data-index="${index}" 
							 style="background: white; border: 1px solid #dee2e6; border-radius: 8px; margin-bottom: 15px; cursor: move;"
							 draggable="true"
							 ondragstart="dragTaskStart(event, ${index})"
							 ondragover="dragTaskOver(event)"
							 ondrop="dropTask(event, ${index})">
							
							<!-- Заголовок с номером и кнопками -->
							<div class="task-header" 
								 style="background: #f8f9fa; padding: 12px 15px; border-bottom: 1px solid #dee2e6; border-radius: 8px 8px 0 0; display: flex; justify-content: space-between; align-items: center;">
								<div style="display: flex; align-items: center; gap: 10px;">
									<span style="background: #6c757d; color: white; width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold;">
										${index + 1}
									</span>
									<h5 style="margin: 0; cursor: move;">
										Задание ${index + 1}
										<small style="color: #6c757d; margin-left: 5px;">(перетащите)</small>
									</h5>
								</div>
								<div>
									<button class="btn btn-sm btn-danger" onclick="event.stopPropagation(); removeTask(${index})" 
											style="margin-left: 5px;">
										??? Удалить
									</button>
								</div>
							</div>
							
							<!-- Содержимое задания -->
							<div class="task-body" style="padding: 20px;">
								<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin-bottom: 20px;">
									
									<!-- Тип задания -->
									<div class="form-group">
										<label><strong>Тип задания:</strong></label>
										<select class="form-control" 
												value="${task.type || 'Выбор ответа'}"
												onchange="updateTaskField(${index}, 'type', this.value)">
											<option value="Выбор ответа" ${task.type === 'Выбор ответа' ? 'selected' : ''}>
												Выбор ответа
											</option>
											<option value="Краткий ответ" ${task.type === 'Краткий ответ' ? 'selected' : ''}>
												Краткий ответ
											</option>
											<option value="Развернутый ответ" ${task.type === 'Развернутый ответ' ? 'selected' : ''}>
												Развернутый ответ
											</option>
											<option value="Соответствие" ${task.type === 'Соответствие' ? 'selected' : ''}>
												Соответствие
											</option>
											<option value="Практическое задание" ${task.type === 'Практическое задание' ? 'selected' : ''}>
												Практическое задание
											</option>
										</select>
									</div>
									
									<!-- Максимальный балл -->
									<div class="form-group">
										<label><strong>Максимальный балл:</strong></label>
										<input type="number" class="form-control" 
											   value="${task.maxScore || 1}" 
											   min="0" max="100"
											   onchange="updateTaskField(${index}, 'maxScore', parseInt(this.value) || 1)">
									</div>
									
									<!-- Уровень сложности -->
									<div class="form-group">
										<label><strong>Уровень сложности:</strong></label>
										<select class="form-control" 
												onchange="updateTaskField(${index}, 'level', parseInt(this.value) || 1)">
											${Object.entries(complexityLevels).map(([key, level]) => `
												<option value="${key}" ${task.level == key ? 'selected' : ''}
														style="color: ${level.color};">
													${key}. ${level.name}
												</option>
											`).join('')}
										</select>
										<small style="color: ${levelColor};">
											${levelName} – ${complexityLevels[task.level]?.desc || ''}
										</small>
									</div>
									
									<!-- Тип ответа -->
									<div class="form-group">
										<label><strong>Тип ответа:</strong></label>
										<select class="form-control" 
												onchange="updateTaskField(${index}, 'answerType', this.value)">
											<option value="Краткий ответ" ${answerType === 'Краткий ответ' ? 'selected' : ''}>
												Краткий ответ
											</option>
											<option value="Развернутый ответ" ${answerType === 'Развернутый ответ' ? 'selected' : ''}>
												Развернутый ответ
											</option>
											<option value="Выбор ответа" ${answerType === 'Выбор ответа' ? 'selected' : ''}>
												Выбор ответа
											</option>
											<option value="Соответствие" ${answerType === 'Соответствие' ? 'selected' : ''}>
												Соответствие
											</option>
										</select>
									</div>
									
									<!-- Код КЭС -->
									<div class="form-group">
										<label><strong>Код КЭС:</strong></label>
										<input type="text" class="form-control" 
											   value="${codeKES}" 
											   placeholder="Пример: 1.2.3"
											   onchange="updateTaskField(${index}, 'codeKES', this.value)">
									</div>
									
									<!-- Код ПУ -->
									<div class="form-group">
										<label><strong>Код ПУ:</strong></label>
										<input type="text" class="form-control" 
											   value="${codePU}" 
											   placeholder="Проверяемое умение"
											   onchange="updateTaskField(${index}, 'codePU', this.value)">
									</div>
									
									<!-- Элемент содержания -->
									<div class="form-group">
										<label><strong>Элемент содержания:</strong></label>
										<input type="text" class="form-control" 
											   value="${contentElement}" 
											   placeholder="Что проверяет задание"
											   onchange="updateTaskField(${index}, 'contentElement', this.value)">
									</div>
									
									<!-- Компетенция -->
									<div class="form-group">
										<label><strong>Компетенция:</strong></label>
										<input type="text" class="form-control" 
											   value="${competency}" 
											   placeholder="text_work, calculations, logic и т.д."
											   onchange="updateTaskField(${index}, 'competency', this.value)">
										<small style="color: #666;">
											text_work, calculations, logic, graphics, data_work
										</small>
									</div>
									
								</div>
								
								<!-- Описание задания -->
								<div class="form-group">
									<label><strong>Описание задания:</strong></label>
									<textarea class="form-control" rows="3"
											  placeholder="Полное описание задания для учащихся..."
											  onchange="updateTaskField(${index}, 'description', this.value)"
											  style="width: 100%;">${description}</textarea>
								</div>
								
								<!-- Быстрые действия -->
								<div style="display: flex; gap: 10px; margin-top: 15px; padding-top: 15px; border-top: 1px solid #eee;">
									<button class="btn btn-sm btn-outline-primary" 
											onclick="duplicateTask(${index})">
										?? Дублировать
									</button>
									<button class="btn btn-sm btn-outline-secondary" 
											onclick="moveTaskUp(${index})" ${index === 0 ? 'disabled' : ''}>
										?? Вверх
									</button>
									<button class="btn btn-sm btn-outline-secondary" 
											onclick="moveTaskDown(${index})" ${index === appData.tasks.length - 1 ? 'disabled' : ''}>
										?? Вниз
									</button>
								</div>
							</div>
						</div>
					`;
				});
			}
			
			html += `</div>`;
			
			// Статистика
			if (appData.tasks.length > 0) {
				const totalScore = appData.tasks.reduce((sum, task) => sum + (task.maxScore || 0), 0);
				const levelDistribution = appData.tasks.reduce((acc, task) => {
					acc[task.level] = (acc[task.level] || 0) + 1;
					return acc;
				}, {});
				
				html += `
					<div style="background: #e8f4f8; padding: 15px; border-radius: 8px; margin-top: 20px;">
						<h5>?? Статистика заданий</h5>
						<div style="display: flex; gap: 20px; flex-wrap: wrap;">
							<div>
								<strong>Всего заданий:</strong> ${appData.tasks.length}
							</div>
							<div>
								<strong>Максимальный балл:</strong> ${totalScore}
							</div>
							<div>
								<strong>Распределение по уровням:</strong>
								${Object.entries(levelDistribution).map(([level, count]) => {
									const levelInfo = complexityLevels[level];
									return `<span style="margin-left: 10px; color: ${levelInfo?.color || '#666'}">${level}: ${count}</span>`;
								}).join('')}
							</div>
						</div>
					</div>
				`;
			}
			
			container.innerHTML = html;
			
			// Инициализируем drag-and-drop визуальные эффекты
			initTaskDragAndDrop();
		}
		// Переменные для drag-and-drop
		let draggedTaskIndex = null;

		// Добавить новое задание
		function addNewTask() {
			const newTask = {
				id: 'task_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9), // Добавляем ID
				type: "Выбор ответа",
				maxScore: 1,
				level: 1,
				description: "",
				competency: "text_work",
				errorTypes: [],
				codeKES: "1.1.1",
				codePU: "Проверяемое умение",
				contentElement: "",
				answerType: "Краткий ответ"
			};
			
			appData.tasks.push(newTask);
			saveData();
			renderTasks();
			renderResults(); // Обновить таблицу результатов
			
			showNotification('? Добавлено новое задание', 'success');
			
			// Прокрутить к последнему заданию
			setTimeout(() => {
				const taskCards = document.querySelectorAll('.task-card');
				if (taskCards.length > 0) {
					taskCards[taskCards.length - 1].scrollIntoView({ behavior: 'smooth', block: 'center' });
				}
			}, 100);
		}

		// Удалить задание
		function removeTask(index) {
			if (confirm(`Удалить задание ${index + 1}? Все результаты по этому заданию также будут удалены.`)) {
				// Удаляем задание
				appData.tasks.splice(index, 1);
				
				// Удаляем соответствующий столбец из всех результатов
				appData.results.forEach(studentResults => {
					if (index < studentResults.length) {
						studentResults.splice(index, 1);
					}
				});
				
				saveData();
				renderAll(); // Обновить весь интерфейс
				showNotification('??? Задание удалено', 'info');
			}
		}

		// Дублировать задание
		function duplicateTask(index) {
			const originalTask = appData.tasks[index];
			const duplicatedTask = JSON.parse(JSON.stringify(originalTask));
			
			appData.tasks.splice(index + 1, 0, duplicatedTask);
			
			// Добавить пустой столбец для нового задания в результаты
			appData.results.forEach(studentResults => {
				studentResults.splice(index + 1, 0, 0);
			});
			
			saveData();
			renderAll();
			showNotification('?? Задание дублировано', 'success');
		}

		// Переместить задание вверх
		function moveTaskUp(index) {
			if (index > 0) {
				// Меняем местами задания
				[appData.tasks[index], appData.tasks[index - 1]] = 
				[appData.tasks[index - 1], appData.tasks[index]];
				
				// Меняем местами столбцы в результатах
				appData.results.forEach(studentResults => {
					if (index < studentResults.length && index - 1 < studentResults.length) {
						[studentResults[index], studentResults[index - 1]] = 
						[studentResults[index - 1], studentResults[index]];
					}
				});
				
				saveData();
				renderTasks();
				renderResults();
			}
		}

		// Переместить задание вниз
		function moveTaskDown(index) {
			if (index < appData.tasks.length - 1) {
				// Меняем местами задания
				[appData.tasks[index], appData.tasks[index + 1]] = 
				[appData.tasks[index + 1], appData.tasks[index]];
				
				// Меняем местами столбцы в результатах
				appData.results.forEach(studentResults => {
					if (index < studentResults.length && index + 1 < studentResults.length) {
						[studentResults[index], studentResults[index + 1]] = 
						[studentResults[index + 1], studentResults[index]];
					}
				});
				
				saveData();
				renderTasks();
				renderResults();
			}
		}

		// Обновить поле задания
		function updateTaskField(index, field, value) {
			if (index >= 0 && index < appData.tasks.length) {
				appData.tasks[index][field] = value;
				saveData();
				
				// Если изменился максимальный балл, пересчитать статистику
				if (field === 'maxScore') {
					renderResults(); // Обновить таблицу результатов
				}
			}
		}

		// Drag-and-drop функции
		function dragTaskStart(event, index) {
			draggedTaskIndex = index;
			event.dataTransfer.setData('text/plain', index);
			event.currentTarget.style.opacity = '0.4';
			
			// Добавляем класс для визуального эффекта
			event.currentTarget.classList.add('dragging');
		}

		function dragTaskOver(event) {
			event.preventDefault();
			event.dataTransfer.dropEffect = 'move';
			
			// Визуальный эффект при наведении
			const taskCard = event.currentTarget.closest('.task-card');
			if (taskCard && !taskCard.classList.contains('dragging')) {
				taskCard.style.borderColor = '#3498db';
				taskCard.style.boxShadow = '0 0 10px rgba(52, 152, 219, 0.3)';
			}
		}

		function dropTask(event, targetIndex) {
			event.preventDefault();
			
			if (draggedTaskIndex === null || draggedTaskIndex === targetIndex) {
				resetDragStyles();
				return;
			}
			
			// Восстанавливаем стили
			resetDragStyles();
			
			// Перемещаем задание
			const movedTask = appData.tasks[draggedTaskIndex];
			
			// Удаляем из старой позиции и вставляем в новую
			appData.tasks.splice(draggedTaskIndex, 1);
			appData.tasks.splice(targetIndex, 0, movedTask);
			
			// Перемещаем соответствующие столбцы в результатах
			appData.results.forEach(studentResults => {
				if (draggedTaskIndex < studentResults.length && targetIndex < studentResults.length) {
					const movedScore = studentResults[draggedTaskIndex];
					studentResults.splice(draggedTaskIndex, 1);
					studentResults.splice(targetIndex, 0, movedScore);
				}
			});
			
			saveData();
			renderTasks();
			renderResults();
			
			showNotification('-? Порядок заданий изменен', 'info');
			
			draggedTaskIndex = null;
		}

		function resetDragStyles() {
			// Сбрасываем все стили drag-and-drop
			document.querySelectorAll('.task-card').forEach(card => {
				card.style.opacity = '1';
				card.style.borderColor = '';
				card.style.boxShadow = '';
				card.classList.remove('dragging');
			});
		}

		function initTaskDragAndDrop() {
			// Добавляем обработчики для плавного drag-and-drop
			document.querySelectorAll('.task-card').forEach(card => {
				card.addEventListener('dragend', resetDragStyles);
				card.addEventListener('dragleave', function(e) {
					if (!this.classList.contains('dragging')) {
						this.style.borderColor = '';
						this.style.boxShadow = '';
					}
				});
			});
		}

		// Функция для массового добавления заданий (быстрый ввод)
		function addMultipleTasks() {
			const html = `
				<div style="max-width: 600px;">
					<h3>?? Массовое добавление заданий</h3>
					
					<div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0;">
						<p><strong>Формат:</strong> Тип|Макс. балл|Уровень|Описание</p>
						<p><strong>Пример:</strong> Выбор ответа|1|1|Выберите правильный вариант</p>
					</div>
					
					<div class="form-group">
						<label>Введите задания (каждое с новой строки):</label>
						<textarea id="multipleTasksInput" 
								  class="form-control" 
								  rows="10" 
								  placeholder="Выбор ответа|1|1|Выберите правильный ответ
		Краткий ответ|2|2|Решите уравнение
		Развернутый ответ|5|3|Напишите сочинение"></textarea>
					</div>
					
					<div style="margin-top: 15px;">
						<button class="btn btn-primary" onclick="parseMultipleTasks()">
							Добавить задания
						</button>
						<button class="btn btn-secondary" onclick="hideModal()">
							Отмена
						</button>
					</div>
				</div>
			`;
			
			showModal('Массовое добавление заданий', html);
		}

		function parseMultipleTasks() {
			const input = document.getElementById('multipleTasksInput').value;
			if (!input.trim()) {
				showNotification('Введите данные', 'warning');
				return;
			}
			
			const lines = input.split('\n').filter(line => line.trim());
			let addedCount = 0;
			
			lines.forEach(line => {
				const parts = line.split('|').map(part => part.trim());
				if (parts.length >= 4) {
					const newTask = {
						type: parts[0] || "Выбор ответа",
						maxScore: parseInt(parts[1]) || 1,
						level: parseInt(parts[2]) || 1,
						description: parts[3] || "",
						competency: parts[4] || "text_work",
						errorTypes: [],
						codeKES: parts[5] || "1.1.1",
						codePU: parts[6] || "Проверяемое умение",
						contentElement: parts[7] || "",
						answerType: parts[8] || "Краткий ответ"
					};
					
					appData.tasks.push(newTask);
					addedCount++;
				}
			});
			
			// Добавляем столбцы в результаты
			if (addedCount > 0) {
				appData.results.forEach(studentResults => {
					for (let i = 0; i < addedCount; i++) {
						studentResults.push(0);
					}
				});
				
				saveData();
				renderAll();
				hideModal();
				showNotification(`? Добавлено ${addedCount} заданий`, 'success');
			} else {
				showNotification('Не удалось добавить задания. Проверьте формат.', 'error');
			}
		}
		
		function showTasksMenu() {
			const html = `
				<div style="padding: 20px;">
					<h3>?? Управление заданиями</h3>
					
					<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 20px 0;">
						<button class="btn btn-success" onclick="addNewTask()" style="padding: 15px;">
							+ Добавить задание
						</button>
						
						<button class="btn btn-primary" onclick="addMultipleTasks()" style="padding: 15px;">
							?? Массовое добавление
						</button>
						
						<button class="btn btn-warning" onclick="fixMissingTaskFields()" style="padding: 15px;">
							?? Исправить поля
						</button>
						
						<button class="btn btn-info" onclick="reorderTasksByLevel()" style="padding: 15px;">
							?? Сортировать по уровню
						</button>
					</div>
					
					${appData.tasks.length > 0 ? `
					<div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
						<h5>Быстрые действия:</h5>
						<button class="btn btn-sm btn-outline-danger" onclick="if(confirm('Удалить ВСЕ задания?')) { clearAllTasks(); }">
							??? Удалить все задания
						</button>
						<small style="display: block; margin-top: 10px; color: #666;">
							Заданий: ${appData.tasks.length}, Макс. баллов: ${appData.tasks.reduce((sum, t) => sum + (t.maxScore || 0), 0)}
						</small>
					</div>
					` : ''}
				</div>
			`;
			
			showModal('Управление заданиями', html);
		}

		function reorderTasksByLevel() {
			// Создаем копию с индексами
			const tasksWithIndex = appData.tasks.map((task, index) => ({ task, index }));
			
			// Сортируем по уровню
			tasksWithIndex.sort((a, b) => (a.task.level || 1) - (b.task.level || 1));
			
			// Применяем новую сортировку
			appData.tasks = tasksWithIndex.map(item => item.task);
			
			// Переупорядочиваем результаты
			const newResults = appData.results.map(studentResults => {
				const newStudentResults = [];
				tasksWithIndex.forEach(item => {
					if (item.index < studentResults.length) {
						newStudentResults.push(studentResults[item.index]);
					}
				});
				return newStudentResults;
			});
			
			appData.results = newResults;
			
			saveData();
			renderAll();
			showNotification('?? Задания отсортированы по уровню сложности', 'success');
		}

		function clearAllTasks() {
			if (confirm('Удалить ВСЕ задания? Все результаты также будут удалены.')) {
				appData.tasks = [];
				appData.results = appData.results.map(() => []);
				saveData();
				renderAll();
				showNotification('??? Все задания удалены', 'info');
			}
		}		
		
        // Обновление задания
        function updateTask(index, field, value) {
            appData.tasks[index][field] = value;
            saveData();
            scheduleAutoSave();
        }

        // Функция для добавления нового задания
        function addTask() {
            const newTask = {
                type: `Новое задание ${appData.tasks.length + 1}`,
                maxScore: 1,
                level: 1,
                knowledge: "",
                number: appData.tasks.length + 1
            };
            
            if (appData.test.workType === 'vpr') {
                newTask.competence = 'calculations';
                newTask.vprLevel = 1;
            } else if (appData.test.workType === 'func_literacy') {
                newTask.literacyType = 'reading';
                newTask.skill = '';
                newTask.context = 'personal';
            } else if (appData.test.workType === 'oge' || appData.test.workType === 'ege') {
                newTask.kes = '';
                newTask.pu = '';
                newTask.answerType = 'short';
            }
            
            appData.tasks.push(newTask);
            
            appData.results.forEach(studentResults => {
                studentResults.push(0);
            });
            
            saveData();
            renderTasks();
            renderResults();
            showNotification(`Добавлено задание №${newTask.number}`, "success");
        }
		
		// Проверяем, что все необходимые функции определены
		function ensureFunctionsExist() {
			const requiredFunctions = [
				'selectClass',
				'addWholeClassToTestingFromCard',
				'showQRForClass',
				'deleteClass',
				'addSelectedToTesting',
				'addWholeClassToTesting',
				'toggleAllStudents',
				'addSingleStudent',
				'renderClassStudents',
				'importSchoolFile'
			];
			
			const missingFunctions = [];
			
			requiredFunctions.forEach(funcName => {
				if (typeof window[funcName] !== 'function') {
					missingFunctions.push(funcName);
				}
			});
			
			if (missingFunctions.length > 0) {
				console.error('Не найдены функции:', missingFunctions);
				showNotification(`Ошибка: отсутствуют функции: ${missingFunctions.join(', ')}`, 'error');
				return false;
			}
			
			return true;
		}

		// Вызывайте эту функцию при загрузке
		document.addEventListener('DOMContentLoaded', function() {
			if (ensureFunctionsExist()) {
				console.log('Все функции управления классами загружены');
			}
		});	

		// 1. Выбор класса
		window.selectClass = function(classId) {
			console.log('selectClass вызвана с classId:', classId);
			console.log('Доступные классы:', schoolData.classes.map(c => ({id: c.id, name: `${c.grade}${c.name}`})));
			
			const schoolClass = schoolData.classes.find(c => {
				console.log('Сравниваем:', c.id, 'с', classId, 'результат:', c.id === classId);
				return c.id === classId || c.id.toString() === classId.toString();
			});
			
			if (!schoolClass) {
				console.error('Класс не найден. Ищем по:', classId);
				console.error('Тип classId:', typeof classId);
				console.error('Все классы:', schoolData.classes);
				showNotification('Класс не найден', 'error');
				return;
			}
			
			const selector = document.getElementById('classSelector');
			if (selector) {
				selector.value = classId;
				console.log('Установлен класс в селекторе:', classId);
				
				if (typeof renderClassStudents === 'function') {
					renderClassStudents();
				}
			}
		};


		// 2. Добавление всего класса
		window.addWholeClassToTestingFromCard = function(classId) {
			console.log('addWholeClassToTestingFromCard вызвана с classId:', classId);
			console.log('Поиск класса в:', schoolData.classes.map(c => c.id));
			
			// Пробуем найти класс разными способами
			let schoolClass = schoolData.classes.find(c => c.id === classId);
			
			if (!schoolClass) {
				// Пробуем найти как строку
				schoolClass = schoolData.classes.find(c => c.id.toString() === classId.toString());
			}
			
			if (!schoolClass) {
				// Пробуем найти по числовому значению
				const classIdNum = parseFloat(classId);
				if (!isNaN(classIdNum)) {
					schoolClass = schoolData.classes.find(c => parseFloat(c.id) === classIdNum);
				}
			}
			
			if (!schoolClass) {
				console.error('Класс не найден после всех попыток:', classId);
				console.error('Тип classId:', typeof classId);
				console.error('Все классы:', schoolData.classes);
				showNotification('Класс не найден', 'error');
				return;
			}
			
			console.log('Класс найден:', schoolClass);
			
			if (confirm(`Добавить весь класс ${schoolClass.grade}${schoolClass.name} (${schoolClass.students.length} учеников) к тестированию?`)) {
				let addedCount = 0;
				
				schoolClass.students.forEach(student => {
					const studentExists = appData.students.some(s => {
						const existingName = s.toLowerCase();
						const newName = `${student.lastName} ${student.firstName}`.toLowerCase();
						return existingName.includes(newName) || newName.includes(existingName);
					});
					
					if (!studentExists) {
						appData.students.push(`${student.lastName} ${student.firstName} ${student.middleName || ''}`.trim());
						appData.results.push(new Array(appData.tasks.length).fill(0));
						addedCount++;
						console.log('Добавлен ученик:', student.lastName, student.firstName);
					}
				});
				
				if (addedCount > 0) {
					appData.test.presentStudents = appData.students.length;
					if (document.getElementById('presentStudents')) {
						document.getElementById('presentStudents').value = appData.students.length;
					}
					
					saveData();
					
					if (typeof renderStudents === 'function') {
						renderStudents();
					}
					if (typeof renderResults === 'function') {
						renderResults();
					}
					
					showNotification(`Добавлено ${addedCount} учеников из класса ${schoolClass.grade}${schoolClass.name}`, 'success');
					
					const currentClassId = document.getElementById('classSelector')?.value;
					if (currentClassId === classId && typeof renderClassStudents === 'function') {
						renderClassStudents();
					}
				} else {
					showNotification('Все ученики этого класса уже добавлены к тестированию', 'info');
				}
			}
		};

		// 3. Показ QR-кода
		window.showQRForClass = function(classId) {
			console.log('showQRForClass вызвана с classId:', classId);
			
			const schoolClass = schoolData.classes.find(c => c.id === classId);
			if (!schoolClass) {
				console.error('Класс не найден:', classId);
				showNotification('Класс не найден', 'error');
				return;
			}
			
			// Временно - показываем информацию о классе
			const studentList = schoolClass.students
				.map(s => `${s.lastName} ${s.firstName} ${s.middleName || ''}`.trim())
				.join('\n');
			
			const message = `Класс: ${schoolClass.grade}${schoolClass.name}\n` +
						   `Учеников: ${schoolClass.students.length}\n\n` +
						   `Список:\n${studentList}`;
			
			alert(message);
			showNotification(`Информация о классе ${schoolClass.grade}${schoolClass.name} показана`, 'info');
		};

		// 4. Удаление класса
		window.deleteClass = function(classId) {
			console.log('deleteClass вызвана с classId:', classId);
			
			const schoolClass = schoolData.classes.find(c => c.id === classId);
			if (!schoolClass) {
				console.error('Класс не найден:', classId);
				return;
			}
			
			if (confirm(`Удалить класс ${schoolClass.grade}${schoolClass.name}? Все данные об учениках будут удалены.`)) {
				const index = schoolData.classes.findIndex(c => c.id === classId);
				if (index !== -1) {
					schoolData.classes.splice(index, 1);
					localStorage.setItem('schoolData', JSON.stringify(schoolData));
					
					if (typeof renderClassManager === 'function') {
						renderClassManager();
						showNotification('Класс удален', 'success');
					} else {
						console.error('renderClassManager не найдена');
					}
				}
			}
		};
		
        // Функция для удаления задания
        function removeTask(taskIndex) {
            if (appData.tasks.length <= 1) {
                showNotification("Нельзя удалить последнее задание!", "error");
                return;
            }
            
            if (confirm(`Удалить задание №${taskIndex + 1}?`)) {
                appData.tasks.splice(taskIndex, 1);
                
                appData.tasks.forEach((task, index) => {
                    task.number = index + 1;
                });
                
                appData.results.forEach(studentResults => {
                    studentResults.splice(taskIndex, 1);
                });
                
                appData.errors = appData.errors.filter(error => error.taskIndex !== taskIndex);
                appData.errors.forEach(error => {
                    if (error.taskIndex > taskIndex) {
                        error.taskIndex--;
                    }
                });
                
                saveData();
                renderTasks();
                renderResults();
                showNotification("Задание удалено!", "success");
            }
        }

        function removeLastTask() {
            if (appData.tasks.length > 0) {
                removeTask(appData.tasks.length - 1);
            }
        }

        // Сохранение заданий
        function saveTasks() {
            saveData();
            showNotification("Задания сохранены!", "success");
        }

        // Рендер учащихся
		// Глобальные переменные для перетаскивания
		// Глобальные переменные для перетаскивания
		let dragStartIndex = null;
		let isDragging = false;

		// Функция для добавления минимальных стилей Bootstrap
		function addBootstrapMinimalStyles() {
			if (!document.getElementById('bootstrap-minimal-styles')) {
				const style = document.createElement('style');
				style.id = 'bootstrap-minimal-styles';
				style.textContent = `
					/* Основные стили для кнопок */
					.btn {
						display: inline-block;
						font-weight: 400;
						text-align: center;
						white-space: nowrap;
						vertical-align: middle;
						user-select: none;
						border: 1px solid transparent;
						padding: 0.375rem 0.75rem;
						font-size: 1rem;
						line-height: 1.5;
						border-radius: 0.25rem;
						transition: color 0.15s ease-in-out, background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
						cursor: pointer;
					}
					
					/* Размеры кнопок */
					.btn-sm {
						padding: 0.25rem 0.5rem;
						font-size: 0.875rem;
						line-height: 1.5;
						border-radius: 0.2rem;
					}
					
					/* Цвета кнопок */
					.btn-success {
						color: #fff;
						background-color: #28a745;
						border-color: #28a745;
					}
					
					.btn-danger {
						color: #fff;
						background-color: #dc3545;
						border-color: #dc3545;
					}
					
					.btn-primary {
						color: #fff;
						background-color: #007bff;
						border-color: #007bff;
					}
					
					.btn-info {
						color: #fff;
						background-color: #17a2b8;
						border-color: #17a2b8;
					}
					
					.btn-secondary {
						color: #fff;
						background-color: #6c757d;
						border-color: #6c757d;
					}
					
					.btn-warning {
						color: #212529;
						background-color: #ffc107;
						border-color: #ffc107;
					}
					
					/* Outline стили */
					.btn-outline-success {
						color: #28a745;
						background-color: transparent;
						background-image: none;
						border-color: #28a745;
					}
					
					.btn-outline-danger {
						color: #dc3545;
						background-color: transparent;
						background-image: none;
						border-color: #dc3545;
					}
					
					.btn-outline-primary {
						color: #007bff;
						background-color: transparent;
						background-image: none;
						border-color: #007bff;
					}
					
					.btn-outline-info {
						color: #17a2b8;
						background-color: transparent;
						background-image: none;
						border-color: #17a2b8;
					}
					
					.btn-outline-secondary {
						color: #6c757d;
						background-color: transparent;
						background-image: none;
						border-color: #6c757d;
					}
					
					.btn-outline-warning {
						color: #ffc107;
						background-color: transparent;
						background-image: none;
						border-color: #ffc107;
					}
					
					/* Hover эффекты */
					.btn:hover {
						color: #fff;
						text-decoration: none;
						opacity: 0.9;
					}
					
					.btn-outline-success:hover {
						color: #fff;
						background-color: #28a745;
						border-color: #28a745;
					}
					
					.btn-outline-danger:hover {
						color: #fff;
						background-color: #dc3545;
						border-color: #dc3545;
					}
					
					.btn-outline-primary:hover {
						color: #fff;
						background-color: #007bff;
						border-color: #007bff;
					}
					
					.btn-outline-info:hover {
						color: #fff;
						background-color: #17a2b8;
						border-color: #17a2b8;
					}
					
					.btn-outline-secondary:hover {
						color: #fff;
						background-color: #6c757d;
						border-color: #6c757d;
					}
					
					.btn-outline-warning:hover {
						color: #212529;
						background-color: #ffc107;
						border-color: #ffc107;
					}
					
					/* Disabled состояние */
					.btn:disabled,
					.btn.disabled {
						opacity: 0.65;
						cursor: not-allowed;
					}
					
					/* Группы кнопок */
					.btn-group {
						position: relative;
						display: inline-flex;
						vertical-align: middle;
					}
					
					.btn-group > .btn {
						position: relative;
						flex: 1 1 auto;
					}
					
					.btn-group > .btn:not(:last-child) {
						border-top-right-radius: 0;
						border-bottom-right-radius: 0;
					}
					
					.btn-group > .btn:not(:first-child) {
						border-top-left-radius: 0;
						border-bottom-left-radius: 0;
						margin-left: -1px;
					}
					
					/* Form controls */
					.form-control {
						display: block;
						width: 100%;
						padding: 0.375rem 0.75rem;
						font-size: 1rem;
						line-height: 1.5;
						color: #495057;
						background-color: #fff;
						background-clip: padding-box;
						border: 1px solid #ced4da;
						border-radius: 0.25rem;
						transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
					}
					
					.form-control-sm {
						padding: 0.25rem 0.5rem;
						font-size: 0.875rem;
						line-height: 1.5;
						border-radius: 0.2rem;
					}
					
					.form-control:focus {
						color: #495057;
						background-color: #fff;
						border-color: #80bdff;
						outline: 0;
						box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
					}
					
					/* Badge */
					.badge {
						display: inline-block;
						padding: 0.25em 0.4em;
						font-size: 75%;
						font-weight: 700;
						line-height: 1;
						text-align: center;
						white-space: nowrap;
						vertical-align: baseline;
						border-radius: 0.25rem;
					}
					
					.badge-success {
						color: #fff;
						background-color: #28a745;
					}
					
					.badge-warning {
						color: #212529;
						background-color: #ffc107;
					}
					
					.badge-secondary {
						color: #fff;
						background-color: #6c757d;
					}
					
					.badge-info {
						color: #fff;
						background-color: #17a2b8;
					}
					
					.badge-light {
						color: #212529;
						background-color: #f8f9fa;
					}
					
					/* Progress bar */
					.progress {
						display: flex;
						height: 1rem;
						overflow: hidden;
						font-size: 0.75rem;
						background-color: #e9ecef;
						border-radius: 0.25rem;
					}
					
					.progress-bar {
						display: flex;
						flex-direction: column;
						justify-content: center;
						color: #fff;
						text-align: center;
						white-space: nowrap;
						background-color: #007bff;
						transition: width 0.6s ease;
					}
					
					.bg-success {
						background-color: #28a745 !important;
					}
					
					.bg-warning {
						background-color: #ffc107 !important;
					}
					
					.bg-secondary {
						background-color: #6c757d !important;
					}
					
					.bg-info {
						background-color: #17a2b8 !important;
					}
					
					.bg-light {
						background-color: #f8f9fa !important;
					}
					
					/* Text colors */
					.text-white {
						color: #fff !important;
					}
					
					.text-muted {
						color: #6c757d !important;
					}
					
					/* Spacing utilities */
					.mb-0 { margin-bottom: 0 !important; }
					.mb-2 { margin-bottom: 0.5rem !important; }
					.mb-3 { margin-bottom: 1rem !important; }
					.mb-4 { margin-bottom: 1.5rem !important; }
					.mt-2 { margin-top: 0.5rem !important; }
					.mr-2 { margin-right: 0.5rem !important; }
					
					/* Flex utilities */
					.d-flex { display: flex !important; }
					.flex-wrap { flex-wrap: wrap !important; }
					.justify-content-between { justify-content: space-between !important; }
					.align-items-center { align-items: center !important; }
					.align-middle { vertical-align: middle !important; }
					
					/* Small text */
					.small { font-size: 80%; }
					
					/* Responsive */
					@media (max-width: 768px) {
						.d-sm-flex { display: flex !important; }
						.flex-sm-wrap { flex-wrap: wrap !important; }
					}
				`;
				document.head.appendChild(style);
			}
		}

		// Функция переключения режимов
		let isClassManagerView = false;

		function toggleViewMode() {
			isClassManagerView = !isClassManagerView;
			
			const studentsContainer = document.getElementById('studentsContainer');
			const classManagerContainer = document.getElementById('classManagerContainer');
			const viewModeText = document.getElementById('viewModeText');
			
			if (isClassManagerView) {
				studentsContainer.style.display = 'none';
				classManagerContainer.style.display = 'block';
				viewModeText.textContent = 'Перейти к списку тестируемых';
				
				// Загружаем данные школы
				loadSchoolData();
				
				// Рендерим менеджер классов
				renderClassManager();
				
				// Добавляем обработчики после рендеринга
				setTimeout(() => {
					const classesGrid = document.getElementById('classesGrid');
					if (classesGrid) {
						classesGrid.addEventListener('click', handleClassAction);
					}
				}, 100);
				
			} else {
				studentsContainer.style.display = 'block';
				classManagerContainer.style.display = 'none';
				viewModeText.textContent = 'Перейти к управлению классами';
				renderStudents();
			}
		}
		
		function renderStudents() {
			const container = document.getElementById('studentsContainer');
			container.innerHTML = '';
			
			// Если нет студентов, создаем дефолтных
			if (appData.students.length === 0) {
				for (let i = 0; i < appData.test.presentStudents; i++) {
					appData.students.push(`Учащийся ${i + 1}`);
					appData.results.push(new Array(appData.tasks.length).fill(0));
				}
			}
			
			// Основные контролы
			const controlsDiv = document.createElement('div');
			controlsDiv.style.cssText = `
				background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
				color: white;
				padding: 20px;
				border-radius: 12px;
				margin-bottom: 20px;
				box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
			`;

			controlsDiv.innerHTML = `
				<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
					<h4 style="color: white; margin: 0;">
						<span style="margin-right: 10px;">??</span> Управление списком учащихся
					</h4>
					<span style="background: rgba(255,255,255,0.2); color: white; font-size: 14px; padding: 4px 8px; border-radius: 12px;">
						${appData.students.length} учащихся
					</span>					
				</div>
				
				<div style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 15px; align-items: center;">
					<div style="display: flex; gap: 5px;">
						<button class="btn btn-success" onclick="addStudent()" title="Добавить нового учащегося" style="display: flex; align-items: center; gap: 5px;">
							<span>?</span> Добавить
						</button>
						<button class="btn btn-outline-success" onclick="addMultipleStudents(5)" style="display: flex; align-items: center; gap: 5px; color: white; border-color: white;">
							<span>??</span> +5
						</button>
					</div>
					
					<div style="display: flex; gap: 5px;">
						<button class="btn btn-danger" onclick="removeLastStudent()" title="Удалить последнего учащегося" style="display: flex; align-items: center; gap: 5px;">
							<span>?</span> Удалить
						</button>
						<button class="btn btn-outline-danger" onclick="clearStudents()" style="display: flex; align-items: center; gap: 5px; color: white; border-color: white;">
							<span>???</span> Очистить
						</button>
					</div>
					
					<button class="btn btn-primary" onclick="showQuickSetDialog()" style="display: flex; align-items: center; gap: 5px;">
						<span>??</span> Задать количество
					</button>
					
					<button class="btn btn-info" onclick="showMassImportDialog()" style="display: flex; align-items: center; gap: 5px;">
						<span>??</span> Импорт списка
					</button>
					
					<button class="btn btn-secondary" onclick="exportStudentsList()" title="Экспорт списка в CSV" style="display: flex; align-items: center; gap: 5px;">
						<span>??</span> Экспорт
					</button>
					
					<div style="position: relative; flex-grow: 1; max-width: 300px;">
						<input type="text" id="studentSearch" placeholder="Поиск учащихся..." 
							   oninput="filterStudents()" class="form-control" style="padding-left: 35px;">
						<span style="position: absolute; left: 12px; top: 50%; transform: translateY(-50%); color: #999;">??</span>
					</div>
				</div>
				
				<div>
					<small style="color: rgba(255,255,255,0.8);">
						<span>??</span> 
						Перетаскивайте строки для изменения порядка. 
						${appData.test.totalStudents ? `Всего по списку: ${appData.test.totalStudents}` : ''}
					</small>
				</div>
			`;
			container.appendChild(controlsDiv);
			
			// Таблица студентов
			const tableWrapper = document.createElement('div');
			tableWrapper.className = 'students-table-wrapper';
			tableWrapper.style.cssText = 'background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); overflow: hidden; margin-bottom: 20px;';
			
			const table = document.createElement('table');
			table.className = 'students-table';
			table.id = 'studentsTable';
			table.style.cssText = 'width: 100%; border-collapse: collapse;';
			
			// Заголовок таблицы
			const thead = document.createElement('thead');
			thead.innerHTML = `
				<tr style="background: #f8f9fa;">
					<th style="width: 40px; padding: 12px 15px; text-align: left; font-weight: 600; color: #495057; border-bottom: 2px solid #dee2e6;">№</th>
					<th style="width: 50px; padding: 12px 15px; text-align: left; font-weight: 600; color: #495057; border-bottom: 2px solid #dee2e6;"></th>
					<th style="padding: 12px 15px; text-align: left; font-weight: 600; color: #495057; border-bottom: 2px solid #dee2e6;">ФИО учащегося</th>
					<th style="width: 100px; padding: 12px 15px; text-align: left; font-weight: 600; color: #495057; border-bottom: 2px solid #dee2e6;">Статус</th>
					<th style="width: 200px; padding: 12px 15px; text-align: left; font-weight: 600; color: #495057; border-bottom: 2px solid #dee2e6;">Действия</th>
				</tr>
			`;
			table.appendChild(thead);
			
			// Тело таблицы
			const tbody = document.createElement('tbody');
			tbody.id = 'studentsTableBody';
			
			appData.students.forEach((student, index) => {
				const row = document.createElement('tr');
				row.id = `student-row-${index}`;
				row.draggable = true;
				row.dataset.index = index;
				row.style.cssText = 'transition: background-color 0.2s;';
				
				// Добавляем обработчики для перетаскивания
				row.addEventListener('dragstart', handleDragStart);
				row.addEventListener('dragover', handleDragOver);
				row.addEventListener('drop', handleDrop);
				row.addEventListener('dragend', handleDragEnd);
				
				// Вычисляем прогресс студента
				const studentResults = appData.results[index] || [];
				const completedTasks = studentResults.filter(score => score > 0).length;
				const totalTasks = appData.tasks.length;
				const progressPercentage = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0;
				
				row.innerHTML = `
					<td style="text-align: center; padding: 12px 15px; border-bottom: 1px solid #e9ecef;">
						<span style="font-weight: 600; color: #495057;">${index + 1}</span>
					</td>
					<td class="drag-handle" title="Перетащите для изменения порядка" style="cursor: grab; color: #adb5bd; text-align: center; padding: 12px 15px; border-bottom: 1px solid #e9ecef; user-select: none;">
						<span>¦?</span>
					</td>
					<td style="padding: 12px 15px; border-bottom: 1px solid #e9ecef;">
						<div style="display: flex; flex-direction: column; gap: 5px;">
							<input type="text" 
								   value="${student}" 
								   class="form-control form-control-sm"
								   data-index="${index}"
								   onchange="updateStudent(${index}, this.value)"
								   placeholder="Введите ФИО"
								   style="border: 1px solid #ced4da; transition: all 0.3s;">
							<div style="display: flex; align-items: center; gap: 10px; font-size: 12px;">
								<div style="flex-grow: 1; height: 6px; background: #e9ecef; border-radius: 3px; overflow: hidden;">
									<div style="height: 100%; background: linear-gradient(90deg, #28a745, #20c997); width: ${progressPercentage}%; transition: width 0.3s;"></div>
								</div>
								<small>${completedTasks}/${totalTasks}</small>
							</div>
						</div>
					</td>
					<td style="padding: 12px 15px; border-bottom: 1px solid #e9ecef;">
						<span style="display: inline-block; padding: 3px 8px; border-radius: 12px; font-size: 12px; font-weight: 600; background: ${progressPercentage === 100 ? '#d4edda' : progressPercentage > 0 ? '#fff3cd' : '#e9ecef'}; color: ${progressPercentage === 100 ? '#155724' : progressPercentage > 0 ? '#856404' : '#495057'}">
							${progressPercentage === 100 ? 'Выполнено' : progressPercentage > 0 ? 'Частично' : 'Нет данных'}
						</span>
					</td>
					<td style="padding: 12px 15px; border-bottom: 1px solid #e9ecef;">
						<div style="display: flex; gap: 5px; flex-wrap: nowrap;">
							<button class="btn btn-sm" onclick="duplicateStudent(${index})" title="Дублировать" style="padding: 2px 8px; font-size: 12px; background: #e7f5ff; color: #0066cc; border: 1px solid #b3d7ff;">
								<span>??</span>
							</button>
							<button class="btn btn-sm" onclick="editStudentInModal(${index})" title="Редактировать" style="padding: 2px 8px; font-size: 12px; background: #fff8e6; color: #cc8800; border: 1px solid #ffdd99;">
								<span>??</span>
							</button>
							<button class="btn btn-sm" onclick="removeStudent(${index})" title="Удалить" style="padding: 2px 8px; font-size: 12px; background: #ffe6e6; color: #cc0000; border: 1px solid #ff9999;">
								<span>???</span>
							</button>
							<button class="btn btn-sm" onclick="moveStudentUp(${index})" ${index === 0 ? 'disabled' : ''} title="Переместить вверх" style="padding: 2px 8px; font-size: 12px; background: #f8f9fa; color: #6c757d; border: 1px solid #dee2e6; ${index === 0 ? 'opacity: 0.5; cursor: not-allowed;' : ''}">
								<span>??</span>
							</button>
							<button class="btn btn-sm" onclick="moveStudentDown(${index})" ${index === appData.students.length - 1 ? 'disabled' : ''} title="Переместить вниз" style="padding: 2px 8px; font-size: 12px; background: #f8f9fa; color: #6c757d; border: 1px solid #dee2e6; ${index === appData.students.length - 1 ? 'opacity: 0.5; cursor: not-allowed;' : ''}">
								<span>??</span>
							</button>
						</div>
					</td>
				`;
				
				row.addEventListener('mouseenter', () => {
					row.style.backgroundColor = '#f8f9fa';
				});
				row.addEventListener('mouseleave', () => {
					row.style.backgroundColor = '';
				});
				
				tbody.appendChild(row);
			});
			
			table.appendChild(tbody);
			tableWrapper.appendChild(table);
			container.appendChild(tableWrapper);
			
			// Пагинация (если много студентов)
			if (appData.students.length > 20) {
				const paginationDiv = document.createElement('div');
				paginationDiv.style.cssText = 'text-align: center; padding: 10px; color: #6c757d; font-size: 14px;';
				paginationDiv.innerHTML = `
					<small>
						Показано ${appData.students.length} учащихся. 
						Используйте поиск для фильтрации.
					</small>
				`;
				container.appendChild(paginationDiv);
			}
			
			// Быстрые действия
			const quickActionsDiv = document.createElement('div');
			quickActionsDiv.style.cssText = 'background: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px solid #dee2e6;';
			quickActionsDiv.innerHTML = `
				<div style="margin-bottom: 10px;">
					<h6 style="margin: 0;"><span style="margin-right: 8px;">?</span> Быстрые действия</h6>
				</div>
				<div style="display: flex; flex-wrap: wrap; gap: 10px;">
					<button class="btn btn-outline-success btn-sm" onclick="generateDefaultNames()" style="display: flex; align-items: center; gap: 5px;">
						<span>??</span> Сгенерировать имена
					</button>
					<button class="btn btn-outline-warning btn-sm" onclick="sortStudentsAlphabetically()" style="display: flex; align-items: center; gap: 5px;">
						<span>??</span> Сортировать по алфавиту
					</button>
					<button class="btn btn-outline-info btn-sm" onclick="randomizeOrder()" style="display: flex; align-items: center; gap: 5px;">
						<span>??</span> Перемешать
					</button>
					<button class="btn btn-outline-secondary btn-sm" onclick="saveStudents()" style="display: flex; align-items: center; gap: 5px;">
						<span>??</span> Сохранить список
					</button>
				</div>
			`;
			container.appendChild(quickActionsDiv);
		}
		
		// ПЕРЕМЕСТИТЕ ЭТИ ФУНКЦИИ В НАЧАЛО ФАЙЛА, перед renderClassManager()

		// ==================== ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ДЛЯ КЛАССОВ ====================

		// Выбор класса из списка
		function selectClass(classId) {
			const selector = document.getElementById('classSelector');
			if (selector) {
				selector.value = classId;
				renderClassStudents();
			}
		}

		// Добавление всего класса по ID
		function addWholeClassToTestingFromCard(classId) {
			const schoolClass = schoolData.classes.find(c => c.id === classId);
			if (!schoolClass) return;
			
			if (!confirm(`Добавить весь класс ${schoolClass.grade}${schoolClass.name} (${schoolClass.students.length} учеников) к тестированию?`)) {
				return;
			}
			
			let addedCount = 0;
			schoolClass.students.forEach(student => {
				if (!appData.students.some(s => 
					s.includes(student.lastName) && s.includes(student.firstName))) {
					
					appData.students.push(`${student.lastName} ${student.firstName} ${student.middleName || ''}`.trim());
					appData.results.push(new Array(appData.tasks.length).fill(0));
					addedCount++;
				}
			});
			
			if (addedCount > 0) {
				appData.test.presentStudents = appData.students.length;
				if (document.getElementById('presentStudents')) {
					document.getElementById('presentStudents').value = appData.students.length;
				}
				
				saveData();
				renderStudents();
				renderResults();
				
				showNotification(`Добавлено ${addedCount} учеников из класса ${schoolClass.grade}${schoolClass.name}`, 'success');
				
				if (document.getElementById('classSelector').value === classId) {
					renderClassStudents();
				}
			} else {
				showNotification('Все ученики этого класса уже добавлены к тестированию', 'info');
			}
		}

		// Показ QR-кода для класса
		function showQRForClass(classId) {
			const schoolClass = schoolData.classes.find(c => c.id === classId);
			if (!schoolClass) return;
			
			// Создаем уникальную ссылку для класса
			const classData = {
				classId: schoolClass.id,
				className: `${schoolClass.grade}${schoolClass.name}`,
				students: schoolClass.students.map(s => ({
					lastName: s.lastName,
					firstName: s.firstName,
					middleName: s.middleName
				})),
				timestamp: new Date().toISOString()
			};
			
			const dataStr = JSON.stringify(classData);
			const dataUrl = `data:application/json;charset=utf-8,${encodeURIComponent(dataStr)}`;
			
			// Создаем модальное окно с QR-кодом
			const modal = document.createElement('div');
			modal.className = 'modal fade';
			modal.id = 'qrModal';
			modal.innerHTML = `
				<div class="modal-dialog modal-dialog-centered">
					<div class="modal-content">
						<div class="modal-header">
							<h5 class="modal-title">QR-код класса ${schoolClass.grade}${schoolClass.name}</h5>
							<button type="button" class="btn-close" data-bs-dismiss="modal"></button>
						</div>
						<div class="modal-body text-center">
							<div id="qrCodeContainer" class="mb-3"></div>
							<p class="text-muted small">
								Отсканируйте QR-код для быстрого импорта данных класса
							</p>
							<div class="d-grid gap-2">
								<button class="btn btn-outline-primary" onclick="downloadQRCode()">
									<i class="fas fa-download me-2"></i>Скачать QR-код
								</button>
								<button class="btn btn-outline-secondary" onclick="shareClassData('${classId}')">
									<i class="fas fa-share-alt me-2"></i>Поделиться
								</button>
							</div>
						</div>
					</div>
				</div>
			`;
			
			document.body.appendChild(modal);
			
			// Инициализируем модальное окно Bootstrap
			const modalInstance = new bootstrap.Modal(modal);
			modalInstance.show();
			
			// Генерируем QR-код после отображения модального окна
			setTimeout(() => {
				if (typeof QRCode !== 'undefined') {
					QRCode.toCanvas(document.getElementById('qrCodeContainer'), dataUrl, {
						width: 200,
						margin: 2,
						color: {
							dark: '#000000',
							light: '#FFFFFF'
						}
					}, function(error) {
						if (error) {
							console.error('Ошибка генерации QR-кода:', error);
							showNotification('Ошибка генерации QR-кода', 'error');
						}
					});
				} else {
					document.getElementById('qrCodeContainer').innerHTML = `
						<div class="alert alert-warning">
							<i class="fas fa-exclamation-triangle me-2"></i>
							Библиотека QR-кодов не загружена
						</div>
					`;
				}
			}, 100);
			
			// Удаляем модальное окно после закрытия
			modal.addEventListener('hidden.bs.modal', function() {
				modal.remove();
			});
		}

		// Удаление класса
		function deleteClass(classId) {
			if (!confirm('Удалить этот класс? Все данные об учениках будут удалены.')) {
				return;
			}
			
			const index = schoolData.classes.findIndex(c => c.id === classId);
			if (index !== -1) {
				schoolData.classes.splice(index, 1);
				localStorage.setItem('schoolData', JSON.stringify(schoolData));
				
				// Перерисовываем интерфейс
				if (typeof renderClassManager === 'function') {
					renderClassManager();
				}
				
				showNotification('Класс удален', 'success');
			}
		}

		// Добавление выбранных студентов к тестированию
		function addSelectedToTesting() {
			const classId = document.getElementById('classSelector').value;
			const schoolClass = schoolData.classes.find(c => c.id === classId);
			if (!schoolClass) return;
			
			const selectedStudents = Array.from(document.querySelectorAll('.student-checkbox:checked'))
				.map(cb => cb.value);
			
			if (selectedStudents.length === 0) {
				showNotification('Выберите хотя бы одного ученика!', 'warning');
				return;
			}
			
			let addedCount = 0;
			selectedStudents.forEach(studentId => {
				const student = schoolClass.students.find(s => s.id === studentId);
				if (student && !appData.students.some(s => 
					s.includes(student.lastName) && s.includes(student.firstName))) {
					
					// Добавляем в appData
					appData.students.push(`${student.lastName} ${student.firstName} ${student.middleName || ''}`.trim());
					appData.results.push(new Array(appData.tasks.length).fill(0));
					addedCount++;
				}
			});
			
			if (addedCount > 0) {
				// Обновляем счетчик присутствующих
				appData.test.presentStudents = appData.students.length;
				if (document.getElementById('presentStudents')) {
					document.getElementById('presentStudents').value = appData.students.length;
				}
				
				saveData();
				
				if (typeof renderStudents === 'function') {
					renderStudents();
				}
				if (typeof renderResults === 'function') {
					renderResults();
				}
				
				showNotification(`Добавлено ${addedCount} учеников к тестированию`, 'success');
				
				// Обновляем список студентов класса
				if (typeof renderClassStudents === 'function') {
					renderClassStudents();
				}
			}
		}

		// Добавление всего класса
		function addWholeClassToTesting() {
			const classId = document.getElementById('classSelector').value;
			if (classId) {
				addWholeClassToTestingFromCard(classId);
			}
		}

		// Переключение всех студентов
		function toggleAllStudents(checked) {
			document.querySelectorAll('.student-checkbox:not(:disabled)').forEach(checkbox => {
				checkbox.checked = checked;
			});
		}

		// Добавление одного студента
		function addSingleStudent(studentId) {
			const classId = document.getElementById('classSelector').value;
			const schoolClass = schoolData.classes.find(c => c.id === classId);
			if (!schoolClass) return;
			
			const student = schoolClass.students.find(s => s.id === studentId);
			if (!student) return;
			
			// Проверяем, не добавлен ли уже
			if (appData.students.some(s => 
				s.includes(student.lastName) && s.includes(student.firstName))) {
				showNotification('Этот ученик уже добавлен к тестированию', 'warning');
				return;
			}
			
			appData.students.push(`${student.lastName} ${student.firstName} ${student.middleName || ''}`.trim());
			appData.results.push(new Array(appData.tasks.length).fill(0));
			
			appData.test.presentStudents = appData.students.length;
			if (document.getElementById('presentStudents')) {
				document.getElementById('presentStudents').value = appData.students.length;
			}
			
			saveData();
			
			if (typeof renderStudents === 'function') {
				renderStudents();
			}
			if (typeof renderResults === 'function') {
				renderResults();
			}
			
			showNotification(`Ученик ${student.lastName} ${student.firstName} добавлен`, 'success');
			
			if (typeof renderClassStudents === 'function') {
				renderClassStudents();
			}
		}

		// Скачивание QR-кода
		function downloadQRCode() {
			const canvas = document.querySelector('#qrModal canvas');
			if (!canvas) return;
			
			const link = document.createElement('a');
			link.download = `qr-code-класс-${new Date().toISOString().slice(0, 10)}.png`;
			link.href = canvas.toDataURL('image/png');
			document.body.appendChild(link);
			link.click();
			document.body.removeChild(link);
			
			showNotification('QR-код скачан', 'success');
		}

		// Поделиться данными класса
		function shareClassData(classId) {
			const schoolClass = schoolData.classes.find(c => c.id === classId);
			if (!schoolClass) return;
			
			const shareText = `Класс: ${schoolClass.grade}${schoolClass.name}\n` +
							 `Учеников: ${schoolClass.students.length}\n` +
							 `Список учеников:\n` +
							 schoolClass.students.map(s => 
								 `- ${s.lastName} ${s.firstName} ${s.middleName || ''}`
							 ).join('\n');
			
			if (navigator.share) {
				navigator.share({
					title: `Класс ${schoolClass.grade}${schoolClass.name}`,
					text: shareText,
					url: window.location.href
				}).catch(console.error);
			} else {
				// Копируем в буфер обмена
				navigator.clipboard.writeText(shareText)
					.then(() => showNotification('Список класса скопирован в буфер обмена', 'success'))
					.catch(() => {
						// Fallback для старых браузеров
						const textarea = document.createElement('textarea');
						textarea.value = shareText;
						document.body.appendChild(textarea);
						textarea.select();
						document.execCommand('copy');
						document.body.removeChild(textarea);
						showNotification('Список класса скопирован в буфер обмена', 'success');
					});
			}
		}		
		
		// тут добавил
		document.addEventListener('DOMContentLoaded', function() {
			console.log('DOM загружен, проверяем зависимости...');
			
			// Небольшая задержка для гарантии загрузки всех скриптов
			setTimeout(function() {
				console.log('Начинаем проверку зависимостей...');
				
				// ПРОВЕРКА BOOTSTRAP
				console.log('Проверяем Bootstrap...');
				console.log('window.bootstrap:', window.bootstrap);
				
				if (typeof bootstrap === 'undefined') {
					console.error('? Bootstrap не загружен!');
					
					// Дополнительная диагностика
					console.log('Проверяем jQuery (если используется):', typeof $ === 'undefined' ? 'Не загружен' : 'Загружен');
					console.log('Проверяем Popper:', typeof Popper === 'undefined' ? 'Не загружен' : 'Загружен');
					
					// Проверяем, есть ли в DOM элементы Bootstrap
					const bootstrapElements = document.querySelectorAll('[data-bs-toggle]');
					console.log(`Найдено элементов с data-bs-toggle: ${bootstrapElements.length}`);
					
					// Показываем уведомление об ошибке
					const errorMessage = 'Bootstrap не загружен. Некоторые функции могут работать некорректно. ' +
									   'Пожалуйста, проверьте подключение к интернету и перезагрузите страницу.';
					showNotification(errorMessage, 'error');
					
					// Можно добавить кнопку для принудительной перезагрузки
					const reloadBtn = document.createElement('button');
					reloadBtn.className = 'btn btn-sm btn-warning ms-2';
					reloadBtn.textContent = 'Перезагрузить';
					reloadBtn.onclick = function() {
						location.reload();
					};
					
					// Добавляем кнопку перезагрузки в уведомление (после его создания)
					setTimeout(() => {
						const alert = document.querySelector('.alert-danger .btn-close');
						if (alert && alert.parentNode) {
							alert.parentNode.insertBefore(reloadBtn, alert);
						}
					}, 100);
					
				} else {
					console.log('? Bootstrap успешно загружен');
					console.log('Доступные компоненты Bootstrap:', Object.keys(bootstrap).filter(key => key !== '__proto__'));
					
					// Проверяем основные компоненты Bootstrap
					const components = ['Modal', 'Dropdown', 'Tooltip', 'Popover', 'Toast', 'Alert'];
					components.forEach(comp => {
						if (bootstrap[comp]) {
							console.log(`? Bootstrap ${comp} доступен`);
						} else {
							console.warn(`?? Bootstrap ${comp} недоступен`);
						}
					});
				}
				
				// ПРОВЕРКА XLSX
				console.log('\nПроверяем библиотеку XLSX...');
				if (typeof XLSX === 'undefined') {
					console.warn('?? Библиотека XLSX не загружена - импорт/экспорт Excel будет недоступен');
					showNotification('Функции работы с Excel недоступны', 'warning');
				} else {
					console.log('? Библиотека XLSX успешно загружена');
					console.log('Версия XLSX:', XLSX.version || 'неизвестна');
				}
				
				// ПРОВЕРКА QRCode
				console.log('\nПроверяем библиотеку QRCode...');
				if (typeof QRCode === 'undefined') {
					console.warn('?? Библиотека QRCode не загружена - генерация QR-кодов будет недоступна');
					showNotification('Генерация QR-кодов недоступна', 'warning');
				} else {
					console.log('? Библиотека QRCode успешно загружена');
				}
				
				// ПРОВЕРКА ДРУГИХ ВОЗМОЖНЫХ ЗАВИСИМОСТЕЙ
				console.log('\nДополнительные проверки:');
				
				// Проверка jQuery (если используется)
				if (typeof $ !== 'undefined') {
					console.log('? jQuery загружен, версия:', $.fn.jquery);
				}
				
				// Проверка Popper.js (если используется отдельно)
				if (typeof Popper !== 'undefined') {
					console.log('? Popper.js загружен');
				}
				
				// Проверка поддержки localStorage
				try {
					localStorage.setItem('test', 'test');
					localStorage.removeItem('test');
					console.log('? localStorage доступен');
				} catch (e) {
					console.warn('?? localStorage недоступен:', e.message);
					showNotification('Локальное хранилище недоступно. Возможно, у вас включен режим инкогнито или отключены cookies.', 'warning');
				}
				
				// Проверка поддержки fetch
				if (typeof fetch === 'undefined') {
					console.warn('?? Fetch API недоступен');
					showNotification('Некоторые функции могут не работать в вашем браузере', 'warning');
				} else {
					console.log('? Fetch API доступен');
				}
				
				// Сводка проверок
				console.log('\n======= СВОДКА ПРОВЕРОК =======');
				const checks = {
					'Bootstrap': typeof bootstrap !== 'undefined',
					'XLSX': typeof XLSX !== 'undefined',
					'QRCode': typeof QRCode !== 'undefined',
					'localStorage': (() => {
						try {
							localStorage.setItem('test', 'test');
							localStorage.removeItem('test');
							return true;
						} catch {
							return false;
						}
					})(),
					'Fetch API': typeof fetch !== 'undefined'
				};
				
				Object.entries(checks).forEach(([name, status]) => {
					console.log(`${status ? '?' : '?'} ${name}: ${status ? 'ОК' : 'НЕ ЗАГРУЖЕНО'}`);
				});
				
				console.log('=============================\n');
				
				// Если Bootstrap загружен, инициализируем компоненты, которые требуют JS
				if (typeof bootstrap !== 'undefined') {
					// Инициализация всех тултипов
					const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
					tooltipTriggerList.map(function (tooltipTriggerEl) {
						return new bootstrap.Tooltip(tooltipTriggerEl);
					});
					
					// Инициализация всех попапов
					const popoverTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="popover"]'));
					popoverTriggerList.map(function (popoverTriggerEl) {
						return new bootstrap.Popover(popoverTriggerEl);
					});
					
					console.log('? Компоненты Bootstrap инициализированы');
				}
				
				// Загружаем данные школы только если Bootstrap загружен
				if (typeof bootstrap !== 'undefined') {
					loadSchoolData();
				} else {
					console.error('? Невозможно загрузить данные школы: Bootstrap не загружен');
					showNotification('Невозможно загрузить данные без Bootstrap', 'error');
				}
				
			}, 100); // Задержка 100мс для гарантии загрузки всех скриптов
		});

		// Добавляем глобальный обработчик ошибок для отслеживания проблем с загрузкой
		window.addEventListener('error', function(e) {
			// Фильтруем ошибки связанные с загрузкой скриптов
			if (e.target && (e.target.tagName === 'SCRIPT' || e.target.tagName === 'LINK')) {
				console.error('? Ошибка загрузки ресурса:', e.target.src || e.target.href);
				
				// Проверяем, не связана ли ошибка с Bootstrap
				const src = e.target.src || e.target.href || '';
				if (src.includes('bootstrap')) {
					showNotification(`Ошибка загрузки Bootstrap: ${e.message}`, 'error');
				}
			}
		});

		// Также отслеживаем ошибки промисов
		window.addEventListener('unhandledrejection', function(event) {
			console.error('? Необработанная ошибка промиса:', event.reason);
		});

		console.log('Скрипт проверки зависимостей загружен');	

		// Добавьте этот код в начало файла для отладки
		function debugClassActions() {
			console.log('=== ДЕБАГ ИНФОРМАЦИЯ ===');
			console.log('1. Проверка функций в window:');
			console.log('- selectClass:', typeof window.selectClass);
			console.log('- addWholeClassToTestingFromCard:', typeof window.addWholeClassToTestingFromCard);
			console.log('- showQRForClass:', typeof window.showQRForClass);
			console.log('- deleteClass:', typeof window.deleteClass);
			
			console.log('2. Данные классов:');
			console.log('Всего классов:', schoolData.classes.length);
			schoolData.classes.forEach((cls, i) => {
				console.log(`Класс ${i}: ${cls.grade}${cls.name}, ID: ${cls.id}, Учеников: ${cls.students.length}`);
			});
			
			console.log('3. Проверка HTML элементов:');
			setTimeout(() => {
				const buttons = document.querySelectorAll('.btn-group .btn');
				console.log('Найдено кнопок в группах:', buttons.length);
				buttons.forEach((btn, i) => {
					console.log(`Кнопка ${i}:`, {
						onclick: btn.getAttribute('onclick'),
						html: btn.innerHTML,
						parent: btn.parentElement?.parentElement?.parentElement?.querySelector('h6')?.textContent
					});
				});
			}, 1000);
		}		
		
		// классы
		function renderClassManager() {
			setTimeout(debugClassActions, 500);
			const container = document.getElementById('classManagerContainer');
			if (!container) return;
			
			container.innerHTML = '';
			
			const classesCount = schoolData.classes.length;
			
			// Основной интерфейс управления классами
			const mainCard = document.createElement('div');
			mainCard.className = 'class-manager-container';
			mainCard.innerHTML = `
				<div class="dashboard-header mb-4">
					<div class="row">
						<div class="col-lg-8">
							<div class="d-flex align-items-center">
								<div class="dashboard-icon me-3">
									<i class="fas fa-school fa-2x text-primary"></i>
								</div>
								<div>
									<h1 class="h3 mb-1">Управление классами</h1>
									<p class="text-muted mb-0">Импорт данных, управление учениками и классами</p>
								</div>
							</div>
						</div>
						<div class="col-lg-4">
							<div class="stats-card card border-0 bg-primary text-white h-100">
								<div class="card-body py-3">
									<div class="d-flex justify-content-between align-items-center">
										<div>
											<div class="small opacity-75">Всего классов</div>
											<div class="h2 mb-0">${classesCount}</div>
										</div>
										<i class="fas fa-chalkboard fa-2x opacity-50"></i>
									</div>
								</div>
							</div>
						</div>
					</div>
				</div>
				
				<div class="row">
					<div class="col-xl-8">
						<!-- Блок импорта -->
						<div class="card border-0 shadow-sm mb-4">
							<div class="card-header bg-white border-0 py-3">
								<h5 class="mb-0"><i class="fas fa-file-import text-primary me-2"></i>Импорт данных школы</h5>
							</div>
							<div class="card-body">
								<div class="row">
									<div class="col-md-6 mb-4">
										<div class="mb-3">
											<label class="form-label fw-medium">Название школы</label>
											<div class="input-group">
												<span class="input-group-text">
													<i class="fas fa-university"></i>
												</span>
												<input type="text" id="schoolName" class="form-control form-control-lg" 
													   value="${schoolData.schoolName || ''}" 
													   placeholder="Введите название школы">
											</div>
										</div>
										
										${schoolData.lastImportDate ? `
											<div class="alert alert-light border mb-4">
												<div class="d-flex align-items-center">
													<i class="fas fa-clock text-info me-3 fa-lg"></i>
													<div>
														<div class="fw-medium">Последний импорт</div>
														<div class="text-muted">
															${new Date(schoolData.lastImportDate).toLocaleDateString('ru-RU', {
																day: 'numeric',
																month: 'long',
																year: 'numeric',
																hour: '2-digit',
																minute: '2-digit'
															})}
														</div>
													</div>
												</div>
											</div>
										` : ''}
									</div>
									
									<div class="col-md-6 mb-4">
										<div class="import-card card border-dashed h-100">
											<div class="card-body d-flex flex-column align-items-center justify-content-center py-4">
												<div class="import-icon mb-3">
													<i class="fas fa-cloud-upload-alt fa-3x text-muted"></i>
												</div>
												<h5 class="mb-2">Загрузите файл</h5>
												<p class="text-muted text-center small mb-3">
													Перетащите файл или нажмите для загрузки
												</p>
												
												<div class="file-upload-area w-100">
													<input type="file" id="schoolFileInput" class="d-none" 
														   accept=".xlsx,.xls,.csv,.txt,.json">
													<label for="schoolFileInput" class="btn btn-outline-primary w-100 mb-3">
														<i class="fas fa-folder-open me-2"></i>Выбрать файл
													</label>
													
													<select id="fileFormat" class="form-select">
														<option value="auto">Автоопределение формата</option>
														<option value="excel">Excel формат</option>
														<option value="csv">CSV файл</option>
														<option value="json">JSON данные</option>
													</select>
												</div>
												
												<div class="mt-3 text-center">
													<button class="btn btn-primary px-4" onclick="importSchoolFile()">
														<i class="fas fa-upload me-2"></i>Начать импорт
													</button>
												</div>
											</div>
										</div>
									</div>
								</div>
								
								<div class="formats-info">
									<div class="row">
										<div class="col-md-4">
											<div class="format-card text-center p-3">
												<div class="format-icon mb-2">
													<i class="fas fa-file-excel fa-2x text-success"></i>
												</div>
												<div class="format-name fw-medium">Excel</div>
												<div class="format-ext small text-muted">.xlsx, .xls</div>
											</div>
										</div>
										<div class="col-md-4">
											<div class="format-card text-center p-3">
												<div class="format-icon mb-2">
													<i class="fas fa-file-csv fa-2x text-info"></i>
												</div>
												<div class="format-name fw-medium">CSV</div>
												<div class="format-ext small text-muted">.csv, .txt</div>
											</div>
										</div>
										<div class="col-md-4">
											<div class="format-card text-center p-3">
												<div class="format-icon mb-2">
													<i class="fas fa-file-code fa-2x text-warning"></i>
												</div>
												<div class="format-name fw-medium">JSON</div>
												<div class="format-ext small text-muted">.json</div>
											</div>
										</div>
									</div>
								</div>
							</div>
						</div>
						
						<!-- Все классы школы -->
						<div class="card border-0 shadow-sm">
							<div class="card-header bg-white border-0 py-3">
								<div class="d-flex justify-content-between align-items-center">
									<h5 class="mb-0"><i class="fas fa-chalkboard text-primary me-2"></i>Все классы школы</h5>
									<span class="badge bg-primary rounded-pill px-3 py-2">${classesCount} классов</span>
								</div>
							</div>
							<div class="card-body">
								${classesCount === 0 ? `
									<div class="empty-state text-center py-5">
										<div class="empty-state-icon mb-3">
											<i class="fas fa-school fa-3x text-light bg-primary rounded-circle p-4"></i>
										</div>
										<h4 class="text-muted mb-2">Нет данных о классах</h4>
										<p class="text-muted mb-4">Импортируйте файл со списком учащихся школы</p>
										<button class="btn btn-primary" onclick="importSchoolFile()">
											<i class="fas fa-upload me-2"></i>Импортировать данные
										</button>
									</div>
								` : `
									<div class="row" id="classesGrid">
										<!-- Классы будут отображаться здесь -->
									</div>
								`}
							</div>
						</div>
					</div>
					
					<div class="col-xl-4">
						<!-- Блок быстрого выбора -->
						<div class="sticky-top" style="top: 20px;">
							<div class="card border-0 shadow-sm mb-4">
								<div class="card-header bg-white border-0 py-3">
									<h5 class="mb-0"><i class="fas fa-users text-primary me-2"></i>Быстрый выбор учеников</h5>
								</div>
								<div class="card-body">
									<div class="mb-4">
										<label class="form-label fw-medium">Выберите класс</label>
										<div class="class-selector-wrapper">
											<select id="classSelector" class="form-select form-select-lg" onchange="renderClassStudents()">
												<option value="">-- Выберите класс --</option>
												${schoolData.classes.map(cls => `
													<option value="${cls.id}">
														${cls.grade}${cls.name} (${cls.students.length} уч.)
													</option>
												`).join('')}
											</select>
											<div class="select-arrow">
												<i class="fas fa-chevron-down"></i>
											</div>
										</div>
									</div>
									
									<div id="classStudentsContainer" class="mb-4">
										<!-- Здесь будут отображаться ученики выбранного класса -->
										<div class="empty-state text-center py-5">
											<div class="empty-state-icon mb-3">
												<i class="fas fa-user-graduate fa-2x text-light bg-primary rounded-circle p-3"></i>
											</div>
											<h6 class="text-muted mb-2">Выберите класс</h6>
											<p class="text-muted small">Выберите класс из списка выше, чтобы увидеть учеников</p>
										</div>
									</div>
									
									<div class="action-buttons">
										<div class="d-grid gap-3">
											<button class="btn btn-primary btn-lg py-3" 
													onclick="addSelectedToTesting()" 
													disabled 
													id="addSelectedBtn">
												<div class="d-flex align-items-center justify-content-center">
													<i class="fas fa-user-plus me-3 fa-lg"></i>
													<div class="text-start">
														<div class="fw-medium">Добавить выбранных</div>
														<div class="extra-small">На тестирование</div>
													</div>
												</div>
											</button>
											
											<button class="btn btn-success btn-lg py-3" 
													onclick="addWholeClassToTesting()" 
													disabled 
													id="addWholeClassBtn">
												<div class="d-flex align-items-center justify-content-center">
													<i class="fas fa-users me-3 fa-lg"></i>
													<div class="text-start">
														<div class="fw-medium">Весь класс</div>
														<div class="extra-small">Добавить всех учеников</div>
													</div>
												</div>
											</button>
										</div>
									</div>
								</div>
							</div>
							
							<!-- Статистика -->
							<div class="card border-0 shadow-sm">
								<div class="card-header bg-white border-0 py-3">
									<h6 class="mb-0"><i class="fas fa-chart-bar text-primary me-2"></i>Статистика</h6>
								</div>
								<div class="card-body">
									<div class="stats-list">
										<div class="stat-item d-flex justify-content-between align-items-center mb-3">
											<div class="stat-label">
												<i class="fas fa-chalkboard me-2 text-muted"></i>
												Всего классов
											</div>
											<div class="stat-value fw-bold">${classesCount}</div>
										</div>
										
										<div class="stat-item d-flex justify-content-between align-items-center mb-3">
											<div class="stat-label">
												<i class="fas fa-users me-2 text-muted"></i>
												Всего учеников
											</div>
											<div class="stat-value fw-bold">
												${schoolData.classes.reduce((sum, cls) => sum + cls.students.length, 0)}
											</div>
										</div>
										
										<div class="stat-item d-flex justify-content-between align-items-center mb-3">
											<div class="stat-label">
												<i class="fas fa-check-circle me-2 text-muted"></i>
												Активных тестов
											</div>
											<div class="stat-value fw-bold">0</div>
										</div>
										
										<div class="progress-wrapper mt-4">
											<div class="d-flex justify-content-between mb-1">
												<div class="extra-small text-muted">Загруженность</div>
												<div class="extra-small text-muted">25%</div>
											</div>
											<div class="progress" style="height: 6px;">
												<div class="progress-bar bg-primary" style="width: 25%"></div>
											</div>
										</div>
									</div>
								</div>
							</div>
						</div>
					</div>
				</div>
			`;
			
			container.appendChild(mainCard);
			
			// Отображаем сетку классов, если они есть
			if (classesCount > 0) {
				renderClassesGrid();
			}
		}

		// Функция для отображения сетки классов
		function renderClassesGrid() {
			const container = document.getElementById('classesGrid');
			if (!container) return;
			
			container.innerHTML = '';
			
			console.log('Рендерим сетку классов. Всего классов:', schoolData.classes.length);
			
			// Если классов нет, показываем сообщение
			if (schoolData.classes.length === 0) {
				container.innerHTML = `
					<div class="col-12">
						<div class="card border-dashed">
							<div class="card-body text-center py-5">
								<i class="fas fa-school fa-3x text-muted mb-3"></i>
								<h5 class="text-muted">Классы не найдены</h5>
								<p class="text-muted mb-0">Добавьте первый класс, чтобы начать работу</p>
							</div>
						</div>
					</div>
				`;
				return;
			}
			
			schoolData.classes.forEach(cls => {
				const classCard = document.createElement('div');
				classCard.className = 'col-xxl-2 col-xl-3 col-lg-4 col-md-6 mb-4';
				
				const classIdStr = String(cls.id);
				const studentsCount = cls.students.length;
				
				classCard.innerHTML = `
					<div class="class-card card h-100 border-hover shadow-sm">
						<div class="card-header bg-gradient-primary text-white py-3">
							<div class="d-flex justify-content-between align-items-start">
								<div>
									<h5 class="card-title mb-1">${cls.grade}${cls.name}</h5>
									${cls.teacher ? `
										<div class="d-flex align-items-center mt-2">
											<i class="fas fa-chalkboard-teacher me-2 small"></i>
											<span class="small opacity-90">${cls.teacher}</span>
										</div>
									` : ''}
								</div>
								<span class="badge bg-white text-primary rounded-pill px-3 py-2">
									<i class="fas fa-users me-1"></i>
									${studentsCount}
								</span>
							</div>
						</div>
						
						<div class="card-body p-3">
							<div class="students-list" style="max-height: 180px; overflow-y: auto;">
								${cls.students.slice(0, 6).map((student, index) => `
									<div class="student-item d-flex align-items-center justify-content-between py-2 ${index > 0 ? 'border-top-light' : ''}">
										<div class="d-flex align-items-center">
											<div class="student-avatar me-2">
												<div class="avatar-circle bg-light text-dark small">
													${student.lastName.charAt(0)}${student.firstName.charAt(0)}
												</div>
											</div>
											<div>
												<div class="student-name fw-medium">${student.lastName} ${student.firstName.charAt(0)}.</div>
												${student.middleName ? `<div class="student-patronymic text-muted extra-small">${student.middleName}</div>` : ''}
											</div>
										</div>
									</div>
								`).join('')}
								
								${studentsCount > 6 ? `
									<div class="more-students text-center mt-3 pt-2 border-top-light">
										<div class="badge bg-light text-dark px-3 py-2">
											<i class="fas fa-ellipsis-h me-1"></i>
											Ещё ${studentsCount - 6} учеников
										</div>
									</div>
								` : ''}
								
								${studentsCount === 0 ? `
									<div class="text-center py-4">
										<i class="fas fa-user-graduate fa-2x text-muted mb-2"></i>
										<p class="text-muted small mb-0">В классе пока нет учеников</p>
									</div>
								` : ''}
							</div>
						</div>
						
						<div class="card-footer bg-transparent border-top-0 py-3">
							<div class="btn-group-vertical w-100 gap-2">
								<button class="btn btn-primary" onclick="selectClass('${classIdStr}')">
									<i class="fas fa-check me-2"></i>Выбрать класс
								</button>
								
								<div class="d-grid gap-1">
									<button class="btn btn-outline-success btn-sm" onclick="addWholeClassToTestingFromCard('${classIdStr}')">
										<i class="fas fa-user-plus me-1"></i>Добавить на тестирование
									</button>
									<button class="btn btn-outline-info btn-sm" onclick="showQRForClass('${classIdStr}')">
										<i class="fas fa-qrcode me-1"></i>QR-код класса
									</button>
									<button class="btn btn-outline-danger btn-sm" onclick="deleteClass('${classIdStr}')">
										<i class="fas fa-trash me-1"></i>Удалить класс
									</button>
								</div>
							</div>
						</div>
					</div>
				`;
				container.appendChild(classCard);
			});
		}

		// 10. Добавьте функцию для отладки данных
		function debugSchoolData() {
			console.log('=== ОТЛАДКА SCHOOLDATA ===');
			console.log('schoolData:', schoolData);
			console.log('Классы:', schoolData.classes.length);
			
			schoolData.classes.forEach((cls, i) => {
				console.log(`Класс ${i}:`, {
					id: cls.id,
					type: typeof cls.id,
					name: `${cls.grade}${cls.name}`,
					students: cls.students.length,
					isClassInstance: cls instanceof SchoolClass
				});
			});
			
			// Проверяем сохранение в localStorage
			const saved = localStorage.getItem('schoolData');
			if (saved) {
				const parsed = JSON.parse(saved);
				console.log('Сохранено в localStorage:', parsed);
			}
		}
		
		// Обработчик действий с классами
		function handleClassAction(event) {
			const button = event.target.closest('.class-action-btn');
			if (!button) return;
			
			const classId = button.dataset.classId;
			const action = button.dataset.action;
			
			console.log('handleClassAction:', { classId, action, button: button.innerHTML });
			
			if (!classId) {
				console.error('classId не найден в data-атрибуте');
				return;
			}
			
			// Пробуем разные варианты поиска класса
			console.log('Поиск класса с ID:', classId);
			console.log('Тип classId:', typeof classId);
			console.log('Все доступные ID:', schoolData.classes.map(c => ({id: c.id, type: typeof c.id})));
			
			const schoolClass = schoolData.classes.find(c => {
				return c.id == classId || 
					   c.id.toString() === classId.toString() ||
					   String(c.id) === String(classId);
			});
			
			if (!schoolClass) {
				console.error('Класс не найден ни одним способом');
				return;
			}
			
			console.log('Класс найден:', schoolClass);
			
			switch(action) {
				case 'select':
					selectClass(classId);
					break;
				case 'add-all':
					addWholeClassToTestingFromCard(classId);
					break;
				case 'qr':
					showQRForClass(classId);
					break;
				case 'delete':
					deleteClass(classId);
					break;
			}
		}


		// Функция для отображения учеников выбранного класса
		// Также обновите renderClassStudents:
		function renderClassStudents() {
			const classId = document.getElementById('classSelector').value;
			const container = document.getElementById('classStudentsContainer');
			const addSelectedBtn = document.getElementById('addSelectedBtn');
			const addWholeClassBtn = document.getElementById('addWholeClassBtn');
			
			// Очистка и состояние по умолчанию
			if (!classId || !container) {
				if (container) {
					container.innerHTML = `
						<div class="empty-state text-center py-5">
							<div class="empty-state-icon mb-3">
								<i class="fas fa-users fa-3x text-light bg-primary rounded-circle p-4"></i>
							</div>
							<h5 class="text-muted mb-2">Выберите класс</h5>
							<p class="text-muted small">Выберите класс из списка выше, чтобы увидеть учеников</p>
						</div>
					`;
				}
				if (addSelectedBtn) {
					addSelectedBtn.disabled = true;
					addSelectedBtn.classList.add('opacity-50');
				}
				if (addWholeClassBtn) {
					addWholeClassBtn.disabled = true;
					addWholeClassBtn.classList.add('opacity-50');
				}
				return;
			}
			
			const schoolClass = schoolData.classes.find(c => c.id === classId);
			if (!schoolClass) {
				container.innerHTML = `
					<div class="alert alert-warning">
						<i class="fas fa-exclamation-triangle me-2"></i>
						Класс не найден
					</div>
				`;
				return;
			}
			
			const studentsCount = schoolClass.students.length;
			const addedStudents = appData.students || [];
			
			// Основная структура
			let html = `
				<div class="class-header mb-4">
					<div class="d-flex justify-content-between align-items-start mb-3">
						<div>
							<h4 class="mb-1">${schoolClass.grade}${schoolClass.name}</h4>
							${schoolClass.teacher ? `
								<div class="d-flex align-items-center text-muted">
									<i class="fas fa-chalkboard-teacher me-2 small"></i>
									<span>${schoolClass.teacher}</span>
								</div>
							` : ''}
						</div>
						<div class="text-end">
							<span class="badge bg-primary rounded-pill px-3 py-2">
								<i class="fas fa-users me-1"></i>
								${studentsCount} учеников
							</span>
							${addedStudents.length > 0 ? `
								<div class="mt-2">
									<span class="badge bg-success rounded-pill px-3 py-1">
										<i class="fas fa-check me-1"></i>
										${addedStudents.filter(s => 
											schoolClass.students.some(clsStudent => 
												s.includes(clsStudent.lastName) && s.includes(clsStudent.firstName)
											)
										).length} добавлено
									</span>
								</div>
							` : ''}
						</div>
					</div>
					
					<div class="action-bar card border-0 bg-light p-3 mb-3">
						<div class="row g-2">
							<div class="col-md-8">
								<div class="form-check form-switch d-flex align-items-center">
									<input class="form-check-input me-2" type="checkbox" 
										   id="selectAllStudents" role="switch"
										   onchange="toggleAllStudents(this.checked)">
									<label class="form-check-label fw-medium" for="selectAllStudents">
										Выбрать всех учеников
									</label>
								</div>
								<div class="form-text small text-muted mt-1">
									Отметьте учеников для добавления на тестирование
								</div>
							</div>
							<div class="col-md-4">
								<div class="btn-group w-100">
									<button class="btn btn-sm btn-outline-primary" onclick="clearSelection()">
										<i class="fas fa-times me-1"></i>Снять выделение
									</button>
									<button class="btn btn-sm btn-outline-success" onclick="addInvertedSelection()">
										<i class="fas fa-exchange-alt me-1"></i>Инвертировать
									</button>
								</div>
							</div>
						</div>
					</div>
				</div>
				
				<div class="students-container">
					<div class="students-list" style="max-height: 300px; overflow-y: auto;">
			`;
			
			// Список учеников
			if (studentsCount === 0) {
				html += `
					<div class="text-center py-5">
						<i class="fas fa-user-graduate fa-3x text-muted mb-3"></i>
						<h5 class="text-muted">В классе нет учеников</h5>
						<p class="text-muted small">Добавьте учеников в этот класс</p>
					</div>
				`;
			} else {
				schoolClass.students.forEach((student, index) => {
					const isInTesting = addedStudents.some(s => 
						s.includes(student.lastName) && s.includes(student.firstName)
					);
					const studentId = student.id || `${student.lastName}_${student.firstName}`;
					
					html += `
						<div class="student-card card mb-2 border-hover ${isInTesting ? 'border-success border-2' : ''}">
							<div class="card-body py-2">
								<div class="row align-items-center">
									<div class="col-auto">
										<div class="form-check">
											<input class="form-check-input student-checkbox" type="checkbox" 
												   value="${studentId}" id="student_${studentId}"
												   ${isInTesting ? 'disabled' : ''}>
										</div>
									</div>
									<div class="col">
										<div class="d-flex align-items-center">
											<div class="student-avatar me-3">
												<div class="avatar-circle bg-primary text-white">
													${student.lastName.charAt(0)}${student.firstName.charAt(0)}
												</div>
											</div>
											<div>
												<div class="student-name fw-medium">
													${student.lastName} ${student.firstName}
													${student.middleName ? ` ${student.middleName}` : ''}
												</div>
												<div class="student-id text-muted extra-small">
													ID: ${studentId}
												</div>
											</div>
										</div>
									</div>
									<div class="col-auto">
										<div class="action-buttons">
											${isInTesting ? 
												`<span class="badge bg-success rounded-pill px-3">
													<i class="fas fa-check me-1"></i>Добавлен
												</span>` : 
												`<button class="btn btn-primary btn-sm rounded-pill px-3" 
														onclick="addSingleStudent('${studentId}')">
													<i class="fas fa-plus me-1"></i>Добавить
												</button>`
											}
										</div>
									</div>
								</div>
							</div>
						</div>
					`;
				});
			}
			
			html += `
					</div>
					
					${studentsCount > 0 ? `
						<div class="summary-footer mt-4 pt-3 border-top">
							<div class="row">
								<div class="col-md-6">
									<div class="d-flex align-items-center">
										<div class="me-3">
											<span class="badge bg-light text-dark">Выбрано: 
												<span id="selectedCount" class="text-primary fw-bold">0</span>
											</span>
										</div>
										<div class="form-text">
											Можно добавить до ${studentsCount - (addedStudents.filter(s => 
												schoolClass.students.some(clsStudent => 
													s.includes(clsStudent.lastName) && s.includes(clsStudent.firstName)
												)
											).length)} учеников
										</div>
									</div>
								</div>
								<div class="col-md-6 text-end">
									<div class="btn-group">
										<button class="btn btn-primary" id="addSelectedBtn" onclick="addSelectedStudents()">
											<i class="fas fa-user-plus me-2"></i>
											Добавить выбранных
										</button>
										<button class="btn btn-success" id="addWholeClassBtn" onclick="addWholeClassToTesting()">
											<i class="fas fa-users me-2"></i>
											Весь класс
										</button>
									</div>
								</div>
							</div>
						</div>
					` : ''}
				</div>
			`;
			
			container.innerHTML = html;
			
			// Активируем кнопки
			if (addSelectedBtn) {
				addSelectedBtn.disabled = false;
				addSelectedBtn.classList.remove('opacity-50');
			}
			if (addWholeClassBtn && studentsCount > 0) {
				addWholeClassBtn.disabled = false;
				addWholeClassBtn.classList.remove('opacity-50');
			}
			
			// Обновляем счетчик выбранных
			updateSelectedCount();
		}

		// Вспомогательные функции
		function updateSelectedCount() {
			const checkboxes = document.querySelectorAll('.student-checkbox:not(:disabled)');
			const count = Array.from(checkboxes).filter(cb => cb.checked).length;
			const countElement = document.getElementById('selectedCount');
			if (countElement) {
				countElement.textContent = count;
			}
		}

		function toggleAllStudents(checked) {
			document.querySelectorAll('.student-checkbox:not(:disabled)').forEach(cb => {
				cb.checked = checked;
			});
			updateSelectedCount();
		}

		function clearSelection() {
			toggleAllStudents(false);
		}

		function addInvertedSelection() {
			document.querySelectorAll('.student-checkbox:not(:disabled)').forEach(cb => {
				cb.checked = !cb.checked;
			});
			updateSelectedCount();
		}

		// Обновляем счетчик при клике на чекбоксы
		document.addEventListener('change', function(e) {
			if (e.target.classList.contains('student-checkbox')) {
				updateSelectedCount();
			}
		});
		
		// Загрузка данных школы из localStorage
		function loadSchoolData() {
			try {
				const saved = localStorage.getItem('schoolData');
				if (saved) {
					const parsed = JSON.parse(saved);
					
					// Восстанавливаем классы с правильными прототипами
					if (parsed.classes && Array.isArray(parsed.classes)) {
						parsed.classes = parsed.classes.map(clsData => {
							const schoolClass = new SchoolClass(clsData.name, clsData.grade, clsData.teacher);
							
							// Копируем все свойства
							Object.keys(clsData).forEach(key => {
								if (key !== 'students') {
									schoolClass[key] = clsData[key];
								}
							});
							
							// Восстанавливаем студентов
							if (clsData.students && Array.isArray(clsData.students)) {
								schoolClass.students = clsData.students.map(studentData => {
									const student = new SchoolStudent(
										studentData.lastName,
										studentData.firstName,
										studentData.middleName,
										studentData.id
									);
									
									// Копируем остальные свойства
									Object.keys(studentData).forEach(key => {
										if (!['lastName', 'firstName', 'middleName', 'id'].includes(key)) {
											student[key] = studentData[key];
										}
									});
									
									return student;
								});
							}
							
							return schoolClass;
						});
					}
					
					// Обновляем schoolData
					Object.assign(schoolData, parsed);
					console.log('Данные школы загружены:', schoolData.classes.length, 'классов');
					
				} else {
					console.log('Нет сохраненных данных школы');
				}
			} catch (error) {
				console.error('Ошибка загрузки данных школы:', error);
				// Сбрасываем на начальные значения
				schoolData.classes = [];
				schoolData.lastImportDate = null;
				schoolData.schoolName = '';
			}
		}

		// Удаление класса
		function deleteClass(classId) {
			if (!confirm('Удалить этот класс? Все данные об учениках будут удалены.')) {
				return;
			}
			
			const index = schoolData.classes.findIndex(c => c.id === classId);
			if (index !== -1) {
				schoolData.classes.splice(index, 1);
				localStorage.setItem('schoolData', JSON.stringify(schoolData));
				renderClassManager();
				showNotification('Класс удален', 'success');
			}
		}	
		
		// Генерация QR-кода для класса
		function showQRForClass(classId) {
			const schoolClass = schoolData.classes.find(c => c.id === classId);
			if (!schoolClass) return;
			
			// Создаем уникальную ссылку для класса
			const classData = {
				classId: schoolClass.id,
				className: `${schoolClass.grade}${schoolClass.name}`,
				students: schoolClass.students.map(s => ({
					lastName: s.lastName,
					firstName: s.firstName,
					middleName: s.middleName
				})),
				timestamp: new Date().toISOString()
			};
			
			const dataStr = JSON.stringify(classData);
			const dataUrl = `data:application/json;charset=utf-8,${encodeURIComponent(dataStr)}`;
			
			// Создаем модальное окно с QR-кодом
			const modal = document.createElement('div');
			modal.className = 'modal fade';
			modal.id = 'qrModal';
			modal.innerHTML = `
				<div class="modal-dialog modal-dialog-centered">
					<div class="modal-content">
						<div class="modal-header">
							<h5 class="modal-title">QR-код класса ${schoolClass.grade}${schoolClass.name}</h5>
							<button type="button" class="btn-close" data-bs-dismiss="modal"></button>
						</div>
						<div class="modal-body text-center">
							<div id="qrCodeContainer" class="mb-3"></div>
							<p class="text-muted small">
								Отсканируйте QR-код для быстрого импорта данных класса
							</p>
							<div class="d-grid gap-2">
								<button class="btn btn-outline-primary" onclick="downloadQRCode()">
									<i class="fas fa-download me-2"></i>Скачать QR-код
								</button>
								<button class="btn btn-outline-secondary" onclick="shareClassData('${classId}')">
									<i class="fas fa-share-alt me-2"></i>Поделиться
								</button>
							</div>
						</div>
					</div>
				</div>
			`;
			
			document.body.appendChild(modal);
			
			// Инициализируем модальное окно Bootstrap
			const modalInstance = new bootstrap.Modal(modal);
			modalInstance.show();
			
			// Генерируем QR-код после отображения модального окна
			setTimeout(() => {
				QRCode.toCanvas(document.getElementById('qrCodeContainer'), dataUrl, {
					width: 200,
					margin: 2,
					color: {
						dark: '#000000',
						light: '#FFFFFF'
					}
				}, function(error) {
					if (error) {
						console.error('Ошибка генерации QR-кода:', error);
						showNotification('Ошибка генерации QR-кода', 'error');
					}
				});
			}, 100);
			
			// Удаляем модальное окно после закрытия
			modal.addEventListener('hidden.bs.modal', function() {
				modal.remove();
			});
		}

		// Скачивание QR-кода
		function downloadQRCode() {
			const canvas = document.querySelector('#qrModal canvas');
			if (!canvas) return;
			
			const link = document.createElement('a');
			link.download = `qr-code-класс-${new Date().toISOString().slice(0, 10)}.png`;
			link.href = canvas.toDataURL('image/png');
			link.click();
			
			showNotification('QR-код скачан', 'success');
		}

		// Поделиться данными класса
		function shareClassData(classId) {
			const schoolClass = schoolData.classes.find(c => c.id === classId);
			if (!schoolClass) return;
			
			const shareText = `Класс: ${schoolClass.grade}${schoolClass.name}\n` +
							 `Учеников: ${schoolClass.students.length}\n` +
							 `Список учеников:\n` +
							 schoolClass.students.map(s => 
								 `- ${s.lastName} ${s.firstName} ${s.middleName || ''}`
							 ).join('\n');
			
			if (navigator.share) {
				navigator.share({
					title: `Класс ${schoolClass.grade}${schoolClass.name}`,
					text: shareText,
					url: window.location.href
				}).catch(console.error);
			} else {
				// Копируем в буфер обмена
				navigator.clipboard.writeText(shareText)
					.then(() => showNotification('Список класса скопирован в буфер обмена', 'success'))
					.catch(() => {
						// Fallback для старых браузеров
						const textarea = document.createElement('textarea');
						textarea.value = shareText;
						document.body.appendChild(textarea);
						textarea.select();
						document.execCommand('copy');
						document.body.removeChild(textarea);
						showNotification('Список класса скопирован в буфер обмена', 'success');
					});
			}
		}		
		// Импорт данных школы из файла
		async function importSchoolFile() {
			const fileInput = document.getElementById('schoolFileInput');
			const fileFormat = document.getElementById('fileFormat').value;
			const schoolNameInput = document.getElementById('schoolName');
			
			if (!fileInput.files.length) {
				showNotification('Выберите файл для импорта', 'warning');
				return;
			}
			
			const file = fileInput.files[0];
			const schoolName = schoolNameInput.value.trim() || 'Без названия';
			
			showNotification('Начинаю импорт данных...', 'info');
			
			try {
				let data = [];
				
				if (file.name.toLowerCase().endsWith('.xlsx') || file.name.toLowerCase().endsWith('.xls')) {
					data = await importFromExcel(file);
				} else if (file.name.toLowerCase().endsWith('.csv') || file.name.toLowerCase().endsWith('.txt')) {
					data = await importFromCSV(file);
				} else {
					showNotification('Неподдерживаемый формат файла', 'error');
					return;
				}
				
				if (!data || data.length === 0) {
					showNotification('Файл пуст или содержит некорректные данные', 'warning');
					return;
				}
				
				const classes = parseSchoolData(data);
				
				if (classes.length === 0) {
					showNotification('Не удалось распознать данные в файле', 'warning');
					return;
				}
				
				// Устанавливаем новые данные
				schoolData.schoolName = schoolName;
				schoolData.classes = classes;
				schoolData.lastImportDate = new Date().toISOString();
				
				// Сохраняем в localStorage
				saveSchoolData();
				
				// Обновляем интерфейс
				renderClassManager();
				
				const totalStudents = countTotalStudents(classes);
				showNotification(`Импортировано ${classes.length} классов, ${totalStudents} учеников`, 'success');
				
				console.log('Импорт завершен. Данные школы:', schoolData);
				
			} catch (error) {
				console.error('Ошибка импорта:', error);
				showNotification('Ошибка при импорте файла: ' + error.message, 'error');
			}
		}

		// 7. Добавьте функцию saveSchoolData
		function saveSchoolData() {
			try {
				localStorage.setItem('schoolData', JSON.stringify(schoolData));
				console.log('Данные школы сохранены:', schoolData);
			} catch (error) {
				console.error('Ошибка сохранения данных школы:', error);
			}
		}
		
		// Импорт из Excel
		async function importFromExcel(file) {
			return new Promise((resolve, reject) => {
				const reader = new FileReader();
				
				reader.onload = function(e) {
					try {
						console.log('Чтение Excel файла...');
						const data = new Uint8Array(e.target.result);
						const workbook = XLSX.read(data, { 
							type: 'array',
							cellDates: true,
							cellNF: false,
							cellText: false,
							raw: false // Получаем форматированные значения
						});
						
						console.log('Листы в файле:', workbook.SheetNames);
						
						// Используем первый лист
						const sheetName = workbook.SheetNames[0];
						const worksheet = workbook.Sheets[sheetName];
						
						// Получаем данные в разных форматах для отладки
						const jsonData = XLSX.utils.sheet_to_json(worksheet, { 
							header: 1, // Получаем как массив массивов
							defval: '' // Значение по умолчанию для пустых ячеек
						});
						
						console.log('Данные Excel (первые 10 строк):', jsonData.slice(0, 10));
						resolve(jsonData);
						
					} catch (error) {
						console.error('Ошибка парсинга Excel:', error);
						reject(error);
					}
				};
				
				reader.onerror = function() {
					reject(new Error('Ошибка чтения файла'));
				};
				
				reader.readAsArrayBuffer(file);
			});
		}

		// Функция предпросмотра файла перед импортом
		function setupFilePreview() {
			const fileInput = document.getElementById('schoolFileInput');
			if (!fileInput) return;
			
			fileInput.addEventListener('change', function(e) {
				const file = e.target.files[0];
				if (!file) return;
				
				// Показываем предпросмотр
				showFilePreview(file);
			});
		}

		// Предпросмотр файла
		async function showFilePreview(file) {
			const previewDiv = document.createElement('div');
			previewDiv.className = 'card mt-3';
			previewDiv.innerHTML = `
				<div class="card-header">
					<h6 class="mb-0">Предпросмотр файла: ${file.name}</h6>
				</div>
				<div class="card-body">
					<div class="table-responsive">
						<table class="table table-sm table-bordered" id="filePreviewTable">
							<thead>
								<tr>
									<th>#</th>
									<th>Содержимое строки</th>
								</tr>
							</thead>
							<tbody id="previewTableBody">
								<!-- Данные будут здесь -->
							</tbody>
						</table>
					</div>
					<div class="mt-3">
						<button class="btn btn-sm btn-outline-secondary" onclick="analyzeFileStructure()">
							<i class="fas fa-search me-1"></i>Анализировать структуру
						</button>
					</div>
				</div>
			`;
			
			// Вставляем предпросмотр перед кнопкой импорта
			const importButton = document.querySelector('button[onclick="importSchoolFile()"]');
			if (importButton && importButton.parentNode) {
				const existingPreview = document.getElementById('filePreview');
				if (existingPreview) existingPreview.remove();
				
				previewDiv.id = 'filePreview';
				importButton.parentNode.insertBefore(previewDiv, importButton);
			}
			
			// Читаем первые строки файла
			try {
				let previewData = [];
				
				if (file.name.toLowerCase().endsWith('.xlsx') || file.name.toLowerCase().endsWith('.xls')) {
					previewData = await getFilePreview(file, 10);
				} else {
					previewData = await getCSVPreview(file, 10);
				}
				
				const tbody = document.getElementById('previewTableBody');
				tbody.innerHTML = previewData.map((row, i) => `
					<tr>
						<td class="text-center" style="width: 50px;">${i + 1}</td>
						<td>${row.map(cell => 
							`<span class="badge bg-light text-dark me-1 mb-1">${escapeHtml(String(cell))}</span>`
						).join('')}</td>
					</tr>
				`).join('');
				
			} catch (error) {
				console.error('Ошибка предпросмотра:', error);
			}
		}

		// Получение предпросмотра Excel
		async function getFilePreview(file, maxRows = 10) {
			return new Promise((resolve, reject) => {
				const reader = new FileReader();
				
				reader.onload = function(e) {
					try {
						const data = new Uint8Array(e.target.result);
						const workbook = XLSX.read(data, { type: 'array' });
						const sheetName = workbook.SheetNames[0];
						const worksheet = workbook.Sheets[sheetName];
						const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });
						resolve(jsonData.slice(0, maxRows));
					} catch (error) {
						reject(error);
					}
				};
				
				reader.onerror = reject;
				reader.readAsArrayBuffer(file);
			});
		}

		// Получение предпросмотра CSV
		async function getCSVPreview(file, maxRows = 10) {
			return new Promise((resolve, reject) => {
				const reader = new FileReader();
				
				reader.onload = function(e) {
					try {
						const text = e.target.result;
						const lines = text.split('\n').slice(0, maxRows);
						const data = lines.map(line => {
							if (line.includes(';')) return line.split(';');
							if (line.includes(',')) return line.split(',');
							if (line.includes('\t')) return line.split('\t');
							return [line];
						}).map(row => row.map(cell => cell.trim()));
						resolve(data);
					} catch (error) {
						reject(error);
					}
				};
				
				reader.onerror = reject;
				reader.readAsText(file, 'UTF-8');
			});
		}

		// Анализ структуры файла
		async function analyzeFileStructure() {
			const fileInput = document.getElementById('schoolFileInput');
			if (!fileInput.files.length) return;
			
			const file = fileInput.files[0];
			
			try {
				let data = [];
				
				if (file.name.toLowerCase().endsWith('.xlsx') || file.name.toLowerCase().endsWith('.xls')) {
					data = await getFilePreview(file, 20);
				} else {
					data = await getCSVPreview(file, 20);
				}
				
				const structure = detectFileStructure(data);
				
				// Показываем результаты анализа
				const resultDiv = document.createElement('div');
				resultDiv.className = 'alert alert-info mt-3';
				resultDiv.innerHTML = `
					<h6><i class="fas fa-chart-bar me-2"></i>Результаты анализа файла</h6>
					<ul class="mb-0">
						<li><strong>Заголовок:</strong> ${structure.hasHeader ? 'Да' : 'Нет'}</li>
						<li><strong>Формат:</strong> ${structure.format === 'class-first' ? 'Класс > ФИО' : 'ФИО > Класс'}</li>
						<li><strong>Колонки:</strong>
							${structure.columns.class >= 0 ? `Класс: ${structure.columns.class + 1}` : 'не найден'},
							${structure.columns.lastName >= 0 ? `Фамилия: ${structure.columns.lastName + 1}` : 'не найден'},
							${structure.columns.firstName >= 0 ? `Имя: ${structure.columns.firstName + 1}` : 'не найден'}
						</li>
						<li><strong>Строк для анализа:</strong> ${data.length}</li>
					</ul>
				`;
				
				// Удаляем предыдущие результаты
				const existingResults = document.querySelector('.alert.alert-info[style*="analysis"]');
				if (existingResults) existingResults.remove();
				
				resultDiv.style.cssText = 'animation: fadeIn 0.5s;';
				document.getElementById('filePreview').appendChild(resultDiv);
				
			} catch (error) {
				console.error('Ошибка анализа:', error);
				showNotification('Ошибка анализа файла', 'error');
			}
		}

		// Экранирование HTML
		function escapeHtml(text) {
			const div = document.createElement('div');
			div.textContent = text;
			return div.innerHTML;
		}

		// Добавьте CSS анимацию
		const style = document.createElement('style');
		style.textContent = `
			@keyframes fadeIn {
				from { opacity: 0; transform: translateY(-10px); }
				to { opacity: 1; transform: translateY(0); }
			}
			
			.badge-cell {
				font-family: monospace;
				background-color: #f8f9fa;
				border: 1px solid #dee2e6;
				border-radius: 3px;
				padding: 2px 6px;
				margin: 1px;
				display: inline-block;
				font-size: 12px;
			}
		`;
		document.head.appendChild(style);

		// Импорт из CSV
		async function importFromCSV(file) {
			return new Promise((resolve, reject) => {
				const reader = new FileReader();
				
				reader.onload = function(e) {
					try {
						console.log('Чтение CSV файла...');
						const text = e.target.result;
						
						// Пробуем разные разделители
						let delimiter = ';';
						if (text.includes(',')) delimiter = ',';
						if (text.includes('\t')) delimiter = '\t';
						
						console.log('Определен разделитель:', delimiter);
						
						const lines = text.split('\n').filter(line => line.trim() !== '');
						const data = lines.map(line => {
							// Обрабатываем кавычки
							const cells = [];
							let currentCell = '';
							let inQuotes = false;
							
							for (let i = 0; i < line.length; i++) {
								const char = line[i];
								const nextChar = line[i + 1];
								
								if (char === '"') {
									if (inQuotes && nextChar === '"') {
										// Двойная кавычка внутри кавычек
										currentCell += '"';
										i++; // Пропускаем следующую кавычку
									} else {
										inQuotes = !inQuotes;
									}
								} else if (char === delimiter && !inQuotes) {
									cells.push(currentCell);
									currentCell = '';
								} else {
									currentCell += char;
								}
							}
							
							cells.push(currentCell);
							return cells.map(cell => cell.trim());
						});
						
						console.log('Данные CSV (первые 10 строк):', data.slice(0, 10));
						resolve(data);
						
					} catch (error) {
						console.error('Ошибка парсинга CSV:', error);
						reject(error);
					}
				};
				
				reader.onerror = function() {
					reject(new Error('Ошибка чтения файла'));
				};
				
				reader.readAsText(file, 'UTF-8');
			});
		}

		// Парсинг данных школы из массива
		function parseSchoolData(data) {
			const classesMap = new Map();
			
			const structure = detectFileStructure(data);
			console.log('Обнаруженная структура:', structure);
			
			let startRow = structure.hasHeader ? 1 : 0;
			
			for (let i = startRow; i < data.length; i++) {
				const row = data[i];
				if (!row || row.length === 0) continue;
				
				const cleanRow = row.map(cell => {
					if (cell === null || cell === undefined) return '';
					return String(cell).trim();
				}).filter(cell => cell !== '');
				
				if (cleanRow.length < 2) continue;
				
				let className = '';
				let lastName = '';
				let firstName = '';
				let middleName = '';
				
				if (structure.format === 'class-first') {
					className = cleanRow[structure.columns.class] || '';
					lastName = cleanRow[structure.columns.lastName] || '';
					firstName = cleanRow[structure.columns.firstName] || '';
					middleName = cleanRow[structure.columns.middleName] || '';
				} else if (structure.format === 'class-last') {
					lastName = cleanRow[structure.columns.lastName] || '';
					firstName = cleanRow[structure.columns.firstName] || '';
					middleName = cleanRow[structure.columns.middleName] || '';
					className = cleanRow[structure.columns.class] || '';
				} else {
					className = findClassName(cleanRow);
					if (className) {
						const classIndex = cleanRow.indexOf(className);
						const fioParts = cleanRow.filter((_, idx) => idx !== classIndex);
						
						if (fioParts.length >= 2) {
							lastName = fioParts[0];
							firstName = fioParts[1];
							middleName = fioParts[2] || '';
						}
					}
				}
				
				className = normalizeClassName(className);
				
				if (!className || !lastName || !firstName) {
					continue;
				}
				
				const match = className.match(/([0-9]+)([А-Яа-яA-Za-z]+)?/);
				if (!match) continue;
				
				const grade = parseInt(match[1]);
				const letter = (match[2] || 'А').toUpperCase();
				const classKey = `${grade}-${letter}`;
				
				if (!classesMap.has(classKey)) {
					const schoolClass = new SchoolClass(letter, grade);
					classesMap.set(classKey, schoolClass);
				}
				
				const schoolClass = classesMap.get(classKey);
				
				// Создаем студента
				const student = new SchoolStudent(lastName, firstName, middleName);
				student.classId = schoolClass.id;
				schoolClass.students.push(student);
			}
			
			const classesArray = Array.from(classesMap.values());
			console.log('Созданы классы:', classesArray.map(c => ({
				id: c.id,
				name: `${c.grade}${c.name}`,
				students: c.students.length
			})));
			
			return classesArray;
		}

		// Функция для определения структуры файла
		function detectFileStructure(data) {
			if (!data || data.length === 0) {
				return { hasHeader: false, format: 'unknown' };
			}
			
			const firstRow = data[0];
			const secondRow = data[1] || [];
			
			// Преобразуем в строки и приводим к нижнему регистру
			const firstRowLower = firstRow.map(cell => 
				String(cell || '').trim().toLowerCase()
			);
			
			// Проверяем наличие заголовка
			let hasHeader = false;
			const headerKeywords = ['класс', 'фамилия', 'имя', 'отчество', 'ученик', 'student', 'lastname', 'firstname'];
			
			if (firstRowLower.some(cell => headerKeywords.some(keyword => cell.includes(keyword)))) {
				hasHeader = true;
			}
			
			// Определяем формат
			let format = 'unknown';
			let columns = {
				class: -1,
				lastName: -1,
				firstName: -1,
				middleName: -1
			};
			
			// Если есть заголовок, определяем колонки по нему
			if (hasHeader) {
				firstRowLower.forEach((cell, index) => {
					if (cell.includes('класс')) columns.class = index;
					if (cell.includes('фамилия') || cell.includes('lastname')) columns.lastName = index;
					if (cell.includes('имя') || cell.includes('firstname')) columns.firstName = index;
					if (cell.includes('отчество') || cell.includes('middlename')) columns.middleName = index;
				});
				
				// Определяем формат по расположению колонки "класс"
				if (columns.class === 0) {
					format = 'class-first';
				} else if (columns.class > 0) {
					format = 'class-last';
				}
			} else {
				// Пытаемся определить формат по второй строке
				if (secondRow.length >= 4) {
					// Проверяем, содержит ли первая ячейка номер класса
					const firstCell = String(secondRow[0] || '').trim();
					if (firstCell.match(/[0-9]+[А-Яа-яA-Za-z]/)) {
						format = 'class-first';
						columns = { class: 0, lastName: 1, firstName: 2, middleName: 3 };
					} else {
						format = 'class-last';
						columns = { lastName: 0, firstName: 1, middleName: 2, class: 3 };
					}
				}
			}
			
			return { hasHeader, format, columns };
		}

		// Функция для поиска номера класса в строке
		function findClassName(rowCells) {
			for (const cell of rowCells) {
				const str = String(cell).trim();
				// Ищем паттерны: "5А", "10Б", "11а", "7-b", "8 класс", "9 класс А"
				const match = str.match(/([0-9]+)[\s\-]*([А-Яа-яA-Za-z]+)?[\s]*к?л?а?с?с?/i);
				if (match) {
					return match[1] + (match[2] || 'А');
				}
			}
			return '';
		}

		// Нормализация имени класса
		function normalizeClassName(className) {
			if (!className) return '';
			
			// Удаляем слово "класс" и лишние пробелы
			let normalized = className.replace(/[\s\-]*к?л?а?с?с?/gi, '').trim();
			
			// Добавляем букву "А", если только номер
			if (normalized.match(/^[0-9]+$/)) {
				normalized += 'А';
			}
			
			return normalized;
		}

		// Подсчет общего количества учеников
		function countTotalStudents(classes) {
			return classes.reduce((total, cls) => total + cls.students.length, 0);
		}		
		
		// ==================== ФУНКЦИИ ПЕРЕТАСКИВАНИЯ ====================

		function handleDragStart(e) {
			dragStartIndex = parseInt(e.target.closest('tr').dataset.index);
			const row = e.target.closest('tr');
			row.style.opacity = '0.5';
			row.style.backgroundColor = '#e3f2fd';
			isDragging = true;
			
			e.dataTransfer.effectAllowed = 'move';
			e.dataTransfer.setData('text/plain', dragStartIndex.toString());
		}

		function handleDragOver(e) {
			e.preventDefault();
			e.dataTransfer.dropEffect = 'move';
			
			const row = e.target.closest('tr');
			if (row && row.id !== `student-row-${dragStartIndex}`) {
				row.style.borderTop = '2px solid #2196f3';
				row.style.borderBottom = '2px solid #2196f3';
			}
		}

		function handleDrop(e) {
			e.preventDefault();
			
			const dragEndRow = e.target.closest('tr');
			if (!dragEndRow) return;
			
			const dragEndIndex = parseInt(dragEndRow.dataset.index);
			if (dragStartIndex === null || dragEndIndex === null || dragStartIndex === dragEndIndex) {
				return;
			}
			
			// Перемещаем студента
			moveStudent(dragStartIndex, dragEndIndex);
			
			// Снимаем стили
			document.querySelectorAll('#studentsTableBody tr').forEach(row => {
				row.style.borderTop = '';
				row.style.borderBottom = '';
				row.style.opacity = '';
				row.style.backgroundColor = '';
			});
			
			dragStartIndex = null;
			isDragging = false;
		}

		function handleDragEnd(e) {
			document.querySelectorAll('#studentsTableBody tr').forEach(row => {
				row.style.borderTop = '';
				row.style.borderBottom = '';
				row.style.opacity = '';
				row.style.backgroundColor = '';
			});
			dragStartIndex = null;
			isDragging = false;
		}

		// ==================== ДОПОЛНИТЕЛЬНЫЕ ФУНКЦИИ ====================

		function addMultipleStudents(count) {
			for (let i = 0; i < count; i++) {
				const newStudent = `Учащийся ${appData.students.length + 1}`;
				appData.students.push(newStudent);
				appData.results.push(new Array(appData.tasks.length).fill(0));
			}
			
			saveData();
			
			renderStudents();
			renderResults();
			showNotification(`Добавлено ${count} учащихся`, "success");
		}

		function clearStudents() {
			if (appData.students.length === 0) return;
			
			if (confirm(`Очистить весь список учащихся (${appData.students.length} записей)? Все результаты будут удалены.`)) {
				appData.students = [];
				appData.results = [];
				appData.errors = [];
				
				// Создаем одного студента по умолчанию
				appData.students.push('Учащийся 1');
				appData.results.push(new Array(appData.tasks.length).fill(0));
				
				saveData();
				
				renderStudents();
				renderResults();
				showNotification("Список учащихся очищен", "success");
			}
		}

		function filterStudents() {
			const searchTerm = document.getElementById('studentSearch').value.toLowerCase();
			const rows = document.querySelectorAll('#studentsTableBody tr');
			
			rows.forEach(row => {
				const input = row.querySelector('input[type="text"]');
				if (input) {
					const studentName = input.value.toLowerCase();
					if (studentName.includes(searchTerm) || searchTerm === '') {
						row.style.display = '';
					} else {
						row.style.display = 'none';
					}
				}
			});
		}

		// ==================== ОСТАЛЬНЫЕ ФУНКЦИИ (оставляем как есть с небольшими исправлениями) ====================

		function duplicateStudent(index) {
			const originalStudent = appData.students[index];
			const originalResults = [...appData.results[index]];
			
			const newStudent = `${originalStudent} (копия)`;
			appData.students.splice(index + 1, 0, newStudent);
			appData.results.splice(index + 1, 0, originalResults);
			
			saveData();
			
			renderStudents();
			renderResults();
			showNotification(`Создана копия учащегося`, "info");
		}

		function moveStudentUp(index) {
			if (index > 0) {
				moveStudent(index, index - 1);
			}
		}

		function moveStudentDown(index) {
			if (index < appData.students.length - 1) {
				moveStudent(index, index + 1);
			}
		}

		function moveStudent(fromIndex, toIndex) {
			if (fromIndex === toIndex) return;
			
			const student = appData.students[fromIndex];
			const result = appData.results[fromIndex];
			
			appData.students.splice(fromIndex, 1);
			appData.results.splice(fromIndex, 1);
			
			appData.students.splice(toIndex, 0, student);
			appData.results.splice(toIndex, 0, result);
			
			appData.errors = appData.errors.filter(error => error.studentIndex !== fromIndex);
			appData.errors.forEach(error => {
				if (error.studentIndex > fromIndex && error.studentIndex <= toIndex) {
					error.studentIndex--;
				} else if (error.studentIndex < fromIndex && error.studentIndex >= toIndex) {
					error.studentIndex++;
				}
			});
			
			saveData();
			renderStudents();
			renderResults();
			
			showNotification(`Учащийся перемещен на позицию ${toIndex + 1}`, "info");
		}

		function sortStudentsAlphabetically() {
			const studentsWithData = appData.students.map((student, index) => ({
				name: student,
				results: appData.results[index],
				originalIndex: index
			}));
			
			studentsWithData.sort((a, b) => a.name.localeCompare(b.name));
			
			appData.students = studentsWithData.map(item => item.name);
			appData.results = studentsWithData.map(item => item.results);
			
			saveData();
			renderStudents();
			showNotification("Список отсортирован по алфавиту", "info");
		}

		function randomizeOrder() {
			const studentsCopy = [...appData.students];
			const resultsCopy = [...appData.results];
			
			for (let i = studentsCopy.length - 1; i > 0; i--) {
				const j = Math.floor(Math.random() * (i + 1));
				[studentsCopy[i], studentsCopy[j]] = [studentsCopy[j], studentsCopy[i]];
				[resultsCopy[i], resultsCopy[j]] = [resultsCopy[j], resultsCopy[i]];
			}
			
			appData.students = studentsCopy;
			appData.results = resultsCopy;
			
			saveData();
			renderStudents();
			renderResults();
			showNotification("Порядок учащихся изменен случайным образом", "info");
		}

		function generateDefaultNames() {
			const names = [
				'Иванов Иван', 'Петрова Анна', 'Сидоров Алексей', 'Кузнецова Мария',
				'Смирнов Дмитрий', 'Попова Екатерина', 'Лебедев Михаил', 'Новикова Ольга',
				'Морозов Сергей', 'Волкова Наталья', 'Алексеев Андрей', 'Павлова Юлия'
			];
			
			appData.students = [];
			appData.results = [];
			
			for (let i = 0; i < Math.min(names.length, 12); i++) {
				appData.students.push(names[i]);
				appData.results.push(new Array(appData.tasks.length).fill(0));
			}
			
			for (let i = names.length; i < appData.test.presentStudents; i++) {
				appData.students.push(`Учащийся ${i + 1}`);
				appData.results.push(new Array(appData.tasks.length).fill(0));
			}
			
			saveData();
			renderStudents();
			renderResults();
			showNotification("Сгенерированы стандартные имена", "success");
		}

		function exportStudentsList() {
			const csvContent = appData.students
				.map((student, index) => `${index + 1},${student}`)
				.join('\n');
			
			const blob = new Blob(['№,ФИО учащегося\n' + csvContent], { type: 'text/csv;charset=utf-8;' });
			const link = document.createElement('a');
			const url = URL.createObjectURL(blob);
			
			link.setAttribute('href', url);
			link.setAttribute('download', `учащиеся_${new Date().toLocaleDateString('ru-RU').replace(/\./g, '-')}.csv`);
			link.style.visibility = 'hidden';
			
			document.body.appendChild(link);
			link.click();
			document.body.removeChild(link);
			
			showNotification("Список учащихся экспортирован в CSV", "success");
		}

		function editStudentInModal(index) {
			const student = appData.students[index];
			const newName = prompt('Редактировать ФИО учащегося:', student);
			
			if (newName !== null && newName.trim() !== '') {
				updateStudent(index, newName.trim());
				showNotification("ФИО учащегося обновлено", "success");
			}
		}
		// ==================== CSS СТИЛИ ====================
		const studentsStyles = `
			.students-controls-panel {
				background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
				color: white;
				padding: 20px;
				border-radius: 12px;
				margin-bottom: 20px;
				box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
			}
			
			.controls-header {
				display: flex;
				justify-content: space-between;
				align-items: center;
				margin-bottom: 15px;
			}
			
			.controls-toolbar {
				display: flex;
				flex-wrap: wrap;
				gap: 10px;
				margin-bottom: 15px;
				align-items: center;
			}
			
			.controls-search {
				position: relative;
				flex-grow: 1;
				max-width: 300px;
			}
			
			.controls-search input {
				padding-left: 35px;
			}
			
			.controls-search i {
				position: absolute;
				left: 12px;
				top: 50%;
				transform: translateY(-50%);
				color: #999;
			}
			
			.students-table-wrapper {
				background: white;
				border-radius: 8px;
				box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
				overflow: hidden;
				margin-bottom: 20px;
			}
			
			.students-table {
				width: 100%;
				border-collapse: collapse;
			}
			
			.students-table th {
				background: #f8f9fa;
				padding: 12px 15px;
				text-align: left;
				font-weight: 600;
				color: #495057;
				border-bottom: 2px solid #dee2e6;
				user-select: none;
			}
			
			.students-table td {
				padding: 12px 15px;
				border-bottom: 1px solid #e9ecef;
				transition: background-color 0.2s;
			}
			
			.students-table tr:hover td {
				background-color: #f8f9fa;
			}
			
			.students-table tr.dragging {
				opacity: 0.5;
				background: #e3f2fd;
			}
			
			.students-table tr.drag-over td {
				border-top: 2px solid #2196f3;
				border-bottom: 2px solid #2196f3;
			}
			
			.drag-handle {
				cursor: grab;
				color: #adb5bd;
				text-align: center;
				user-select: none;
			}
			
			.drag-handle:hover {
				color: #495057;
			}
			
			.student-name-editor {
				display: flex;
				flex-direction: column;
				gap: 5px;
			}
			
			.student-name-input {
				border: 1px solid #ced4da;
				transition: all 0.3s;
			}
			
			.student-name-input:focus {
				border-color: #80bdff;
				box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
			}
			
			.student-progress {
				display: flex;
				align-items: center;
				gap: 10px;
				font-size: 12px;
			}
			
			.progress-bar-bg {
				flex-grow: 1;
				height: 6px;
				background: #e9ecef;
				border-radius: 3px;
				overflow: hidden;
			}
			
			.progress-bar-fill {
				height: 100%;
				background: linear-gradient(90deg, #28a745, #20c997);
				transition: width 0.3s;
			}
			
			.student-actions {
				display: flex;
				gap: 5px;
				flex-wrap: nowrap;
			}
			
			.student-actions .btn-sm {
				padding: 2px 8px;
				font-size: 12px;
			}
			
			.quick-actions {
				background: #f8f9fa;
				padding: 15px;
				border-radius: 8px;
				border: 1px solid #dee2e6;
			}
			
			.quick-actions-header {
				margin-bottom: 10px;
			}
			
			.quick-actions-buttons {
				display: flex;
				flex-wrap: wrap;
				gap: 10px;
			}
			
			.students-pagination {
				text-align: center;
				padding: 10px;
				color: #6c757d;
				font-size: 14px;
			}
			
			@media (max-width: 768px) {
				.controls-toolbar {
					flex-direction: column;
					align-items: stretch;
				}
				
				.controls-search {
					max-width: 100%;
				}
				
				.student-actions {
					flex-wrap: wrap;
				}
				
				.students-table {
					display: block;
					overflow-x: auto;
				}
			}
		`;

		// Добавляем стили в DOM
		if (!document.querySelector('#students-styles')) {
			const styleSheet = document.createElement('style');
			styleSheet.id = 'students-styles';
			styleSheet.textContent = studentsStyles;
			document.head.appendChild(styleSheet);
		}

        // Обновление студента
        // Обновляем функцию updateStudent для моментального сохранения
		function updateStudent(index, value) {
			if (isDragging) return; // Не обновляем во время перетаскивания
			
			if (index >= 0 && index < appData.students.length) {
				appData.students[index] = value;
				saveData();
				
				// Обновляем прогресс в реальном времени
				updateStudentProgressBar(index);
			}
		}

		function updateStudentProgressBar(index) {
			const progressBar = document.querySelector(`#student-row-${index} .progress-bar-fill`);
			if (progressBar) {
				const studentResults = appData.results[index] || [];
				const completedTasks = studentResults.filter(score => score > 0).length;
				const totalTasks = appData.tasks.length;
				const progressPercentage = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0;
				
				// Находим элемент с прогресс-баром и обновляем его
				const progressFill = document.querySelector(`#student-row-${index} [style*="background: linear-gradient"]`);
				if (progressFill) {
					progressFill.style.width = `${progressPercentage}%`;
				}
				
				// Обновляем счетчик выполненных заданий
				const progressText = document.querySelector(`#student-row-${index} small`);
				if (progressText) {
					progressText.textContent = `${completedTasks}/${totalTasks}`;
				}
				
				// Обновляем статус
				const statusBadge = document.querySelector(`#student-row-${index} span[style*="background:"]`);
				if (statusBadge) {
					if (progressPercentage === 100) {
						statusBadge.style.background = '#d4edda';
						statusBadge.style.color = '#155724';
						statusBadge.textContent = 'Выполнено';
					} else if (progressPercentage > 0) {
						statusBadge.style.background = '#fff3cd';
						statusBadge.style.color = '#856404';
						statusBadge.textContent = 'Частично';
					} else {
						statusBadge.style.background = '#e9ecef';
						statusBadge.style.color = '#495057';
						statusBadge.textContent = 'Нет данных';
					}
				}
			}
		}

		// Функция для проверки и исправления данных
		function validateStudentData() {
			// Проверяем соответствие массивов студентов и результатов
			if (appData.students.length !== appData.results.length) {
				console.warn('Несоответствие количества студентов и результатов. Исправляю...');
				
				// Исправляем: добавляем пустые результаты для недостающих студентов
				while (appData.students.length > appData.results.length) {
					appData.results.push(new Array(appData.tasks.length).fill(0));
				}
				
				// Удаляем лишние результаты
				while (appData.students.length < appData.results.length) {
					appData.results.pop();
				}
				
				saveData();
				showNotification('Данные учащихся исправлены', 'warning');
			}
		}

		// Вызывать эту функцию при загрузке данных
		function onDataLoad() {
			validateStudentData();
		}

        // Функция для добавления нового учащегося
		function addStudent() {
			const newStudent = `Учащийся ${appData.students.length + 1}`;
			appData.students.push(newStudent);
			
			const emptyResults = new Array(appData.tasks.length).fill(0);
			appData.results.push(emptyResults);
			
			// Обновляем счетчик присутствующих
			appData.test.presentStudents = appData.students.length;
			if (document.getElementById('presentStudents')) {
				document.getElementById('presentStudents').value = appData.students.length;
			}
			
			saveData();
			renderStudents();
			renderResults();
			
			setTimeout(() => {
				const studentsContainer = document.getElementById('studentsContainer');
				const lastStudent = studentsContainer.querySelector('#studentsTableBody tr:last-child');
				if (lastStudent) {
					lastStudent.scrollIntoView({ behavior: 'smooth' });
				}
			}, 100);
			
			showNotification(`Добавлен новый учащийся: ${newStudent}`, "success");
		}

        // Функция для удаления учащегося
		function removeStudent(studentIndex) {
			if (appData.students.length <= 1) {
				showNotification("Нельзя удалить последнего учащегося!", "error");
				return;
			}
			
			if (studentIndex < 0 || studentIndex >= appData.students.length) {
				showNotification("Неверный индекс учащегося!", "error");
				return;
			}
			
			const studentName = appData.students[studentIndex];
			
			if (confirm(`Удалить учащегося "${studentName}"? Все его результаты будут удалены.`)) {
				// Удаляем студента
				appData.students.splice(studentIndex, 1);
				appData.results.splice(studentIndex, 1);
				
				// Обновляем ошибки
				// 1. Удаляем ошибки для удаленного студента
				appData.errors = appData.errors.filter(error => error.studentIndex !== studentIndex);
				
				// 2. Обновляем индексы для студентов после удаленного
				appData.errors.forEach(error => {
					if (error.studentIndex > studentIndex) {
						error.studentIndex--;
					}
				});
				
				// Обновляем счетчик присутствующих
				appData.test.presentStudents = Math.max(1, appData.students.length);
				if (document.getElementById('presentStudents')) {
					document.getElementById('presentStudents').value = appData.students.length;
				}
				
				saveData();
				renderStudents();
				renderResults();
				
				// Показываем уведомление
				showNotification(`Учащийся "${studentName}" удален!`, "success");
				
				// Если есть другие модальные окна или элементы, которые могут ссылаться на удаленного студента,
				// нужно их обновить
				updateAllStudentDependentElements();
			}
		}
		
		// Дополнительная функция для обновления всех элементов, зависящих от студентов
		function updateAllStudentDependentElements() {
			// Обновляем графики, если они есть
			if (typeof renderCharts === 'function') {
				renderCharts();
			}
			
			// Обновляем статистику, если есть такая функция
			if (typeof renderStatistics === 'function') {
				renderStatistics();
			}
			
			// Обновляем сводную таблицу
			if (typeof renderResults === 'function') {
				renderResults();
			}
		}
		
		function removeLastStudent() {
			if (appData.students.length <= 1) {
				showNotification("Нельзя удалить последнего учащегося!", "error");
				return;
			}
			
			const lastIndex = appData.students.length - 1;
			const studentName = appData.students[lastIndex];
			
			if (confirm(`Удалить последнего учащегося "${studentName}"? Все его результаты будут удалены.`)) {
				// Удаляем студента
				appData.students.pop();
				appData.results.pop();
				
				// Обновляем ошибки - удаляем все ошибки для этого студента
				appData.errors = appData.errors.filter(error => error.studentIndex !== lastIndex);
				// Ничего не декрементируем, так как удалили последнего
				
				// Обновляем счетчик присутствующих
				appData.test.presentStudents = Math.max(1, appData.students.length);
				if (document.getElementById('presentStudents')) {
					document.getElementById('presentStudents').value = appData.students.length;
				}
				
				saveData();
				renderStudents();
				renderResults();
				showNotification(`Учащийся "${studentName}" удален!`, "success");
			}
		}

        // Функция для установки точного количества учащихся
		function setStudentsCount(count) {
			if (count < 1 || count > 100) {
				showNotification("Количество учащихся должно быть от 1 до 100", "error");
				return;
			}
			
			const currentCount = appData.students.length;
			
			if (count > currentCount) {
				// Добавляем недостающих студентов
				for (let i = currentCount; i < count; i++) {
					appData.students.push(`Учащийся ${i + 1}`);
					appData.results.push(new Array(appData.tasks.length).fill(0));
				}
			} else if (count < currentCount) {
				// Удаляем лишних студентов
				if (confirm(`Удалить ${currentCount - count} последних учащихся? Все их результаты будут удалены.`)) {
					// Удаляем с конца
					const studentsToRemove = currentCount - count;
					appData.students.splice(count, studentsToRemove);
					appData.results.splice(count, studentsToRemove);
					
					// Обновляем ошибки - удаляем ошибки для удаленных студентов
					appData.errors = appData.errors.filter(error => error.studentIndex < count);
				} else {
					return; // Отмена удаления
				}
			}
			
			// Обновляем счетчик
			appData.test.presentStudents = count;
			if (document.getElementById('presentStudents')) {
				document.getElementById('presentStudents').value = count;
			}
			
			saveData();
			renderStudents();
			renderResults();
			
			showNotification(`Установлено ${count} учащихся`, "success");
		}

        // Диалог для быстрой установки количества
        function showQuickSetDialog() {
            const count = prompt('Введите количество учащихся:', appData.students.length);
            if (count !== null) {
                const numCount = parseInt(count);
                if (!isNaN(numCount) && numCount > 0) {
                    setStudentsCount(numCount);
                } else {
                    showNotification('Введите корректное число!', "error");
                }
            }
        }

        // Диалог для массового импорта
        function showMassImportDialog() {
            const namesText = prompt(`Введите список учащихся (каждое имя с новой строки):\n\nПример:\nИванов Алексей\nПетрова Мария\nСидоров Дмитрий`, appData.students.join('\n'));
            
            if (namesText !== null) {
                const names = namesText.split('\n')
                    .map(name => name.trim())
                    .filter(name => name.length > 0);
                
                if (names.length > 0) {
                    generateStudents(names);
                } else {
                    showNotification('Не найдено имен учащихся!', "error");
                }
            }
        }

        // Функция для массового создания учащихся
        function generateStudents(names) {
            if (!names || names.length === 0) {
                showNotification("Введите список имен учащихся!", "error");
                return;
            }
            
            appData.students = [];
            appData.results = [];
            appData.errors = [];
            
            names.forEach((name, index) => {
                appData.students.push(name.trim());
                appData.results.push(new Array(appData.tasks.length).fill(0));
            });
            
            appData.test.presentStudents = names.length;
            document.getElementById('presentStudents').value = names.length;
            
            saveData();
            renderStudents();
            renderResults();
            showNotification(`Создано ${names.length} учащихся!`, "success");
        }

        // Сохранение студентов
        function saveStudents() {
            saveData();
            showNotification("Список учащихся сохранен!", "success");
        }



        // Добавление ошибки
        function addError() {
            const studentIndex = parseInt(document.getElementById('errorStudent').value);
            const taskIndex = parseInt(document.getElementById('errorTask').value);
            const type = document.getElementById('errorType').value;
            const description = document.getElementById('errorDescription').value;
            
            if (!description) {
                showNotification("Введите описание ошибки!", "error");
                return;
            }
            
            appData.errors.push({
                studentIndex,
                taskIndex,
                type,
                description,
                count: 1
            });
            
            saveData();
            renderResults();
            document.getElementById('errorDescription').value = '';
            showNotification("Ошибка добавлена", "success");
        }

        // Обновление результата
        function updateResult(studentIndex, taskIndex, value) {
			if (!appData.results[studentIndex]) {
				appData.results[studentIndex] = [];
			}
			
			// Жесткое приведение к числу
			let numValue = parseInt(value);
			
			// Валидация: не меньше 0, не больше макс. балла
			const maxScore = appData.tasks[taskIndex].maxScore;
			if (isNaN(numValue)) numValue = 0;
			if (numValue < 0) numValue = 0;
			if (numValue > maxScore) {
				numValue = maxScore;
				showNotification(`Максимальный балл за это задание: ${maxScore}`, 'warning');
			}

			appData.results[studentIndex][taskIndex] = numValue;
			
			saveData();
			// Перерисовка всей таблицы может быть тяжелой, лучше обновить только итог
			// Но для надежности пока оставим renderResults()
			renderResults();
        }

        // Сохранение результатов
        function saveResults() {
            saveData();
            showNotification("Результаты сохранены!", "success");
        }

        // Расчет оценки
		function calculateGrade(totalScore) {
			// 1. Защита от типов
			const score = parseFloat(totalScore) || 0;
			
			// 2. Получаем текущие настройки
			const type = appData.test.criteriaType || 'points';
			const criteria = appData.test.criteria;
			const maxPossible = appData.tasks.reduce((sum, task) => sum + (parseFloat(task.maxScore) || 0), 0);

			if (!criteria) return 2; // Fallback

			// 3. Расчет для процентов
			if (type === 'percentage' || type === 'percent') { // Обработка разных названий в коде
				const percentage = maxPossible > 0 ? (score / maxPossible) * 100 : 0;
				
				// Проходим по всем уровням критериев (1-10 или 2-5)
				for (const [level, range] of Object.entries(criteria)) {
					if (percentage >= range.min && percentage <= range.max) {
						// Возвращаем ключ уровня (например "5" или "high")
						// Если ключ числовой, возвращаем число
						return isNaN(parseInt(level)) ? level : parseInt(level);
					}
				}
				return 2; // Default low grade
			}
			
			// 4. Расчет для баллов (points)
			else {
				for (const [level, range] of Object.entries(criteria)) {
					if (score >= range.min && score <= range.max) {
						return isNaN(parseInt(level)) ? level : parseInt(level);
					}
				}
			}

			// Если не попали ни в один диапазон (например, 0 баллов)
			return 2;
		}


        // Синхронизация количества учащихся
        function syncStudentsCount() {
            const currentCount = appData.students.length;
            document.getElementById('presentStudents').value = currentCount;
            appData.test.presentStudents = currentCount;
            saveData();
            showNotification(`Количество учащихся синхронизировано: ${currentCount}`, "success");
        }

        // ==================== АНАЛИТИКА ====================

		// Обновляем функцию updateAnalytics()
		function updateAnalytics() {
			try {
				// ВСЕ ФУНКЦИИ В БЛОКЕ try-catch
				updateKPIDashboard();
				updateTaxonomyAnalysis();
				updateErrorsAnalysis();
				updatePersonalAnalysis();
				showSmartRecommendations();
				
				// Проверяем тип работы
				const workType = safeGet(appData, 'test.workType', 'current');
				
				switch(workType) {
					case 'vpr':
						updateVPRAnalysis();
						break;
					case 'func_literacy':
						updateLiteracyAnalysis();
						break;
					case 'oge':
					case 'ege':
						updateGIAnalysis();
						break;
					case 'final':
						updateFinalAnalysis();
						break;
					case 'milestone':
						updateMilestoneAnalysis();
						break;
					case 'current':
						updateCurrentAnalysis();
						break;
					case 'diagnostic':
						updateDiagnosticAnalysis();
						break;
					case 'psychology':
					updatePsychologyAnalysis();
					break;
					default:
						document.getElementById('specializedAnalysis').innerHTML = 
							'<p>Специализированный анализ не предусмотрен для данного типа работы</p>';
				}
			} catch (error) {
				console.error('Критическая ошибка в updateAnalytics:', error);
				document.getElementById('specializedAnalysis').innerHTML = 
					`<div class="alert alert-danger">
						<p>Ошибка при обновлении аналитики: ${error.message}</p>
						<button class="btn btn-sm" onclick="location.reload()">Перезагрузить</button>
					</div>`;
			}
		}

        // KPI дашборд
        function updateKPIDashboard() {
            if (appData.results.length === 0) {
                document.getElementById('kpiDashboard').innerHTML = '<p>Нет данных для анализа</p>';
                return;
            }
            
            const totalScores = appData.results.map(scores => scores.reduce((sum, score) => sum + score, 0));
            const grades = totalScores.map(score => calculateGrade(score));
            const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0);
            
            const avgScore = totalScores.reduce((sum, score) => sum + score, 0) / totalScores.length;
            const successRate = (grades.filter(grade => grade >= 3).length / grades.length * 100);
            const qualityRate = (grades.filter(grade => grade >= 4).length / grades.length * 100);
            const completionRate = (totalScores.reduce((sum, score) => sum + score, 0) / (maxPossible * totalScores.length)) * 100;
            
            const sou = (grades.filter(g => g >= 3).length / grades.length * 100);
            
            const gradeCounts = {5: 0, 4: 0, 3: 0, 2: 0};
            grades.forEach(grade => gradeCounts[grade]++);
            const mode = Object.keys(gradeCounts).reduce((a, b) => gradeCounts[a] > gradeCounts[b] ? a : b);
            const median = calculateMedian(totalScores);
            
            const stdDev = Math.sqrt(totalScores.reduce((sum, score) => sum + Math.pow(score - avgScore, 2), 0) / totalScores.length);
            
            document.getElementById('kpiDashboard').innerHTML = `
                <div class="kpi-card">
                    <div class="kpi-value">${avgScore.toFixed(1)}</div>
                    <div class="kpi-label">Средний балл</div>
                </div>
                <div class="kpi-card">
                    <div class="kpi-value">${successRate.toFixed(1)}%</div>
                    <div class="kpi-label">Успеваемость</div>
                </div>
                <div class="kpi-card">
                    <div class="kpi-value">${qualityRate.toFixed(1)}%</div>
                    <div class="kpi-label">Качество знаний</div>
                </div>
                <div class="kpi-card">
                    <div class="kpi-value">${sou.toFixed(1)}%</div>
                    <div class="kpi-label">СОУ</div>
                </div>
                <div class="kpi-card">
                    <div class="kpi-value">${completionRate.toFixed(1)}%</div>
                    <div class="kpi-label">Общее выполнение</div>
                </div>
                <div class="kpi-card">
                    <div class="kpi-value">${stdDev.toFixed(2)}</div>
                    <div class="kpi-label">Станд. отклонение</div>
                </div>
                <div class="kpi-card">
                    <div class="kpi-value">${mode}</div>
                    <div class="kpi-label">Мода оценок</div>
                </div>
                <div class="kpi-card">
                    <div class="kpi-value">${median.toFixed(1)}</div>
                    <div class="kpi-label">Медиана баллов</div>
                </div>
            `;
        }

		// ГЛОБАЛЬНЫЙ ОБРАБОТЧИК ОШИБОК
		window.addEventListener('error', function(event) {
			console.error('Глобальная ошибка:', event.error);
			
			// Показываем пользователю сообщение об ошибке
			if (event.error.message && event.error.message.includes('Cannot read properties')) {
				showNotification('Обнаружена ошибка в данных. Попробуйте перезагрузить страницу.', 'error');
			}
			
			// Предотвращаем стандартное поведение ошибки
			event.preventDefault();
		});

		// ОБРАБОТЧИК ДЛЯ PROMISE ОШИБОК
		window.addEventListener('unhandledrejection', function(event) {
			console.error('Необработанная ошибка Promise:', event.reason);
			showNotification('Произошла ошибка при выполнении операции', 'error');
		});

		// ФУНКЦИЯ ДЛЯ ИНИЦИАЛИЗАЦИИ ДАННЫХ ПО УМОЛЧАНИЮ
		function initializeDefaultData() {
			try {
				// Проверяем и инициализируем appData если он пустой
				if (!appData) {
					appData = {
						test: {},
						tasks: [],
						students: [],
						results: [],
						errors: []
					};
				}
				
				// Убеждаемся, что все свойства существуют
				appData.test = appData.test || {};
				appData.tasks = appData.tasks || [];
				appData.students = appData.students || [];
				appData.results = appData.results || [];
				appData.errors = appData.errors || [];
				
				// Инициализируем критерии если их нет
				if (!appData.test.criteria) {
					appData.test.criteria = {
						5: { min: 18, max: 20 },
						4: { min: 15, max: 17 },
						3: { min: 10, max: 14 },
						2: { min: 0, max: 9 }
					};
				}
				
				saveData(); // Сохраняем исправленные данные
				
			} catch (error) {
				console.error('Ошибка инициализации данных:', error);
			}
		}

		// ==================== ЕДИНАЯ СИСТЕМА ЭКСПОРТА/ИМПОРТА ====================
		function exportAppData(format = 'json') {
			try {
				// Создаем копию данных
				const exportData = {
					version: '2.0',
					timestamp: new Date().toISOString(),
					appData: JSON.parse(JSON.stringify(appData)),
					metadata: {
						testCount: appData.tasks.length,
						studentCount: appData.students.length,
						errorCount: appData.errors.length,
						avgScore: calculateAverageScore().toFixed(2)
					}
				};
				
				const dataStr = JSON.stringify(exportData, null, 2);
				
				if (format === 'json') {
					// Создаем и скачиваем файл
					const blob = new Blob([dataStr], { type: 'application/json' });
					const url = URL.createObjectURL(blob);
					const a = document.createElement('a');
					a.href = url;
					a.download = `анализ_${appData.test.subject || 'данные'}_${new Date().toISOString().slice(0, 10)}.json`;
					a.click();
					URL.revokeObjectURL(url);
					
					showNotification('Данные экспортированы в JSON', 'success');
					return true;
				}
				
				return false;
				
			} catch (error) {
				console.error('Ошибка экспорта:', error);
				showNotification('Ошибка экспорта данных', 'error');
				return false;
			}
		}

		function importAppData(jsonString) {
			try {
				const importedData = JSON.parse(jsonString);
				
				// Проверяем версию и структуру
				if (!importedData.appData) {
					throw new Error('Некорректный формат данных');
				}
				
				// Создаем резервную копию
				createBackup();
				
				// Обновляем данные
				Object.assign(appData, importedData.appData);
				
				// Инициализируем недостающие поля
				initializeAppData();
				
				// Сохраняем
				saveData();
				renderAll();
				
				showNotification('Данные успешно импортированы', 'success');
				return true;
				
			} catch (error) {
				console.error('Ошибка импорта:', error);
				showNotification('Ошибка импорта данных. Проверьте формат файла.', 'error');
				return false;
			}
		}

		function handleFileImport(event) {
			const file = event.target.files[0];
			if (!file) return;
			
			const reader = new FileReader();
			reader.onload = function(e) {
				if (confirm('Импортировать данные из файла? Текущие данные будут заменены.')) {
					importAppData(e.target.result);
				}
			};
			reader.readAsText(file);
			
			// Сбрасываем input
			event.target.value = '';
		}
		
		// ==================== НАДЕЖНАЯ ИНИЦИАЛИЗАЦИЯ ДАННЫХ ====================
		function initializeAppData() {
			try {
				// Проверяем существование appData
				if (!window.appData) {
					window.appData = {
						test: {},
						tasks: [],
						students: [],
						results: [],
						errors: [],
						psychologyFeatures: []
					};
				}
				
				// Инициализируем обязательные поля теста
				const defaultTest = {
					subject: "",
					class: "",
					testDate: new Date().toISOString().split('T')[0],
					theme: "",
					goals: "",
					workType: "current",
					workFormat: "mixed",
					timeLimit: 45,
					totalStudents: 25,
					presentStudents: 23,
					absentReason: "",
					criteria: {
						5: { min: 18, max: 20 },
						4: { min: 15, max: 17 },
						3: { min: 10, max: 14 },
						2: { min: 0, max: 9 }
					},
					criteriaType: 'points',
					criteriaSystem: 'standard',
					customCriteria: [],
					criteriaCount: 4,
					criteriaScale: '2-5'
				};
				
				// Объединяем с существующими данными
				appData.test = { ...defaultTest, ...(appData.test || {}) };
				
				// Убеждаемся, что все массивы существуют
				appData.tasks = appData.tasks || [];
				appData.students = appData.students || [];
				appData.results = appData.results || [];
				appData.errors = appData.errors || [];
				appData.psychologyFeatures = appData.psychologyFeatures || [];
				
				console.log('Данные успешно инициализированы');
				return true;
				
			} catch (error) {
				console.error('Ошибка инициализации данных:', error);
				// Создаем минимальную структуру при критической ошибке
				window.appData = {
					test: {
						subject: "Новый тест",
						class: "5А",
						testDate: new Date().toISOString().split('T')[0],
						criteria: {
							5: { min: 18, max: 20 },
							4: { min: 15, max: 17 },
							3: { min: 10, max: 14 },
							2: { min: 0, max: 9 }
						}
					},
					tasks: [],
					students: [],
					results: [],
					errors: [],
					psychologyFeatures: []
				};
				return false;
			}
		}		
		
		// ОБНОВЛЯЕМ ИНИЦИАЛИЗАЦИЮ ПРИ ЗАГРУЗКЕ
		document.addEventListener('DOMContentLoaded', function() {
			try {
				// Инициализируем данные
				initializeAppData();
				
				// Загружаем сохраненные данные
				loadData();
				loadSchoolData();
				validateStudentData();
				onDataLoad();
				// Проверяем целостность данных
				if (appData.tasks.length === 0 || appData.students.length === 0) {
					console.log('Загружаем пример данных...');
					loadSampleData();
				} else {
					console.log('Восстанавливаем сохраненные данные...');
					renderAll();
				}
				
				// Показываем первую вкладку
				showTab('setup');
				
				// Добавляем глобальный обработчик ошибок
				window.addEventListener('error', function(event) {
					console.error('Глобальная ошибка:', event.error);
					showNotification('Обнаружена ошибка в системе', 'error');
				});
				
				// Обработчик ошибок Promise
				window.addEventListener('unhandledrejection', function(event) {
					console.error('Необработанная ошибка Promise:', event.reason);
					showNotification('Ошибка выполнения операции', 'error');
				});
				
				console.log('? Система успешно инициализирована');
				
			} catch (error) {
				console.error('? Критическая ошибка при загрузке:', error);
				
				// Пытаемся восстановить
				try {
					localStorage.removeItem('testAnalyticsData');
					initializeAppData();
					loadSampleData();
					showNotification('Система восстановлена после сбоя', 'warning');
				} catch (recoveryError) {
					console.error('Не удалось восстановить:', recoveryError);
					alert('Критическая ошибка системы. Пожалуйста, обновите страницу.');
				}
			}
		});

		// Экспорт как HTML отчет с возможностью печати
		async function exportChartsAsHTML() {
			closeExportMenu();
			
			try {
				showNotification('Создаем HTML отчет...', 'info');
				
				// Создаем модальное окно для отчета
				const modal = document.createElement('div');
				modal.className = 'modal fade show d-block';
				modal.style.backgroundColor = 'rgba(0,0,0,0.5)';
				modal.innerHTML = `
					<div class="modal-dialog modal-xl modal-dialog-scrollable">
						<div class="modal-content">
							<div class="modal-header bg-primary text-white">
								<h5 class="modal-title">
									<i class="fas fa-chart-bar me-2"></i>Аналитический отчет
								</h5>
								<button type="button" class="btn-close btn-close-white" onclick="closeReportModal()"></button>
							</div>
							<div class="modal-body p-4" id="reportContent">
								<!-- Контент отчета будет здесь -->
								<div class="text-center py-5">
									<div class="spinner-border text-primary" role="status">
										<span class="visually-hidden">Загрузка...</span>
									</div>
									<p class="mt-3">Формируем отчет...</p>
								</div>
							</div>
							<div class="modal-footer">
								<button type="button" class="btn btn-secondary" onclick="closeReportModal()">
									<i class="fas fa-times me-2"></i>Закрыть
								</button>
								<button type="button" class="btn btn-success" onclick="exportReport('html')">
									<i class="fas fa-print me-2"></i>Печать
								</button>
								<button type="button" class="btn btn-primary" onclick="saveReportAsPDF()">
									<i class="fas fa-file-pdf me-2"></i>Сохранить как PDF
								</button>
							</div>
						</div>
					</div>
				`;
				
				document.body.appendChild(modal);
				
				// Ждем загрузки библиотек
				await loadReportLibraries();
				
				// Генерируем контент отчета
				await generateReportContent();
				addExportButtons();
				
			} catch (error) {
				console.error('Ошибка создания отчета:', error);
				showNotification('Ошибка создания отчета', 'error');
				closeReportModal();
			}
		}


		// Основная функция печати и экспорта
		function exportReport(type = 'print') {
			const reportContent = document.getElementById('reportContent');
			if (!reportContent) {
				showNotification('Отчет не найден', 'error');
				return;
			}

			if (type === 'html') {
				exportToHTML();
				return;
			}
			
			if (type === 'docx') {
				exportToDOCX();
				return;
			}
			
			// Для печати
			printReport();
		}

		// Функция печати
		async function printReport() {
			const reportContent = document.getElementById('reportContent');
			if (!reportContent) return;
			
			try {
				showNotification('Подготовка отчета к печати...', 'info');
				
				// Сохраняем оригинальное состояние
				const originalHtml = reportContent.innerHTML;
				const originalDisplay = reportContent.style.display;
				
				// Скрываем оригинальный контент
				reportContent.style.display = 'none';
				
				// Создаем контейнер для печати
				const printContainer = document.createElement('div');
				printContainer.id = 'printContainer';
				printContainer.style.cssText = `
					position: fixed;
					left: -10000px;
					top: 0;
					width: 210mm;
					min-height: 100%;
					background: white;
					z-index: 99999;
					padding: 15mm;
					box-sizing: border-box;
					font-family: 'Arial', sans-serif;
					font-size: 11pt;
					line-height: 1.4;
					color: #000 !important;
					visibility: hidden;
				`;
				
				// Получаем данные canvas и конвертируем в изображения с высоким качеством
				const canvasPromises = [];
				const canvases = reportContent.querySelectorAll('canvas');
				
				canvases.forEach((canvas, index) => {
					const promise = new Promise((resolve) => {
						try {
							// Для Chart.js
							if (canvas.chart && typeof canvas.chart.toBase64Image === 'function') {
								// Сохраняем текущие размеры
								const originalWidth = canvas.width;
								const originalHeight = canvas.height;
								
								// Временно увеличиваем размер для лучшего качества
								canvas.width = originalWidth * 3;
								canvas.height = originalHeight * 3;
								canvas.chart.resize();
								
								const dataUrl = canvas.chart.toBase64Image();
								
								// Восстанавливаем размеры
								canvas.width = originalWidth;
								canvas.height = originalHeight;
								canvas.chart.resize();
								
								resolve({
									index: index,
									dataUrl: dataUrl,
									type: 'chartjs'
								});
							} else {
								// Обычный canvas
								const tempCanvas = document.createElement('canvas');
								const ctx = tempCanvas.getContext('2d');
								
								// Увеличиваем в 3 раза для лучшего качества
								tempCanvas.width = canvas.width * 3;
								tempCanvas.height = canvas.height * 3;
								
								// Масштабируем и рисуем с высоким качеством
								ctx.scale(3, 3);
								ctx.drawImage(canvas, 0, 0);
								
								const dataUrl = tempCanvas.toDataURL('image/png', 1.0);
								resolve({
									index: index,
									dataUrl: dataUrl,
									type: 'canvas'
								});
							}
						} catch (error) {
							console.warn('Ошибка при обработке canvas:', error);
							resolve(null);
						}
					});
					canvasPromises.push(promise);
				});
				
				// Ждем обработки всех canvas
				const canvasResults = await Promise.all(canvasPromises);
				
				// Клонируем контент
				const contentClone = reportContent.cloneNode(true);
				
				// Заменяем canvas на изображения
				canvasResults.forEach(result => {
					if (result && result.dataUrl) {
						const canvas = contentClone.querySelectorAll('canvas')[result.index];
						if (canvas) {
							const img = document.createElement('img');
							img.src = result.dataUrl;
							img.style.width = '100%';
							img.style.maxWidth = '100%';
							img.style.height = 'auto';
							img.style.display = 'block';
							img.style.margin = '10px 0';
							img.alt = 'График';
							img.style.pageBreakInside = 'avoid';
							img.style.breakInside = 'avoid';
							
							// Сохраняем размер если есть
							if (canvas.style.width) img.style.width = canvas.style.width;
							if (canvas.style.height) img.style.height = canvas.style.height;
							
							canvas.parentNode.replaceChild(img, canvas);
						}
					}
				});
				
				// Удаляем ненужные элементы
				const elementsToRemove = contentClone.querySelectorAll(
					'.btn, .no-print, .modal-footer, .spinner-border, .alert:not(.print-show), ' +
					'button, .navbar, .sidebar, .dropdown, .tooltip, .popover'
				);
				elementsToRemove.forEach(el => el.remove());
				
				// Исправляем оценки (1 становится 2)
				const fixGrades = (text) => {
					return text.replace(/\b1\b/g, '2');
				};
				
				// Обрабатываем текстовые узлы
				const walker = document.createTreeWalker(contentClone, NodeFilter.SHOW_TEXT, null, false);
				let node;
				while (node = walker.nextNode()) {
					if (node.nodeType === Node.TEXT_NODE && node.textContent.trim()) {
						node.textContent = fixGrades(node.textContent);
					}
				}
				
				// Создаем структуру отчета
				const reportSections = [];
				
				// Разбиваем контент на логические секции для многостраничности
				const sections = contentClone.querySelectorAll('.card, .section, table, .chart-container');
				
				let currentSection = [];
				let currentHeight = 0;
				const maxPageHeight = 250; // мм (примерно для A4 с учетом отступов)
				
				sections.forEach((section, index) => {
					// Простая оценка высоты (можно улучшить)
					const estimatedHeight = section.tagName === 'TABLE' ? 100 : 
										  section.classList.contains('chart-container') ? 120 : 80;
					
					if (currentHeight + estimatedHeight > maxPageHeight && currentSection.length > 0) {
						reportSections.push(currentSection);
						currentSection = [section];
						currentHeight = estimatedHeight;
					} else {
						currentSection.push(section);
						currentHeight += estimatedHeight;
					}
				});
				
				if (currentSection.length > 0) {
					reportSections.push(currentSection);
				}
				
				// Создаем HTML для печати
				let printHTML = `
					<!DOCTYPE html>
					<html lang="ru">
					<head>
						<meta charset="UTF-8">
						<meta name="viewport" content="width=device-width, initial-scale=1.0">
						<title>Аналитический отчет</title>
						<style>
							@page {
								margin: 15mm;
								size: A4 portrait;
							}
							
							@media print {
								body {
									font-family: 'Arial', sans-serif;
									font-size: 11pt;
									line-height: 1.4;
									color: #000 !important;
									background: white !important;
									margin: 0;
									padding: 0;
								}
								
								.print-page {
									width: 210mm;
									min-height: 297mm;
									padding: 15mm;
									box-sizing: border-box;
									page-break-after: always;
									position: relative;
								}
								
								.print-page:last-child {
									page-break-after: auto;
								}
								
								.print-header {
									text-align: center;
									margin-bottom: 20mm;
									border-bottom: 2px solid #000;
									padding-bottom: 5mm;
								}
								
								.print-header h1 {
									font-size: 18pt;
									margin: 0 0 3mm 0;
									font-weight: bold;
								}
								
								.print-header .subtitle {
									font-size: 12pt;
									margin: 2mm 0;
								}
								
								.print-footer {
									position: fixed;
									bottom: 0;
									left: 0;
									width: 100%;
									text-align: center;
									font-size: 9pt;
									color: #666;
									padding: 5mm;
									border-top: 1px solid #ddd;
								}
								
								.section {
									margin-bottom: 10mm;
									page-break-inside: avoid;
								}
								
								.card {
									border: 1px solid #000;
									border-radius: 3mm;
									margin-bottom: 5mm;
									page-break-inside: avoid;
									overflow: hidden;
								}
								
								.card-header {
									background: #f5f5f5;
									padding: 3mm;
									border-bottom: 1px solid #000;
									font-weight: bold;
								}
								
								.card-body {
									padding: 3mm;
								}
								
								table {
									width: 100%;
									border-collapse: collapse;
									margin: 3mm 0;
									page-break-inside: avoid;
									font-size: 10pt;
								}
								
								th, td {
									border: 1px solid #000;
									padding: 2mm;
									text-align: left;
								}
								
								th {
									background: #f5f5f5;
									font-weight: bold;
								}
								
								img {
									max-width: 100%;
									height: auto;
									display: block;
									margin: 2mm auto;
									page-break-inside: avoid;
								}
								
								.progress {
									height: 4mm;
									background: #eee;
									border-radius: 2mm;
									overflow: hidden;
									margin: 2mm 0;
								}
								
								.progress-bar {
									height: 100%;
									background: #007bff;
								}
								
								.no-print, .btn, button {
									display: none !important;
								}
								
								/* Стили для цветной печати */
								.print-color * {
									-webkit-print-color-adjust: exact;
									print-color-adjust: exact;
								}
								
								.text-primary { color: #007bff !important; }
								.text-success { color: #28a745 !important; }
								.text-warning { color: #ffc107 !important; }
								.text-danger { color: #dc3545 !important; }
								.text-info { color: #17a2b8 !important; }
								
								.bg-primary { background-color: #007bff !important; color: white !important; }
								.bg-success { background-color: #28a745 !important; color: white !important; }
								.bg-warning { background-color: #ffc107 !important; color: #000 !important; }
								.bg-danger { background-color: #dc3545 !important; color: white !important; }
								.bg-info { background-color: #17a2b8 !important; color: white !important; }
							}
							
							@media screen {
								body {
									background: #f0f0f0;
									padding: 20px;
								}
								
								.print-page {
									background: white;
									margin: 0 auto 20px;
									box-shadow: 0 0 20px rgba(0,0,0,0.1);
									min-height: auto;
								}
							}
						</style>
					</head>
					<body>
				`;
				
				// Добавляем страницы
				reportSections.forEach((sections, pageIndex) => {
					printHTML += `
						<div class="print-page">
							<div class="print-header">
								<h1>Аналитический отчет</h1>
								<div class="subtitle">${document.title || 'Отчет'}</div>
								<div>Страница ${pageIndex + 1} из ${reportSections.length}</div>
								<div>Дата: ${new Date().toLocaleDateString('ru-RU')}</div>
							</div>
							
							<div class="print-content">
					`;
					
					sections.forEach(section => {
						printHTML += `<div class="section">${section.outerHTML}</div>`;
					});
					
					printHTML += `
							</div>
							
							<div class="print-footer">
								Отчет сгенерирован системой • Страница ${pageIndex + 1} из ${reportSections.length}
							</div>
						</div>
					`;
				});
				
				printHTML += `
						</body>
						</html>
					`;
				
				// Открываем в новом окне для печати
				const printWindow = window.open('', '_blank');
				if (printWindow) {
					printWindow.document.write(printHTML);
					printWindow.document.close();
					
					// Даем время на загрузку изображений
					setTimeout(() => {
						printWindow.focus();
						
						// Показываем диалог выбора типа печати
						const printDialog = `
							<div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
									   background: white; padding: 30px; border-radius: 10px; box-shadow: 0 0 30px rgba(0,0,0,0.3);
									   z-index: 100000; text-align: center;">
								<h3 style="margin-bottom: 20px;">Выберите тип печати</h3>
								<div style="display: flex; gap: 15px; justify-content: center; margin-bottom: 20px;">
									<button onclick="window.print(); this.parentNode.parentNode.style.display=\'none\';" 
											style="padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 5px; cursor: pointer;">
										?? Печать
									</button>
									<button onclick="window.close();" 
											style="padding: 10px 20px; background: #dc3545; color: white; border: none; border-radius: 5px; cursor: pointer;">
										? Отмена
									</button>
								</div>
								<div style="display: flex; gap: 10px; justify-content: center;">
									<button onclick="document.body.classList.add(\'print-color\'); window.print(); this.parentNode.parentNode.style.display=\'none\';" 
											style="padding: 8px 15px; background: linear-gradient(45deg, #FF6B6B, #4ECDC4); color: white; border: none; border-radius: 5px; cursor: pointer;">
										?? Цветная
									</button>
									<button onclick="document.body.classList.remove(\'print-color\'); window.print(); this.parentNode.parentNode.style.display=\'none\';" 
											style="padding: 8px 15px; background: #333; color: white; border: none; border-radius: 5px; cursor: pointer;">
										? Ч/Б
									</button>
								</div>
							</div>
						`;
						
						printWindow.document.body.insertAdjacentHTML('beforeend', printDialog);
						
					}, 1000);
					
					// Восстанавливаем оригинальный контент
					reportContent.style.display = originalDisplay;
					
				} else {
					showNotification('Разрешите всплывающие окна для печати', 'warning');
					reportContent.style.display = originalDisplay;
				}
				
			} catch (error) {
				console.error('Ошибка печати:', error);
				showNotification('Ошибка при печати', 'error');
			}
		}

		// Экспорт в HTML
		async function exportToHTML() {
			const reportContent = document.getElementById('reportContent');
			if (!reportContent) return;
			
			try {
				showNotification('Подготовка HTML экспорта...', 'info');
				
				// Клонируем контент
				const contentClone = reportContent.cloneNode(true);
				
				// Обрабатываем canvas
				const canvasPromises = [];
				const canvases = contentClone.querySelectorAll('canvas');
				
				canvases.forEach((canvas, index) => {
					const promise = new Promise((resolve) => {
						try {
							if (canvas.chart && typeof canvas.chart.toBase64Image === 'function') {
								// Увеличиваем качество для Chart.js
								const originalWidth = canvas.width;
								const originalHeight = canvas.height;
								canvas.width = originalWidth * 2;
								canvas.height = originalHeight * 2;
								canvas.chart.resize();
								
								const dataUrl = canvas.chart.toBase64Image();
								
								canvas.width = originalWidth;
								canvas.height = originalHeight;
								canvas.chart.resize();
								
								resolve({ canvas, dataUrl });
							} else {
								const dataUrl = canvas.toDataURL('image/png', 1.0);
								resolve({ canvas, dataUrl });
							}
						} catch (error) {
							resolve(null);
						}
					});
					canvasPromises.push(promise);
				});
				
				const canvasResults = await Promise.all(canvasPromises);
				
				// Заменяем canvas на изображения
				canvasResults.forEach(result => {
					if (result && result.dataUrl) {
						const img = document.createElement('img');
						img.src = result.dataUrl;
						img.style.width = '100%';
						img.style.maxWidth = '100%';
						img.style.height = 'auto';
						result.canvas.parentNode.replaceChild(img, result.canvas);
					}
				});
				
				// Удаляем ненужные элементы
				const elementsToRemove = contentClone.querySelectorAll(
					'.btn, .no-export, .modal-footer, .spinner-border, button, .navbar, .sidebar'
				);
				elementsToRemove.forEach(el => el.remove());
				
				// Исправляем оценки
				const fixGrades = (text) => text.replace(/\b1\b/g, '2');
				
				const walker = document.createTreeWalker(contentClone, NodeFilter.SHOW_TEXT, null, false);
				let node;
				while (node = walker.nextNode()) {
					if (node.nodeType === Node.TEXT_NODE && node.textContent.trim()) {
						node.textContent = fixGrades(node.textContent);
					}
				}
				
				// Создаем HTML документ
				const htmlContent = `
					<!DOCTYPE html>
					<html lang="ru">
					<head>
						<meta charset="UTF-8">
						<meta name="viewport" content="width=device-width, initial-scale=1.0">
						<title>${document.title || 'Аналитический отчет'}</title>
						<link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.1.3/css/bootstrap.min.css" rel="stylesheet">
						<style>
							body {
								font-family: Arial, sans-serif;
								padding: 20px;
								max-width: 1200px;
								margin: 0 auto;
							}
							.report-header {
								text-align: center;
								margin-bottom: 30px;
								padding-bottom: 20px;
								border-bottom: 2px solid #007bff;
							}
							.card {
								margin-bottom: 20px;
								box-shadow: 0 2px 10px rgba(0,0,0,0.1);
							}
							img {
								max-width: 100%;
								height: auto;
							}
							table {
								width: 100%;
								margin-bottom: 20px;
							}
							.export-info {
								text-align: center;
								margin-top: 40px;
								padding-top: 20px;
								border-top: 1px solid #ddd;
								color: #666;
								font-size: 12px;
							}
						</style>
					</head>
					<body>
						<div class="report-header">
							<h1>Аналитический отчет</h1>
							<h3>${document.title || ''}</h3>
							<p>Экспортировано: ${new Date().toLocaleDateString('ru-RU')} ${new Date().toLocaleTimeString('ru-RU')}</p>
						</div>
						
						<div class="report-content">
							${contentClone.innerHTML}
						</div>
						
						<div class="export-info">
							<p>Отчет экспортирован из системы аналитики</p>
							<p>© ${new Date().getFullYear()}</p>
						</div>
					</body>
					</html>
				`;
				
				// Создаем и скачиваем файл
				const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
				const url = URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.href = url;
				a.download = `отчет_${new Date().toISOString().slice(0,10)}.html`;
				document.body.appendChild(a);
				a.click();
				document.body.removeChild(a);
				URL.revokeObjectURL(url);
				
				showNotification('HTML файл успешно экспортирован', 'success');
				
			} catch (error) {
				console.error('Ошибка экспорта в HTML:', error);
				showNotification('Ошибка при экспорте в HTML', 'error');
			}
		}

		// Экспорт в DOCX (упрощенный через HTML)
		async function exportToDOCX() {
			const reportContent = document.getElementById('reportContent');
			if (!reportContent) return;
			
			try {
				showNotification('Подготовка DOCX экспорта...', 'info');
				
				// Используем библиотеку html-docx-js если доступна
				if (typeof htmlDocx !== 'undefined') {
					// Создаем HTML для DOCX
					const htmlForDocx = await createHTMLForDOCX();
					const converted = htmlDocx.asBlob(htmlForDocx);
					
					const url = URL.createObjectURL(converted);
					const a = document.createElement('a');
					a.href = url;
					a.download = `отчет_${new Date().toISOString().slice(0,10)}.docx`;
					document.body.appendChild(a);
					a.click();
					document.body.removeChild(a);
					URL.revokeObjectURL(url);
					
					showNotification('DOCX файл успешно экспортирован', 'success');
				} else {
					// Fallback: экспорт как HTML
					showNotification('Библиотека для DOCX не найдена, экспортируем как HTML', 'warning');
					exportToHTML();
				}
				
			} catch (error) {
				console.error('Ошибка экспорта в DOCX:', error);
				showNotification('Ошибка при экспорте в DOCX', 'error');
			}
		}

		// Вспомогательная функция для создания HTML для DOCX
		async function createHTMLForDOCX() {
			const reportContent = document.getElementById('reportContent');
			const contentClone = reportContent.cloneNode(true);
			
			// Обрабатываем canvas
			const canvasPromises = [];
			const canvases = contentClone.querySelectorAll('canvas');
			
			canvases.forEach((canvas, index) => {
				const promise = new Promise((resolve) => {
					try {
						if (canvas.chart && typeof canvas.chart.toBase64Image === 'function') {
							// Увеличиваем качество для Chart.js
							const originalWidth = canvas.width;
							const originalHeight = canvas.height;
							canvas.width = originalWidth * 2;
							canvas.height = originalHeight * 2;
							canvas.chart.resize();
							
							const dataUrl = canvas.chart.toBase64Image();
							
							canvas.width = originalWidth;
							canvas.height = originalHeight;
							canvas.chart.resize();
							
							resolve({ canvas, dataUrl });
						} else {
							const dataUrl = canvas.toDataURL('image/png', 1.0);
							resolve({ canvas, dataUrl });
						}
					} catch (error) {
						resolve(null);
					}
				});
				canvasPromises.push(promise);
			});
			
			const canvasResults = await Promise.all(canvasPromises);
			
			// Заменяем canvas на изображения
			canvasResults.forEach(result => {
				if (result && result.dataUrl) {
					const img = document.createElement('img');
					img.src = result.dataUrl;
					img.style.width = '100%';
					img.style.maxWidth = '100%';
					img.style.height = 'auto';
					result.canvas.parentNode.replaceChild(img, result.canvas);
				}
			});
			
			// Удаляем ненужные элементы
			const elementsToRemove = contentClone.querySelectorAll(
				'.btn, .no-export, .modal-footer, .spinner-border, button, .navbar, .sidebar'
			);
			elementsToRemove.forEach(el => el.remove());
			
			// Исправляем оценки
			const fixGrades = (text) => text.replace(/\b1\b/g, '2');
			
			const walker = document.createTreeWalker(contentClone, NodeFilter.SHOW_TEXT, null, false);
			let node;
			while (node = walker.nextNode()) {
				if (node.nodeType === Node.TEXT_NODE && node.textContent.trim()) {
					node.textContent = fixGrades(node.textContent);
				}
			}

			return `
				<!DOCTYPE html>
				<html>
				<head>
					<meta charset="UTF-8">
					<style>
						body {
							font-family: 'Times New Roman', Times, serif;
							font-size: 12pt;
							line-height: 1.5;
						}
						h1 { font-size: 16pt; }
						h2 { font-size: 14pt; }
						h3 { font-size: 12pt; }
						table { border-collapse: collapse; width: 100%; }
						th, td { border: 1px solid black; padding: 5px; }
						th { background: #f0f0f0; }
						img { max-width: 100%; height: auto; }
					</style>
				</head>
				<body>
					<h1>Аналитический отчет</h1>
					<p>Дата: ${new Date().toLocaleDateString('ru-RU')}</p>
					${contentClone.innerHTML}
				</body>
				</html>
			`;
		}

		// Добавьте кнопки в интерфейс для вызова этих функций
		// Добавление кнопок экспорта в интерфейс
		function addExportButtons() {
			try {
				// Ищем различные возможные места для размещения кнопок
				let container = null;
				
				// Вариант 1: Ищем уже существующий контейнер для кнопок
				const possibleSelectors = [
					'.report-header',
					'.card-header:has(h1, h2, h3)',
					'.d-flex.justify-content-between',
					'.btn-toolbar',
					'.actions',
					'.toolbar',
					'#reportActions',
					'.container-fluid:first-child'
				];
				
				for (const selector of possibleSelectors) {
					const element = document.querySelector(selector);
					if (element) {
						container = element;
						break;
					}
				}
				
				// Вариант 2: Ищем reportContent и размещаем кнопки перед ним или после
				if (!container) {
					const reportContent = document.getElementById('reportContent');
					if (reportContent) {
						// Создаем контейнер для кнопок перед отчетом
						const buttonContainer = document.createElement('div');
						buttonContainer.className = 'report-export-buttons mb-4';
						buttonContainer.style.cssText = `
							display: flex;
							justify-content: flex-end;
							gap: 10px;
							padding: 15px;
							background: #f8f9fa;
							border-radius: 8px;
							border: 1px solid #dee2e6;
						`;
						
						reportContent.parentNode.insertBefore(buttonContainer, reportContent);
						container = buttonContainer;
					}
				}
				
				// Вариант 3: Создаем плавающую панель кнопок
				if (!container) {
					container = document.createElement('div');
					container.id = 'floatingExportButtons';
					container.style.cssText = `
						position: fixed;
						top: 100px;
						right: 20px;
						z-index: 1000;
						background: white;
						padding: 10px;
						border-radius: 8px;
						box-shadow: 0 4px 20px rgba(0,0,0,0.15);
						display: flex;
						flex-direction: column;
						gap: 8px;
						border: 1px solid #dee2e6;
					`;
					document.body.appendChild(container);
				}
				
				// Создаем кнопки
				const buttonsHTML = `
					<div class="btn-group" role="group" aria-label="Экспорт отчета">
						<button type="button" class="btn btn-primary btn-sm" onclick="exportReport('print')" 
								title="Печать отчета">
							<i class="fas fa-print"></i> Печать
						</button>
						<button type="button" class="btn btn-success btn-sm" onclick="exportReport('html')"
								title="Экспорт в HTML">
							<i class="fas fa-file-code"></i> HTML
						</button>
						<button type="button" class="btn btn-info btn-sm" onclick="exportReport('docx')"
								title="Экспорт в Word">
							<i class="fas fa-file-word"></i> DOCX
						</button>
					</div>
					
					<style>
						.report-export-buttons .btn {
							min-width: 100px;
						}
						
						#floatingExportButtons .btn {
							min-width: 120px;
							justify-content: flex-start;
						}
						
						@media (max-width: 768px) {
							#floatingExportButtons {
								position: fixed;
								bottom: 20px;
								top: auto;
								right: 20px;
								left: 20px;
								flex-direction: row;
								justify-content: center;
							}
							
							#floatingExportButtons .btn {
								min-width: auto;
								flex: 1;
							}
						}
					</style>
				`;
				
				// Добавляем кнопки в контейнер
				if (container.id === 'floatingExportButtons') {
					container.innerHTML = buttonsHTML;
				} else {
					// Если контейнер уже существует, добавляем кнопки в него
					if (container.querySelector('.btn-group')) {
						// Уже есть кнопки, обновляем их
						container.querySelector('.btn-group').outerHTML = buttonsHTML;
					} else {
						// Создаем новую группу кнопок
						container.insertAdjacentHTML('beforeend', buttonsHTML);
					}
				}
				
				console.log('Кнопки экспорта добавлены в:', container);
				
			} catch (error) {
				console.error('Ошибка при добавлении кнопок экспорта:', error);
				
				// Fallback: создаем плавающую кнопку
				createFloatingExportButton();
			}
		}

		// Альтернативная функция: плавающая кнопка
		function createFloatingExportButton() {
			const floatingBtn = document.createElement('button');
			floatingBtn.id = 'floatingExportBtn';
			floatingBtn.innerHTML = '<i class="fas fa-download"></i>';
			floatingBtn.title = 'Экспорт отчета';
			floatingBtn.style.cssText = `
				position: fixed;
				bottom: 30px;
				right: 30px;
				width: 60px;
				height: 60px;
				border-radius: 50%;
				background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
				color: white;
				border: none;
				font-size: 24px;
				cursor: pointer;
				z-index: 1000;
				box-shadow: 0 6px 20px rgba(0,0,0,0.3);
				display: flex;
				align-items: center;
				justify-content: center;
				transition: all 0.3s ease;
			`;
			
			// Добавляем hover эффект
			floatingBtn.addEventListener('mouseenter', () => {
				floatingBtn.style.transform = 'scale(1.1)';
				floatingBtn.style.boxShadow = '0 8px 25px rgba(0,0,0,0.4)';
			});
			
			floatingBtn.addEventListener('mouseleave', () => {
				floatingBtn.style.transform = 'scale(1)';
				floatingBtn.style.boxShadow = '0 6px 20px rgba(0,0,0,0.3)';
			});
			
			// Меню экспорта
			let menuVisible = false;
			const exportMenu = document.createElement('div');
			exportMenu.id = 'exportMenu';
			exportMenu.style.cssText = `
				position: absolute;
				bottom: 70px;
				right: 0;
				background: white;
				border-radius: 10px;
				box-shadow: 0 10px 30px rgba(0,0,0,0.2);
				padding: 10px;
				min-width: 150px;
				display: none;
				flex-direction: column;
				gap: 5px;
				z-index: 1001;
				border: 1px solid #dee2e6;
			`;
			
			const menuItems = [
				{ text: '?? Печать', action: 'print', color: '#007bff' },
				{ text: '?? HTML', action: 'html', color: '#28a745' },
				{ text: '?? Word', action: 'docx', color: '#17a2b8' }
			];
			
			menuItems.forEach(item => {
				const menuItem = document.createElement('button');
				menuItem.textContent = item.text;
				menuItem.style.cssText = `
					padding: 8px 12px;
					background: ${item.color};
					color: white;
					border: none;
					border-radius: 5px;
					cursor: pointer;
					text-align: left;
					font-size: 14px;
					transition: all 0.2s;
				`;
				
				menuItem.addEventListener('mouseenter', () => {
					menuItem.style.opacity = '0.9';
					menuItem.style.transform = 'translateX(-5px)';
				});
				
				menuItem.addEventListener('mouseleave', () => {
					menuItem.style.opacity = '1';
					menuItem.style.transform = 'translateX(0)';
				});
				
				menuItem.addEventListener('click', () => {
					exportReport(item.action);
					exportMenu.style.display = 'none';
					menuVisible = false;
				});
				
				exportMenu.appendChild(menuItem);
			});
			
			floatingBtn.appendChild(exportMenu);
			
			// Показ/скрытие меню
			floatingBtn.addEventListener('click', (e) => {
				e.stopPropagation();
				menuVisible = !menuVisible;
				exportMenu.style.display = menuVisible ? 'flex' : 'none';
			});
			
			// Закрытие меню при клике вне
			document.addEventListener('click', () => {
				if (menuVisible) {
					exportMenu.style.display = 'none';
					menuVisible = false;
				}
			});
			
			document.body.appendChild(floatingBtn);
		}

		// Улучшенная инициализация
		function initExportButtons() {
			// Ждем полной загрузки DOM
			if (document.readyState === 'loading') {
				document.addEventListener('DOMContentLoaded', () => {
					setTimeout(addExportButtons, 1500);
				});
			} else {
				setTimeout(addExportButtons, 1500);
			}
			
			// Также пытаемся добавить кнопки после AJAX-загрузки контента
			// Если у вас динамическая загрузка, добавьте вызов addExportButtons после загрузки отчета
		}

		// Автоматическая инициализация
		// initExportButtons();

		// Главная функция экспорта - сделайте ее глобально доступной
		window.exportReport = function(type = 'print') {
			const reportContent = document.getElementById('reportContent');
			if (!reportContent) {
				showNotification('Отчет не найден', 'error');
				return;
			}

			if (type === 'html') {
				exportToHTML();
				return;
			}
			
			if (type === 'docx') {
				exportToDOCX();
				return;
			}
			
			// Для печати
			printReport();
		};

		// Сделайте остальные функции тоже доступными
		window.printReport = printReport;
		window.exportToHTML = exportToHTML;
		window.exportToDOCX = exportToDOCX;
		function exportChartsForPrint() {
			const charts = [];
			document.querySelectorAll('canvas').forEach((canvas, index) => {
				try {
					const dataUrl = canvas.toDataURL('image/png', 1.0);
					charts.push({
						id: canvas.id || `chart-${index}`,
						dataUrl: dataUrl,
						width: canvas.width,
						height: canvas.height
					});
				} catch (e) {
					console.warn('Ошибка экспорта графика:', e);
				}
			});
			return charts;
		}

		// Вспомогательная функция для оптимизации контента для печати
		function optimizeForPrint(container) {
			// Разбиваем большие таблицы
			const tables = container.querySelectorAll('table');
			tables.forEach(table => {
				if (table.offsetHeight > 500) { // Если таблица слишком высокая
					table.classList.add('no-break');
				}
			});
			
			// Убедимся, что изображения не выходят за границы
			const images = container.querySelectorAll('img');
			images.forEach(img => {
				img.style.maxWidth = '100%';
				img.style.height = 'auto';
			});
			
			// Добавляем разрывы страниц перед большими секциями
			const sections = container.querySelectorAll('.card, .section');
			sections.forEach((section, index) => {
				if (index > 0 && section.offsetHeight > 400) {
					section.classList.add('no-break');
				}
			});
			
			// Удаляем пустые элементы
			const emptyElements = container.querySelectorAll(':empty');
			emptyElements.forEach(el => {
				if (!el.hasChildNodes() && el.tagName !== 'INPUT' && el.tagName !== 'BR' && el.tagName !== 'HR') {
					el.remove();
				}
			});
		}
		// Загрузка необходимых библиотек
		async function loadReportLibraries() {
			if (typeof html2canvas === 'undefined') {
				await loadScript('https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js');
			}
		}



		// Генерация контента отчета
		async function generateReportContent() {
			const reportContent = document.getElementById('reportContent');
			if (!reportContent) return;
			
			try {
				// Получаем данные для отчета
				const totalScores = appData.results.map(scores => 
					scores.reduce((sum, score) => sum + (parseInt(score) || 0), 0)
				);
				const averageScore = totalScores.reduce((a, b) => a + b, 0) / (totalScores.length || 1);
				const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0);
				const averagePercentage = (averageScore / (maxPossible || 1)) * 100;
				const minScore = Math.min(...totalScores);
				const maxScore = Math.max(...totalScores);
				
				// Распределение оценок
				const gradeDistribution = calculateGradeDistribution();
				
				// Конвертируем графики в изображения
				const chartImages = await getChartImages();
				
				// Генерируем HTML отчета
				const html = `
					<div class="report-container">
						<!-- Заголовок отчета -->
						<div class="report-header text-center mb-5">
							<h1 class="display-5 fw-bold text-primary mb-3">АНАЛИТИЧЕСКИЙ ОТЧЕТ</h1>
							<div class="report-subtitle text-muted">
								<p class="lead">Результаты тестирования</p>
								<p class="mb-0">Дата создания: ${new Date().toLocaleDateString('ru-RU', {
									day: 'numeric',
									month: 'long',
									year: 'numeric',
									hour: '2-digit',
									minute: '2-digit'
								})}</p>
							</div>
						</div>
						
						<!-- Информация о тесте -->
						<div class="report-section card border-0 shadow-sm mb-5">
							<div class="card-header bg-primary text-white">
								<h3 class="mb-0"><i class="fas fa-info-circle me-2"></i>ИНФОРМАЦИЯ О ТЕСТЕ</h3>
							</div>
							<div class="card-body">
								<div class="row">
									<div class="col-md-6">
										<ul class="list-group list-group-flush">
											<li class="list-group-item d-flex justify-content-between">
												<span class="text-muted">Предмет:</span>
												<span class="fw-bold">${appData.test.subject || 'Не указан'}</span>
											</li>
											<li class="list-group-item d-flex justify-content-between">
												<span class="text-muted">Класс:</span>
												<span class="fw-bold">${appData.test.class || 'Не указан'}</span>
											</li>
											<li class="list-group-item d-flex justify-content-between">
												<span class="text-muted">Тема:</span>
												<span class="fw-bold">${appData.test.theme || 'Не указана'}</span>
											</li>
										</ul>
									</div>
									<div class="col-md-6">
										<ul class="list-group list-group-flush">
											<li class="list-group-item d-flex justify-content-between">
												<span class="text-muted">Дата проведения:</span>
												<span class="fw-bold">${appData.test.testDate || 'Не указана'}</span>
											</li>
											<li class="list-group-item d-flex justify-content-between">
												<span class="text-muted">Всего учащихся:</span>
												<span class="fw-bold">${appData.students.length}</span>
											</li>
											<li class="list-group-item d-flex justify-content-between">
												<span class="text-muted">Присутствовало:</span>
												<span class="fw-bold">${appData.test.presentStudents || appData.students.length}</span>
											</li>
										</ul>
									</div>
								</div>
							</div>
						</div>
						
						<!-- Ключевые метрики -->
						<div class="report-section mb-5">
							<h3 class="mb-4 text-center"><i class="fas fa-chart-line me-2"></i>КЛЮЧЕВЫЕ МЕТРИКИ</h3>
							<div class="row g-4">
								<div class="col-md-3 col-6">
									<div class="metric-card card border-0 text-center h-100 shadow-sm">
										<div class="card-body">
											<div class="metric-icon mb-3">
												<i class="fas fa-users fa-2x text-primary"></i>
											</div>
											<div class="metric-value display-6 fw-bold text-primary">${appData.students.length}</div>
											<div class="metric-label text-muted">Учащихся</div>
										</div>
									</div>
								</div>
								<div class="col-md-3 col-6">
									<div class="metric-card card border-0 text-center h-100 shadow-sm">
										<div class="card-body">
											<div class="metric-icon mb-3">
												<i class="fas fa-tasks fa-2x text-success"></i>
											</div>
											<div class="metric-value display-6 fw-bold text-success">${appData.tasks.length}</div>
											<div class="metric-label text-muted">Заданий</div>
										</div>
									</div>
								</div>
								<div class="col-md-3 col-6">
									<div class="metric-card card border-0 text-center h-100 shadow-sm">
										<div class="card-body">
											<div class="metric-icon mb-3">
												<i class="fas fa-star fa-2x text-warning"></i>
											</div>
											<div class="metric-value display-6 fw-bold text-warning">${averageScore.toFixed(1)}</div>
											<div class="metric-label text-muted">Средний балл</div>
											<div class="metric-subtext small">из ${maxPossible}</div>
										</div>
									</div>
								</div>
								<div class="col-md-3 col-6">
									<div class="metric-card card border-0 text-center h-100 shadow-sm">
										<div class="card-body">
											<div class="metric-icon mb-3">
												<i class="fas fa-percentage fa-2x text-info"></i>
											</div>
											<div class="metric-value display-6 fw-bold text-info">${averagePercentage.toFixed(1)}%</div>
											<div class="metric-label text-muted">Успеваемость</div>
											<div class="metric-subtext small">в процентах</div>
										</div>
									</div>
								</div>
							</div>
						</div>
						
						<!-- Графики -->
						<div class="report-section mb-5">
							<h3 class="mb-4 text-center"><i class="fas fa-chart-bar me-2"></i>ГРАФИКИ И ДИАГРАММЫ</h3>
							<div class="row g-4">
								${chartImages.gradesChart ? `
									<div class="col-md-6">
										<div class="chart-card card border-0 shadow-sm h-100">
											<div class="card-header bg-light">
												<h5 class="mb-0"><i class="fas fa-chart-pie me-2"></i>Распределение оценок</h5>
											</div>
											<div class="card-body text-center">
												<img src="${chartImages.gradesChart}" class="img-fluid rounded" alt="График распределения оценок">
											</div>
										</div>
									</div>
								` : ''}
								
								${chartImages.solvabilityChart ? `
									<div class="col-md-6">
										<div class="chart-card card border-0 shadow-sm h-100">
											<div class="card-header bg-light">
												<h5 class="mb-0"><i class="fas fa-chart-line me-2"></i>Решаемость заданий</h5>
											</div>
											<div class="card-body text-center">
												<img src="${chartImages.solvabilityChart}" class="img-fluid rounded" alt="График решаемости заданий">
											</div>
										</div>
									</div>
								` : ''}
								
								${chartImages.complexityChart ? `
									<div class="col-12 mt-4">
										<div class="chart-card card border-0 shadow-sm">
											<div class="card-header bg-light">
												<h5 class="mb-0"><i class="fas fa-project-diagram me-2"></i>Связь сложности и решаемости</h5>
											</div>
											<div class="card-body text-center">
												<img src="${chartImages.complexityChart}" class="img-fluid rounded" style="max-height: 500px;" alt="График сложности и решаемости">
											</div>
										</div>
									</div>
								` : ''}
							</div>
						</div>
						
						<!-- Подробная статистика -->
						<div class="report-section mb-5">
							<h3 class="mb-4 text-center"><i class="fas fa-list-alt me-2"></i>ПОДРОБНАЯ СТАТИСТИКА</h3>
							
							<div class="row">
								<!-- Общая статистика -->
								<div class="col-md-6 mb-4">
									<div class="card border-0 shadow-sm h-100">
										<div class="card-header bg-light">
											<h5 class="mb-0"><i class="fas fa-calculator me-2"></i>Общая статистика</h5>
										</div>
										<div class="card-body">
											<ul class="list-group list-group-flush">
												<li class="list-group-item d-flex justify-content-between">
													<span>Минимальный балл:</span>
													<span class="fw-bold">${minScore}</span>
												</li>
												<li class="list-group-item d-flex justify-content-between">
													<span>Максимальный балл:</span>
													<span class="fw-bold">${maxScore}</span>
												</li>
												<li class="list-group-item d-flex justify-content-between">
													<span>Размах баллов:</span>
													<span class="fw-bold">${maxScore - minScore}</span>
												</li>
												<li class="list-group-item d-flex justify-content-between">
													<span>Медианный балл:</span>
													<span class="fw-bold">${calculateMedian(totalScores).toFixed(1)}</span>
												</li>
											</ul>
										</div>
									</div>
								</div>
								
								<!-- Распределение оценок -->
								<div class="col-md-6 mb-4">
									<div class="card border-0 shadow-sm h-100">
										<div class="card-header bg-light">
											<h5 class="mb-0"><i class="fas fa-star-half-alt me-2"></i>Распределение оценок</h5>
										</div>
										<div class="card-body">
											<div class="table-responsive">
												<table class="table table-hover">
													<thead>
														<tr>
															<th>Оценка</th>
															<th>Количество</th>
															<th>Процент</th>
														</tr>
													</thead>
													<tbody>
														${Object.entries(gradeDistribution).map(([grade, count]) => {
															const percentage = ((count / appData.students.length) * 100).toFixed(1);
															const gradeLabel = getGradeLabel(parseInt(grade));
															return `
																<tr>
																	<td>${grade} (${gradeLabel})</td>
																	<td>${count}</td>
																	<td>
																		<div class="d-flex align-items-center">
																			<div class="progress flex-grow-1 me-2" style="height: 8px;">
																				<div class="progress-bar" style="width: ${percentage}%"></div>
																			</div>
																			<span>${percentage}%</span>
																		</div>
																	</td>
																</tr>
															`;
														}).join('')}
													</tbody>
												</table>
											</div>
										</div>
									</div>
								</div>
							</div>
							
							<!-- Уровни сложности -->
							<div class="row mt-4">
								<div class="col-12">
									<div class="card border-0 shadow-sm">
										<div class="card-header bg-light">
											<h5 class="mb-0"><i class="fas fa-layer-group me-2"></i>Анализ по уровням сложности</h5>
										</div>
										<div class="card-body">
											<div class="table-responsive">
												<table class="table table-hover">
													<thead>
														<tr>
															<th>Уровень</th>
															<th>Количество заданий</th>
															<th>Средняя решаемость</th>
															<th>Общий балл</th>
															<th>Средний балл за задание</th>
														</tr>
													</thead>
													<tbody>
														${generateDifficultyAnalysis().map(level => `
															<tr>
																<td>${level.level}</td>
																<td>${level.taskCount}</td>
																<td>
																	<div class="d-flex align-items-center">
																		<div class="progress flex-grow-1 me-2" style="height: 8px;">
																			<div class="progress-bar bg-${getDifficultyColor(level.avgSolvability)}" 
																				 style="width: ${level.avgSolvability}%"></div>
																		</div>
																		<span>${level.avgSolvability.toFixed(1)}%</span>
																	</div>
																</td>
																<td>${level.totalScore.toFixed(1)}</td>
																<td>${level.avgScorePerTask.toFixed(1)}</td>
															</tr>
														`).join('')}
													</tbody>
												</table>
											</div>
										</div>
									</div>
								</div>
							</div>
						</div>
						
						<!-- Заключение -->
						<div class="report-section">
							<div class="card border-0 shadow-sm bg-light">
								<div class="card-body text-center">
									<h4 class="mb-3"><i class="fas fa-clipboard-check me-2"></i>ЗАКЛЮЧЕНИЕ</h4>
									<p class="lead mb-4">${generateConclusion(averagePercentage, gradeDistribution)}</p>
									<div class="row">
										<div class="col-md-4">
											<div class="d-flex align-items-center justify-content-center">
												<i class="fas fa-calendar-check fa-2x text-primary me-3"></i>
												<div>
													<div class="fw-bold">Дата отчета</div>
													<div>${new Date().toLocaleDateString('ru-RU')}</div>
												</div>
											</div>
										</div>
										<div class="col-md-4">
											<div class="d-flex align-items-center justify-content-center">
												<i class="fas fa-chart-bar fa-2x text-success me-3"></i>
												<div>
													<div class="fw-bold">Общая успеваемость</div>
													<div>${averagePercentage.toFixed(1)}%</div>
												</div>
											</div>
										</div>
										<div class="col-md-4">
											<div class="d-flex align-items-center justify-content-center">
												<i class="fas fa-user-check fa-2x text-info me-3"></i>
												<div>
													<div class="fw-bold">Учащихся справились</div>
													<div>${calculateSuccessRate(gradeDistribution)}%</div>
												</div>
											</div>
										</div>
									</div>
								</div>
							</div>
						</div>
					</div>
				`;
				
				reportContent.innerHTML = html;
				
				// Добавляем стили для печати
				addPrintStyles();
				
				showNotification('HTML отчет создан успешно', 'success');
				
			} catch (error) {
				console.error('Ошибка генерации отчета:', error);
				reportContent.innerHTML = `
					<div class="alert alert-danger">
						<i class="fas fa-exclamation-triangle me-2"></i>
						<strong>Ошибка при создании отчета:</strong> ${error.message}
					</div>
				`;
			}
		}

		// Вспомогательные функции
		async function getChartImages() {
			const charts = {
				gradesChart: document.getElementById('gradesChart'),
				solvabilityChart: document.getElementById('solvabilityChart'),
				complexityChart: document.getElementById('complexityChart')
			};
			
			const images = {};
			
			for (const [name, canvas] of Object.entries(charts)) {
				if (canvas) {
					try {
						// Используем html2canvas для лучшего рендеринга
						if (typeof html2canvas !== 'undefined') {
							const canvasData = await html2canvas(canvas, {
								scale: 2,
								backgroundColor: '#ffffff',
								logging: false
							});
							images[name] = canvasData.toDataURL('image/png', 1.0);
						} else {
							// Fallback на обычный canvas
							images[name] = canvas.toDataURL('image/png', 1.0);
						}
					} catch (error) {
						console.error(`Ошибка конвертации графика ${name}:`, error);
						images[name] = null;
					}
				}
			}
			
			return images;
		}



		function calculateGradeDistribution(totalScores, maxPossible) {
			const distribution = {};
			
			totalScores.forEach(score => {
				// Вычисляем оценку по баллам
				let grade;
				if (maxPossible > 0) {
					if (score >= (maxPossible * 0.85)) grade = 5;
					else if (score >= (maxPossible * 0.70)) grade = 4;
					else if (score >= (maxPossible * 0.55)) grade = 3;
					else if (score >= (maxPossible * 0.40)) grade = 2;
					else grade = 1;
				} else {
					// Если maxPossible не определен, используем упрощенную логику
					const maxScore = Math.max(...totalScores, 1);
					const percentage = (score / maxScore) * 100;
					
					if (percentage >= 85) grade = 5;
					else if (percentage >= 70) grade = 4;
					else if (percentage >= 55) grade = 3;
					else if (percentage >= 40) grade = 2;
					else grade = 1;
				}
				
				distribution[grade] = (distribution[grade] || 0) + 1;
			});
			
			return distribution;
		}


        // Расчет медианы
        function calculateMedian(scores) {
            const sorted = [...scores].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 !== 0 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
        }

		function generateDifficultyAnalysis() {
			const levels = {};
			
			appData.tasks.forEach((task, index) => {
				const level = task.level || 'Не указан';
				if (!levels[level]) {
					levels[level] = {
						level: level,
						taskCount: 0,
						totalSolvability: 0,
						totalScore: 0
					};
				}
				
				// Вычисляем решаемость для этого задания
				const taskResults = appData.results.map(result => result[index] || 0);
				const maxScore = task.maxScore || 1;
				const solvability = (taskResults.reduce((a, b) => a + b, 0) / (taskResults.length * maxScore)) * 100;
				const avgScore = taskResults.reduce((a, b) => a + b, 0) / taskResults.length;
				
				levels[level].taskCount++;
				levels[level].totalSolvability += solvability;
				levels[level].totalScore += avgScore;
			});
			
			return Object.values(levels).map(level => ({
				...level,
				avgSolvability: level.totalSolvability / level.taskCount,
				avgScorePerTask: level.totalScore / level.taskCount
			}));
		}

		function getDifficultyColor(solvability) {
			if (solvability >= 80) return 'success';
			if (solvability >= 60) return 'info';
			if (solvability >= 40) return 'warning';
			return 'danger';
		}

		function getGradeLabel(grade) {
			const labels = {
				5: 'Отлично',
				4: 'Хорошо',
				3: 'Удовлетворительно',
				2: 'Неудовлетворительно',
				1: 'Плохо'
			};
			return labels[grade] || 'Не определено';
		}

		function calculateSuccessRate(distribution) {
			const totalStudents = appData.students.length;
			const successful = (distribution[4] || 0) + (distribution[5] || 0);
			return ((successful / totalStudents) * 100).toFixed(1);
		}

		function generateConclusion(averagePercentage, gradeDistribution) {
			if (averagePercentage === 0 && (!gradeDistribution || Object.keys(gradeDistribution).length === 0)) {
				return 'Нет данных для формирования заключения. Добавьте результаты тестирования.';
			}
			
			let conclusion = '';
			
			if (averagePercentage >= 80) {
				conclusion = 'Результаты тестирования показывают высокий уровень освоения материала. ';
			} else if (averagePercentage >= 60) {
				conclusion = 'Результаты тестирования демонстрируют удовлетворительный уровень знаний. ';
			} else if (averagePercentage >= 40) {
				conclusion = 'Результаты тестирования указывают на необходимость дополнительной работы. ';
			} else {
				conclusion = 'Результаты тестирования требуют серьезного внимания и коррекции обучения. ';
			}
			
			const goodGrades = (gradeDistribution[4] || 0) + (gradeDistribution[5] || 0);
			const totalStudents = appData.students.length || 1;
			const goodPercentage = ((goodGrades / totalStudents) * 100).toFixed(1);
			
			conclusion += `${goodPercentage}% учащихся показали хорошие и отличные результаты. `;
			
			if (goodPercentage >= 70) {
				conclusion += 'Большинство учащихся успешно справились с заданиями.';
			} else if (goodPercentage >= 50) {
				conclusion += 'Около половины учащихся освоили материал на хорошем уровне.';
			} else {
				conclusion += 'Требуется дополнительная работа с учащимися, показавшими низкие результаты.';
			}
			
			return conclusion;
		}

		// Функции для работы с модальным окном
		function closeReportModal() {
			const modal = document.querySelector('.modal');
			if (modal) modal.remove();
		}

		// Генерация контента отчета
		// Генерация контента отчета (исправленная версия)
		async function generateReportContent() {
			const reportContent = document.getElementById('reportContent');
			if (!reportContent) return;
			
			try {
				// Показываем загрузку
				reportContent.innerHTML = `
					<div class="text-center py-5">
						<div class="spinner-border text-primary" role="status">
							<span class="visually-hidden">Загрузка...</span>
						</div>
						<p class="mt-3">Загружаем данные и графики...</p>
					</div>
				`;
				
				// Получаем данные для отчета
				const totalScores = appData.results.map(scores => 
					scores.reduce((sum, score) => sum + (parseInt(score) || 0), 0)
				);
				const averageScore = totalScores.reduce((a, b) => a + b, 0) / (totalScores.length || 1);
				const maxPossible = appData.tasks.reduce((sum, task) => sum + (task.maxScore || 0), 0);
				const averagePercentage = maxPossible > 0 ? (averageScore / maxPossible) * 100 : 0;
				const minScore = totalScores.length > 0 ? Math.min(...totalScores) : 0;
				const maxScore = totalScores.length > 0 ? Math.max(...totalScores) : 0;
				
				// Распределение оценок (передаем maxPossible как параметр)
				const gradeDistribution = calculateGradeDistribution(totalScores, maxPossible);
				
				// Конвертируем графики в изображения (с обработкой ошибок)
				let chartImages = {};
				try {
					chartImages = await getChartImages();
				} catch (chartError) {
					console.warn('Ошибка загрузки графиков:', chartError);
					// Используем заглушки для графиков
					chartImages = {
						gradesChart: null,
						solvabilityChart: null,
						complexityChart: null
					};
				}
				
				// Генерируем HTML отчета
				const html = generateReportHTML({
					averageScore,
					maxPossible,
					averagePercentage,
					minScore,
					maxScore,
					gradeDistribution,
					chartImages,
					totalScores,
					studentCount: appData.students.length,
					taskCount: appData.tasks.length
				});
				
				reportContent.innerHTML = html;
				
				// Добавляем стили для печати
				addPrintStyles();
				
				showNotification('HTML отчет создан успешно', 'success');
				
			} catch (error) {
				console.error('Ошибка генерации отчета:', error);
				reportContent.innerHTML = `
					<div class="alert alert-danger">
						<i class="fas fa-exclamation-triangle me-2"></i>
						<strong>Ошибка при создании отчета:</strong> ${error.message}
						<div class="mt-2">
							<button class="btn btn-sm btn-outline-primary" onclick="generateSimpleReport()">
								Создать упрощенный отчет
							</button>
						</div>
					</div>
				`;
			}
		}

		// Генерация HTML отчета (вынесено в отдельную функцию)
		function generateReportHTML(data) {
			const {
				averageScore,
				maxPossible,
				averagePercentage,
				minScore,
				maxScore,
				gradeDistribution,
				chartImages,
				totalScores,
				studentCount,
				taskCount
			} = data;
			
			// Проверяем, есть ли данные
			if (studentCount === 0) {
				return `
					<div class="text-center py-5">
						<div class="alert alert-warning">
							<i class="fas fa-exclamation-triangle me-2"></i>
							<strong>Нет данных для отчета</strong>
							<p class="mt-2">Добавьте учащихся и результаты тестирования</p>
						</div>
					</div>
				`;
			}
			
			return `
				<div class="report-container">
					<!-- Заголовок отчета -->
					<div class="report-header text-center mb-5">
						<h1 class="display-5 fw-bold text-primary mb-3">АНАЛИТИЧЕСКИЙ ОТЧЕТ</h1>
						<div class="report-subtitle text-muted">
							<p class="lead">Результаты тестирования</p>
							<p class="mb-0">Дата создания: ${new Date().toLocaleDateString('ru-RU', {
								day: 'numeric',
								month: 'long',
								year: 'numeric',
								hour: '2-digit',
								minute: '2-digit'
							})}</p>
						</div>
					</div>
					
					<!-- Информация о тесте -->
					<div class="report-section card border-0 shadow-sm mb-5">
						<div class="card-header bg-primary text-white">
							<h3 class="mb-0"><i class="fas fa-info-circle me-2"></i>ИНФОРМАЦИЯ О ТЕСТЕ</h3>
						</div>
						<div class="card-body">
							<div class="row">
								<div class="col-md-6">
									<ul class="list-group list-group-flush">
										<li class="list-group-item d-flex justify-content-between">
											<span class="text-muted">Предмет:</span>
											<span class="fw-bold">${appData.test.subject || 'Не указан'}</span>
										</li>
										<li class="list-group-item d-flex justify-content-between">
											<span class="text-muted">Класс:</span>
											<span class="fw-bold">${appData.test.class || 'Не указан'}</span>
										</li>
										<li class="list-group-item d-flex justify-content-between">
											<span class="text-muted">Тема:</span>
											<span class="fw-bold">${appData.test.theme || 'Не указана'}</span>
										</li>
									</ul>
								</div>
								<div class="col-md-6">
									<ul class="list-group list-group-flush">
										<li class="list-group-item d-flex justify-content-between">
											<span class="text-muted">Дата проведения:</span>
											<span class="fw-bold">${appData.test.testDate || 'Не указана'}</span>
										</li>
										<li class="list-group-item d-flex justify-content-between">
											<span class="text-muted">Всего учащихся:</span>
											<span class="fw-bold">${studentCount}</span>
										</li>
										<li class="list-group-item d-flex justify-content-between">
											<span class="text-muted">Присутствовало:</span>
											<span class="fw-bold">${appData.test.presentStudents || studentCount}</span>
										</li>
									</ul>
								</div>
							</div>
						</div>
					</div>
					
					<!-- Ключевые метрики -->
					<div class="report-section mb-5">
						<h3 class="mb-4 text-center"><i class="fas fa-chart-line me-2"></i>КЛЮЧЕВЫЕ МЕТРИКИ</h3>
						<div class="row g-4">
							<div class="col-md-3 col-6">
								<div class="metric-card card border-0 text-center h-100 shadow-sm">
									<div class="card-body">
										<div class="metric-icon mb-3">
											<i class="fas fa-users fa-2x text-primary"></i>
										</div>
										<div class="metric-value display-6 fw-bold text-primary">${studentCount}</div>
										<div class="metric-label text-muted">Учащихся</div>
									</div>
								</div>
							</div>
							<div class="col-md-3 col-6">
								<div class="metric-card card border-0 text-center h-100 shadow-sm">
									<div class="card-body">
										<div class="metric-icon mb-3">
											<i class="fas fa-tasks fa-2x text-success"></i>
										</div>
										<div class="metric-value display-6 fw-bold text-success">${taskCount}</div>
										<div class="metric-label text-muted">Заданий</div>
									</div>
								</div>
							</div>
							<div class="col-md-3 col-6">
								<div class="metric-card card border-0 text-center h-100 shadow-sm">
									<div class="card-body">
										<div class="metric-icon mb-3">
											<i class="fas fa-star fa-2x text-warning"></i>
										</div>
										<div class="metric-value display-6 fw-bold text-warning">${averageScore.toFixed(1)}</div>
										<div class="metric-label text-muted">Средний балл</div>
										<div class="metric-subtext small">из ${maxPossible}</div>
									</div>
								</div>
							</div>
							<div class="col-md-3 col-6">
								<div class="metric-card card border-0 text-center h-100 shadow-sm">
									<div class="card-body">
										<div class="metric-icon mb-3">
											<i class="fas fa-percentage fa-2x text-info"></i>
										</div>
										<div class="metric-value display-6 fw-bold text-info">${averagePercentage.toFixed(1)}%</div>
										<div class="metric-label text-muted">Успеваемость</div>
										<div class="metric-subtext small">в процентах</div>
									</div>
								</div>
							</div>
						</div>
					</div>
					
					<!-- Графики -->
					<div class="report-section mb-5">
						<h3 class="mb-4 text-center"><i class="fas fa-chart-bar me-2"></i>ГРАФИКИ И ДИАГРАММЫ</h3>
						<div class="row g-4">
							${generateChartHTML(chartImages)}
						</div>
					</div>
					
					<!-- Подробная статистика -->
					<div class="report-section mb-5">
						<h3 class="mb-4 text-center"><i class="fas fa-list-alt me-2"></i>ПОДРОБНАЯ СТАТИСТИКА</h3>
						
						<div class="row">
							<!-- Общая статистика -->
							<div class="col-md-6 mb-4">
								<div class="card border-0 shadow-sm h-100">
									<div class="card-header bg-light">
										<h5 class="mb-0"><i class="fas fa-calculator me-2"></i>Общая статистика</h5>
									</div>
									<div class="card-body">
										<ul class="list-group list-group-flush">
											<li class="list-group-item d-flex justify-content-between">
												<span>Минимальный балл:</span>
												<span class="fw-bold">${minScore}</span>
											</li>
											<li class="list-group-item d-flex justify-content-between">
												<span>Максимальный балл:</span>
												<span class="fw-bold">${maxScore}</span>
											</li>
											<li class="list-group-item d-flex justify-content-between">
												<span>Размах баллов:</span>
												<span class="fw-bold">${maxScore - minScore}</span>
											</li>
											<li class="list-group-item d-flex justify-content-between">
												<span>Медианный балл:</span>
												<span class="fw-bold">${calculateMedian(totalScores).toFixed(1)}</span>
											</li>
										</ul>
									</div>
								</div>
							</div>
							
							<!-- Распределение оценок -->
							<div class="col-md-6 mb-4">
								<div class="card border-0 shadow-sm h-100">
									<div class="card-header bg-light">
										<h5 class="mb-0"><i class="fas fa-star-half-alt me-2"></i>Распределение оценок</h5>
									</div>
									<div class="card-body">
										<div class="table-responsive">
											<table class="table table-hover">
												<thead>
													<tr>
														<th>Оценка</th>
														<th>Количество</th>
														<th>Процент</th>
													</tr>
												</thead>
												<tbody>
													${generateGradeDistributionHTML(gradeDistribution, studentCount)}
												</tbody>
											</table>
										</div>
									</div>
								</div>
							</div>
						</div>
						
						<!-- Уровни сложности -->
						${taskCount > 0 ? `
							<div class="row mt-4">
								<div class="col-12">
									<div class="card border-0 shadow-sm">
										<div class="card-header bg-light">
											<h5 class="mb-0"><i class="fas fa-layer-group me-2"></i>Анализ по уровням сложности</h5>
										</div>
										<div class="card-body">
											<div class="table-responsive">
												<table class="table table-hover">
													<thead>
														<tr>
															<th>Уровень</th>
															<th>Количество заданий</th>
															<th>Средняя решаемость</th>
															<th>Общий балл</th>
															<th>Средний балл за задание</th>
														</tr>
													</thead>
													<tbody>
														${generateDifficultyAnalysisHTML()}
													</tbody>
												</table>
											</div>
										</div>
									</div>
								</div>
							</div>
						` : ''}
					</div>
					
					<!-- Заключение -->
					<div class="report-section">
						<div class="card border-0 shadow-sm bg-light">
							<div class="card-body text-center">
								<h4 class="mb-3"><i class="fas fa-clipboard-check me-2"></i>ЗАКЛЮЧЕНИЕ</h4>
								<p class="lead mb-4">${generateConclusion(averagePercentage, gradeDistribution)}</p>
								<div class="row">
									<div class="col-md-4">
										<div class="d-flex align-items-center justify-content-center">
											<i class="fas fa-calendar-check fa-2x text-primary me-3"></i>
											<div>
												<div class="fw-bold">Дата отчета</div>
												<div>${new Date().toLocaleDateString('ru-RU')}</div>
											</div>
										</div>
									</div>
									<div class="col-md-4">
										<div class="d-flex align-items-center justify-content-center">
											<i class="fas fa-chart-bar fa-2x text-success me-3"></i>
											<div>
												<div class="fw-bold">Общая успеваемость</div>
												<div>${averagePercentage.toFixed(1)}%</div>
											</div>
										</div>
									</div>
									<div class="col-md-4">
										<div class="d-flex align-items-center justify-content-center">
											<i class="fas fa-user-check fa-2x text-info me-3"></i>
											<div>
												<div class="fw-bold">Учащихся справились</div>
												<div>${calculateSuccessRate(gradeDistribution)}%</div>
											</div>
										</div>
									</div>
								</div>
							</div>
						</div>
					</div>
				</div>
			`;
		}

		// Вспомогательные функции (добавляем недостающие)

		function generateChartHTML(chartImages) {
			let html = '';
			
			if (chartImages.gradesChart) {
				html += `
					<div class="col-md-6">
						<div class="chart-card card border-0 shadow-sm h-100">
							<div class="card-header bg-light">
								<h5 class="mb-0"><i class="fas fa-chart-pie me-2"></i>Распределение оценок</h5>
							</div>
							<div class="card-body text-center">
								<img src="${chartImages.gradesChart}" class="img-fluid rounded" alt="График распределения оценок">
							</div>
						</div>
					</div>
				`;
			} else {
				html += `
					<div class="col-md-6">
						<div class="chart-card card border-0 shadow-sm h-100">
							<div class="card-header bg-light">
								<h5 class="mb-0"><i class="fas fa-chart-pie me-2"></i>Распределение оценок</h5>
							</div>
							<div class="card-body text-center">
								<div class="alert alert-info">
									<i class="fas fa-exclamation-circle me-2"></i>
									График недоступен
								</div>
							</div>
						</div>
					</div>
				`;
			}
			
			if (chartImages.solvabilityChart) {
				html += `
					<div class="col-md-6">
						<div class="chart-card card border-0 shadow-sm h-100">
							<div class="card-header bg-light">
								<h5 class="mb-0"><i class="fas fa-chart-line me-2"></i>Решаемость заданий</h5>
							</div>
							<div class="card-body text-center">
								<img src="${chartImages.solvabilityChart}" class="img-fluid rounded" alt="График решаемости заданий">
							</div>
						</div>
					</div>
				`;
			} else {
				html += `
					<div class="col-md-6">
						<div class="chart-card card border-0 shadow-sm h-100">
							<div class="card-header bg-light">
								<h5 class="mb-0"><i class="fas fa-chart-line me-2"></i>Решаемость заданий</h5>
							</div>
							<div class="card-body text-center">
								<div class="alert alert-info">
									<i class="fas fa-exclamation-circle me-2"></i>
									График недоступен
								</div>
							</div>
						</div>
					</div>
				`;
			}
			
			if (chartImages.complexityChart) {
				html += `
					<div class="col-12 mt-4">
						<div class="chart-card card border-0 shadow-sm">
							<div class="card-header bg-light">
								<h5 class="mb-0"><i class="fas fa-project-diagram me-2"></i>Связь сложности и решаемости</h5>
							</div>
							<div class="card-body text-center">
								<img src="${chartImages.complexityChart}" class="img-fluid rounded" style="max-height: 500px;" alt="График сложности и решаемости">
							</div>
						</div>
					</div>
				`;
			}
			
			return html;
		}

		// Функция для создания упрощенного отчета
		function generateSimpleReport() {
			const reportContent = document.getElementById('reportContent');
			if (!reportContent) return;
			
			const totalScores = appData.results.map(scores => 
				scores.reduce((sum, score) => sum + (parseInt(score) || 0), 0)
			);
			const averageScore = totalScores.reduce((a, b) => a + b, 0) / (totalScores.length || 1);
			const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0);
			const averagePercentage = (averageScore / (maxPossible || 1)) * 100;
			
			reportContent.innerHTML = `
				<div class="report-container">
					<div class="report-header text-center mb-5">
						<h1 class="display-5 fw-bold text-primary mb-3">АНАЛИТИЧЕСКИЙ ОТЧЕТ</h1>
						<p class="text-muted">Упрощенная версия</p>
					</div>
					
					<div class="alert alert-info">
						<i class="fas fa-info-circle me-2"></i>
						<strong>Информация:</strong> Графики недоступны в упрощенной версии отчета.
					</div>
					
					<div class="row mt-4">
						<div class="col-md-6">
							<div class="card">
								<div class="card-header">Основные данные</div>
								<div class="card-body">
									<p><strong>Предмет:</strong> ${appData.test.subject || 'Не указан'}</p>
									<p><strong>Класс:</strong> ${appData.test.class || 'Не указан'}</p>
									<p><strong>Тема:</strong> ${appData.test.theme || 'Не указана'}</p>
									<p><strong>Учащихся:</strong> ${appData.students.length}</p>
								</div>
							</div>
						</div>
						<div class="col-md-6">
							<div class="card">
								<div class="card-header">Статистика</div>
								<div class="card-body">
									<p><strong>Средний балл:</strong> ${averageScore.toFixed(2)} из ${maxPossible}</p>
									<p><strong>Успеваемость:</strong> ${averagePercentage.toFixed(1)}%</p>
									<p><strong>Заданий:</strong> ${appData.tasks.length}</p>
								</div>
							</div>
						</div>
					</div>
					
					<div class="mt-4">
						<button class="btn btn-primary" onclick="tryGenerateFullReport()">
							Попробовать создать полный отчет
						</button>
					</div>
				</div>
			`;
		}
		
		function tryGenerateFullReport() {
			const reportContent = document.getElementById('reportContent');
			if (!reportContent) return;
			
			reportContent.innerHTML = `
				<div class="text-center py-5">
					<div class="spinner-border text-primary" role="status">
						<span class="visually-hidden">Загрузка...</span>
					</div>
					<p class="mt-3">Попытка создания полного отчета...</p>
				</div>
			`;
			
			setTimeout(() => {
				generateReportContent();
			}, 500);
		}
		
		function generateGradeDistributionHTML(gradeDistribution, studentCount) {
			if (!gradeDistribution || Object.keys(gradeDistribution).length === 0) {
				return `
					<tr>
						<td colspan="3" class="text-center text-muted">
							<i class="fas fa-info-circle me-2"></i>
							Нет данных о распределении оценок
						</td>
					</tr>
				`;
			}
			
			return Object.entries(gradeDistribution).map(([grade, count]) => {
				const percentage = ((count / studentCount) * 100).toFixed(1);
				const gradeLabel = getGradeLabel(parseInt(grade));
				return `
					<tr>
						<td>${grade} (${gradeLabel})</td>
						<td>${count}</td>
						<td>
							<div class="d-flex align-items-center">
								<div class="progress flex-grow-1 me-2" style="height: 8px;">
									<div class="progress-bar" style="width: ${percentage}%"></div>
								</div>
								<span>${percentage}%</span>
							</div>
						</td>
					</tr>
				`;
			}).join('');
		}


		function generateDifficultyAnalysisHTML() {
			const analysis = generateDifficultyAnalysis();
			return analysis.map(level => `
				<tr>
					<td>${level.level}</td>
					<td>${level.taskCount}</td>
					<td>
						<div class="d-flex align-items-center">
							<div class="progress flex-grow-1 me-2" style="height: 8px;">
								<div class="progress-bar bg-${getDifficultyColor(level.avgSolvability)}" 
									 style="width: ${level.avgSolvability}%"></div>
							</div>
							<span>${level.avgSolvability.toFixed(1)}%</span>
						</div>
					</td>
					<td>${level.totalScore.toFixed(1)}</td>
					<td>${level.avgScorePerTask.toFixed(1)}</td>
				</tr>
			`).join('');
		}

		async function saveReportAsPDF() {
			showNotification('Создаем PDF версию...', 'info');
			
			try {
				if (typeof window.jspdf === 'undefined') {
					await loadScript('https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js');
					await loadScript('https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js');
				}
				
				const reportContent = document.getElementById('reportContent');
				if (!reportContent) return;
				
				// Используем html2canvas для конвертации всего контента
				const canvas = await html2canvas(reportContent, {
					scale: 2,
					useCORS: true,
					logging: false,
					backgroundColor: '#ffffff'
				});
				
				const { jsPDF } = window.jspdf;
				const pdf = new jsPDF('p', 'mm', 'a4');
				
				const imgData = canvas.toDataURL('image/png', 1.0);
				const imgWidth = 210; // A4 ширина в мм
				const imgHeight = canvas.height * imgWidth / canvas.width;
				
				pdf.addImage(imgData, 'PNG', 0, 0, imgWidth, imgHeight);
				pdf.save(`Аналитический_отчет_${getTimestamp()}.pdf`);
				
				showNotification('PDF отчет сохранен', 'success');
				
			} catch (error) {
				console.error('Ошибка сохранения PDF:', error);
				showNotification('Ошибка сохранения PDF', 'error');
			}
		}

		function addPrintStyles() {
			// Добавляем CSS для печати
			const style = document.createElement('style');
			style.innerHTML = `
				@media print {
					body * {
						visibility: hidden;
					}
					.modal, .modal * {
						visibility: visible;
					}
					.modal {
						position: absolute;
						left: 0;
						top: 0;
						width: 100%;
						height: auto;
						background: white !important;
					}
					.modal-dialog {
						max-width: 100% !important;
						margin: 0 !important;
					}
					.modal-header, .modal-footer {
						display: none !important;
					}
					.report-container {
						padding: 20px;
					}
				}
			`;
			document.head.appendChild(style);
		}

        // Вспомогательные функции для расчетов
        function calculateAverageScore() {
            const totalScores = appData.results.map(scores => scores.reduce((sum, score) => sum + score, 0));
            return totalScores.reduce((sum, score) => sum + score, 0) / totalScores.length;
        }

		function calculateSuccessRate(gradeDistribution) {
			if (!gradeDistribution || Object.keys(gradeDistribution).length === 0) {
				return 0;
			}
			
			const totalStudents = appData.students.length || 1;
			const successful = (gradeDistribution[4] || 0) + (gradeDistribution[5] || 0);
			return ((successful / totalStudents) * 100).toFixed(1);
		}


        function calculateQualityRate() {
            const totalScores = appData.results.map(scores => scores.reduce((sum, score) => sum + score, 0));
            const grades = totalScores.map(score => calculateGrade(score));
            return (grades.filter(grade => grade >= 4).length / grades.length * 100);
        }

        function calculateSou() {
            const totalScores = appData.results.map(scores => scores.reduce((sum, score) => sum + score, 0));
            const grades = totalScores.map(score => calculateGrade(score));
            return (grades.filter(g => g >= 3).length / grades.length * 100);
        }

        // Таксономический анализ
        function updateTaxonomyAnalysis() {
            let html = '<div class="table-container"><table>';
            html += '<thead><tr><th>Уровень</th><th>Задания</th><th>Ср. балл</th><th>% выполнения</th><th>Анализ</th></tr></thead><tbody>';
            
            Object.entries(complexityLevels).forEach(([level, data]) => {
                const levelTasks = appData.tasks.filter(task => task.level == level);
                if (levelTasks.length === 0) {
                    html += `<tr><td>${level}. ${data.name}</td><td>-</td><td>-</td><td>-</td><td>-</td></tr>`;
                    return;
                }
                
                let totalMaxScore = 0;
                let totalActualScore = 0;
                let taskNumbers = [];
                
                levelTasks.forEach((task, index) => {
                    const taskIndex = appData.tasks.indexOf(task);
                    taskNumbers.push(taskIndex + 1);
                    
                    const maxScore = task.maxScore;
                    const actualScores = appData.results.map(student => student[taskIndex] || 0);
                    const actualTotal = actualScores.reduce((sum, score) => sum + score, 0);
                    
                    totalMaxScore += maxScore * appData.results.length;
                    totalActualScore += actualTotal;
                });
                
                const avgScore = totalActualScore / (levelTasks.length * appData.results.length);
                const completion = (totalActualScore / totalMaxScore) * 100;
                
                let analysis = "";
                if (completion >= 80) analysis = "?? Высокий уровень усвоения";
                else if (completion >= 60) analysis = "?? Средний уровень усвоения";
                else if (completion >= 40) analysis = "?? Требуется коррекция";
                else analysis = "?? Серьезные проблемы";
                
                html += `<tr>
                    <td><strong>${level}. ${data.name}</strong></td>
                    <td>${taskNumbers.join(', ')}</td>
                    <td>${avgScore.toFixed(2)}</td>
                    <td>${completion.toFixed(1)}%</td>
                    <td>${analysis}</td>
                </tr>`;
            });
            
            html += '</tbody></table></div>';
            document.getElementById('taxonomyAnalysis').innerHTML = html;
        }

        // Анализ ошибок
        function updateErrorsAnalysis() {
            if (appData.errors.length === 0) {
                document.getElementById('errorsAnalysis').innerHTML = '<p>Данные об ошибках не внесены</p>';
                return;
            }
            
            const errorStats = {};
            Object.keys(errorTypes).forEach(type => {
                errorStats[type] = appData.errors.filter(e => e.type === type).length;
            });
            
            const topErrors = Object.entries(errorStats)
                .filter(([_, count]) => count > 0)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 5);
            
            let html = '<div class="kpi-grid">';
            topErrors.forEach(([type, count]) => {
                html += `
                    <div class="kpi-card">
                        <div class="kpi-value">${count}</div>
                        <div class="kpi-label">${errorTypes[type].name}</div>
                    </div>
                `;
            });
            html += '</div>';
            
            html += '<div class="table-container"><table><thead><tr><th>Тип ошибки</th><th>Кол-во</th><th>% от всех</th><th>Рекомендации</th></tr></thead><tbody>';
            
            topErrors.forEach(([type, count]) => {
                const percentage = (count / appData.errors.length * 100).toFixed(1);
                let recommendation = "";
                
                switch(type) {
                    case 'calculation': recommendation = "Отработка вычислительных навыков"; break;
                    case 'conceptual': recommendation = "Повторение теоретического материала"; break;
                    case 'attention': recommendation = "Тренировка внимательности"; break;
                    case 'application': recommendation = "Решение типовых задач"; break;
                    case 'factual': recommendation = "Закрепление базовых знаний"; break;
                    default: recommendation = "Индивидуальная работа";
                }
                
                html += `<tr>
                    <td><span class="error-type error-${type}">${errorTypes[type].name}</span></td>
                    <td>${count}</td>
                    <td>${percentage}%</td>
                    <td>${recommendation}</td>
                </tr>`;
            });
            
            html += '</tbody></table></div>';
            document.getElementById('errorsAnalysis').innerHTML = html;
        }

        // Персональный анализ
        function updatePersonalAnalysis() {
            const totalScores = appData.results.map(scores => scores.reduce((sum, score) => sum + score, 0));
            const grades = totalScores.map(score => calculateGrade(score));
            const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0);
            
            const excellent = [];
            const good = [];
            const satisfactory = [];
            const unsatisfactory = [];
            
            appData.students.forEach((student, index) => {
                const data = {
                    name: student,
                    score: totalScores[index],
                    grade: grades[index],
                    percentage: (totalScores[index] / maxPossible) * 100,
                    errors: appData.errors.filter(e => e.studentIndex === index)
                };
                
                if (data.grade === 5) excellent.push(data);
                else if (data.grade === 4) good.push(data);
                else if (data.grade === 3) satisfactory.push(data);
                else unsatisfactory.push(data);
            });
            
            let html = `
                <div class="kpi-grid">
                    <div class="kpi-card" style="border-left-color: #27ae60">
                        <div class="kpi-value">${excellent.length}</div>
                        <div class="kpi-label">Отличники (5)</div>
                    </div>
                    <div class="kpi-card" style="border-left-color: #3498db">
                        <div class="kpi-value">${good.length}</div>
                        <div class="kpi-label">Хорошисты (4)</div>
                    </div>
                    <div class="kpi-card" style="border-left-color: #f39c12">
                        <div class="kpi-value">${satisfactory.length}</div>
                        <div class="kpi-label">Удовлетв. (3)</div>
                    </div>
                    <div class="kpi-card" style="border-left-color: #e74c3c">
                        <div class="kpi-value">${unsatisfactory.length}</div>
                        <div class="kpi-label">Неудовл. (2)</div>
                    </div>
                </div>
            `;
            
            html += '<div class="sub-section"><h4>?? Учащиеся группы риска (неудовлетворительно):</h4>';
            if (unsatisfactory.length > 0) {
                unsatisfactory.forEach(student => {
                    html += `<div class="recommendation-card">
                        <strong>${student.name}</strong> - ${student.score} баллов (${student.percentage.toFixed(1)}%)<br>
                        <small>Основные ошибки: ${student.errors.length > 0 ? 
                            student.errors.map(e => errorTypes[e.type].name).join(', ') : 'требуется диагностика'}</small>
                    </div>`;
                });
            } else {
                html += '<p>? Нет учащихся с неудовлетворительными результатами</p>';
            }
            html += '</div>';
            
            document.getElementById('personalAnalysis').innerHTML = html;
        }

        // Аналитика для ВПР
		// Улучшенная функция анализа ВПР
		function updateVPRAnalysis() {
			let html = '<h3 class="section-title">?? Анализ по компетенциям ВПР</h3>';
			
			const competenceStats = {};
			const levelStats = {1: {total: 0, max: 0, count: 0}, 2: {total: 0, max: 0, count: 0}};
			
			// Сбор статистики по компетенциям и уровням
			appData.tasks.forEach((task, taskIndex) => {
				if (task.competence && competenceStats[task.competence]) {
					const maxScore = task.maxScore;
					const actualScores = appData.results.map(student => student[taskIndex] || 0);
					const actualTotal = actualScores.reduce((sum, score) => sum + score, 0);
					
					competenceStats[task.competence].total += actualTotal;
					competenceStats[task.competence].max += maxScore * appData.results.length;
					competenceStats[task.competence].count++;
				}
				
				// Статистика по уровням ВПР
				if (task.vprLevel && levelStats[task.vprLevel]) {
					const maxScore = task.maxScore;
					const actualScores = appData.results.map(student => student[taskIndex] || 0);
					const actualTotal = actualScores.reduce((sum, score) => sum + score, 0);
					
					levelStats[task.vprLevel].total += actualTotal;
					levelStats[task.vprLevel].max += maxScore * appData.results.length;
					levelStats[task.vprLevel].count++;
				}
			});
			
			// KPI по компетенциям
			html += '<div class="kpi-grid">';
			Object.entries(competenceStats).forEach(([comp, stats]) => {
				if (stats.count > 0) {
					const percentage = (stats.total / stats.max) * 100;
					const competenceName = vprCompetencies[comp];
					let status = '';
					
					if (percentage >= 80) status = 'success';
					else if (percentage >= 60) status = 'warning';
					else status = 'danger';
					
					html += `
						<div class="kpi-card ${status}">
							<div class="kpi-value">${percentage.toFixed(1)}%</div>
							<div class="kpi-label">${competenceName}</div>
						</div>
					`;
				}
			});
			html += '</div>';
			
			// Детальная таблица по компетенциям
			html += '<h4 style="margin-top: 20px;">?? Детальный анализ компетенций</h4>';
			html += '<div class="table-container"><table>';
			html += '<thead><tr><th>Компетенция</th><th>% выполнения</th><th>Уровень сформированности</th><th>Рекомендации</th></tr></thead><tbody>';
			
			Object.entries(competenceStats).forEach(([comp, stats]) => {
				if (stats.count > 0) {
					const percentage = (stats.total / stats.max) * 100;
					const competenceName = vprCompetencies[comp];
					
					let level = '';
					let levelColor = '';
					let recommendations = '';
					
					if (percentage >= 80) {
						level = 'Высокий';
						levelColor = '#27ae60';
						recommendations = 'Компетенция сформирована. Продолжать развитие';
					} else if (percentage >= 60) {
						level = 'Средний';
						levelColor = '#f39c12';
						recommendations = 'Требуется дополнительная отработка';
					} else {
						level = 'Низкий';
						levelColor = '#e74c3c';
						recommendations = 'Необходима интенсивная работа';
					}
					
					html += `
						<tr>
							<td><strong>${competenceName}</strong></td>
							<td>${percentage.toFixed(1)}%</td>
							<td style="color: ${levelColor}; font-weight: bold;">${level}</td>
							<td>${recommendations}</td>
						</tr>
					`;
				}
			});
			
			html += '</tbody></table></div>';
			
			// Анализ по уровням ВПР
			html += '<h4 style="margin-top: 20px;">?? Анализ по уровням сложности ВПР</h4>';
			html += '<div class="kpi-grid">';
			
			Object.entries(levelStats).forEach(([level, stats]) => {
				if (stats.count > 0) {
					const percentage = (stats.total / stats.max) * 100;
					const levelName = vprLevels[level].name;
					const levelColor = vprLevels[level].color;
					
					html += `
						<div class="kpi-card" style="border-left-color: ${levelColor}">
							<div class="kpi-value">${percentage.toFixed(1)}%</div>
							<div class="kpi-label">${levelName} уровень</div>
							<small>${stats.count} заданий</small>
						</div>
					`;
				}
			});
			
			html += '</div>';
			
			// Анализ выполнения заданий
			html += '<h4 style="margin-top: 20px;">?? Выполнение заданий ВПР</h4>';
			html += '<div class="table-container"><table>';
			html += '<thead><tr><th>№</th><th>Задание</th><th>Компетенция</th><th>Уровень</th><th>% выполнения</th><th>Статус</th></tr></thead><tbody>';
			
			appData.tasks.forEach((task, index) => {
				const completion = calculateTaskCompletion(index);
				const competenceName = task.competence ? vprCompetencies[task.competence] : 'Не указана';
				const levelName = task.vprLevel ? vprLevels[task.vprLevel].name : 'Не указан';
				
				let status = '';
				let statusColor = '';
				
				if (completion >= 80) {
					status = 'Высокий';
					statusColor = '#27ae60';
				} else if (completion >= 60) {
					status = 'Средний';
					statusColor = '#f39c12';
				} else if (completion >= 40) {
					status = 'Низкий';
					statusColor = '#e74c3c';
				} else {
					status = 'Критический';
					statusColor = '#c0392b';
				}
				
				html += `
					<tr>
						<td><strong>${index + 1}</strong></td>
						<td>${task.type}</td>
						<td>${competenceName}</td>
						<td>${levelName}</td>
						<td>${completion.toFixed(1)}%</td>
						<td style="color: ${statusColor}; font-weight: bold;">${status}</td>
					</tr>
				`;
			});
			
			html += '</tbody></table></div>';
			
			// Рекомендации по ВПР
			html += generateVPRRecommendations(competenceStats, levelStats);
			
			document.getElementById('specializedAnalysis').innerHTML = html;
		}

		// Генерация рекомендаций для ВПР
		function generateVPRRecommendations(competenceStats, levelStats) {
			let html = '<h4 style="margin-top: 20px;">?? Рекомендации по подготовке к ВПР</h4>';
			html += '<div class="recommendation-card">';
			
			// Анализ проблемных компетенций
			const problemCompetences = Object.entries(competenceStats)
				.filter(([_, stats]) => {
					const percentage = (stats.total / stats.max) * 100;
					return percentage < 60;
				})
				.map(([comp, _]) => vprCompetencies[comp]);
			
			if (problemCompetences.length > 0) {
				html += `<strong>?? Проблемные компетенции:</strong> ${problemCompetences.join(', ')}<br>`;
				html += '<strong>Рекомендуется:</strong><br>';
				html += '• Усилить работу над проблемными компетенциями<br>';
				html += '• Использовать типовые задания ВПР для тренировки<br>';
				html += '• Провести дополнительные занятия<br>';
			} else {
				html += '<strong>? Все компетенции сформированы на хорошем уровне</strong><br>';
				html += 'Рекомендуется поддерживать текущий уровень подготовки';
			}
			
			// Анализ уровней сложности
			const baseLevelPercentage = levelStats[1].max > 0 ? (levelStats[1].total / levelStats[1].max) * 100 : 0;
			const advancedLevelPercentage = levelStats[2].max > 0 ? (levelStats[2].total / levelStats[2].max) * 100 : 0;
			
			html += '<br><strong>?? Анализ уровней:</strong><br>';
			html += `• Базовый уровень: ${baseLevelPercentage.toFixed(1)}%<br>`;
			html += `• Повышенный уровень: ${advancedLevelPercentage.toFixed(1)}%<br>`;
			
			if (advancedLevelPercentage < 60) {
				html += '<br><strong>?? Внимание!</strong> Низкие результаты на повышенном уровне.<br>';
				html += 'Необходимо усилить подготовку к сложным заданиям.';
			}
			
			html += '</div>';
			
			// План подготовки
			html += `
				<div class="recommendation-card">
					<h5>?? План подготовки к ВПР</h5>
					<ul>
						<li>Еженедельные тренировочные работы в формате ВПР</li>
						<li>Работа с типовыми заданиями по проблемным компетенциям</li>
						<li>Индивидуальные консультации для отстающих учащихся</li>
						<li>Анализ типичных ошибок и их разбор</li>
						<li>Пробная ВПР за 2 недели до официальной проверки</li>
					</ul>
				</div>
			`;
			
			return html;
		}

        // Аналитика для функциональной грамотности
		function updateLiteracyAnalysis() {
			let html = '<h3 class="section-title">?? Профиль функциональной грамотности класса</h3>';
			
			const literacyStats = {};
			const contextStats = {};
			const skillStats = {};
			
			// Инициализация статистики
			Object.keys(functionalLiteracyTypes).forEach(type => {
				literacyStats[type] = { total: 0, max: 0, count: 0 };
			});
			
			Object.keys(literacyContexts).forEach(context => {
				contextStats[context] = { total: 0, max: 0, count: 0 };
			});
			
			// Сбор статистики
			appData.tasks.forEach((task, taskIndex) => {
				if (task.literacyType && literacyStats[task.literacyType]) {
					const maxScore = task.maxScore;
					const actualScores = appData.results.map(student => student[taskIndex] || 0);
					const actualTotal = actualScores.reduce((sum, score) => sum + score, 0);
					
					literacyStats[task.literacyType].total += actualTotal;
					literacyStats[task.literacyType].max += maxScore * appData.results.length;
					literacyStats[task.literacyType].count++;
				}
				
				if (task.context && contextStats[task.context]) {
					const maxScore = task.maxScore;
					const actualScores = appData.results.map(student => student[taskIndex] || 0);
					const actualTotal = actualScores.reduce((sum, score) => sum + score, 0);
					
					contextStats[task.context].total += actualTotal;
					contextStats[task.context].max += maxScore * appData.results.length;
					contextStats[task.context].count++;
				}
				
				// Статистика по навыкам
				if (task.skill) {
					if (!skillStats[task.skill]) {
						skillStats[task.skill] = { total: 0, max: 0, count: 0 };
					}
					
					const maxScore = task.maxScore;
					const actualScores = appData.results.map(student => student[taskIndex] || 0);
					const actualTotal = actualScores.reduce((sum, score) => sum + score, 0);
					
					skillStats[task.skill].total += actualTotal;
					skillStats[task.skill].max += maxScore * appData.results.length;
					skillStats[task.skill].count++;
				}
			});
			
			// KPI по видам грамотности
			html += '<h4>?? Уровень сформированности видов грамотности</h4>';
			html += '<div class="kpi-grid">';
			
			Object.entries(literacyStats).forEach(([type, stats]) => {
				if (stats.count > 0) {
					const percentage = (stats.total / stats.max) * 100;
					const literacyData = functionalLiteracyTypes[type];
					
					let status = '';
					if (percentage >= 80) status = 'success';
					else if (percentage >= 60) status = 'warning';
					else status = 'danger';
					
					html += `
						<div class="kpi-card ${status}" style="border-left-color: ${literacyData.color}">
							<div class="kpi-value">${percentage.toFixed(1)}%</div>
							<div class="kpi-label">${literacyData.name}</div>
							<small>${stats.count} заданий</small>
						</div>
					`;
				}
			});
			
			html += '</div>';
			
			// Детальный анализ видов грамотности
			html += '<h4 style="margin-top: 20px;">?? Детальный анализ грамотности</h4>';
			html += '<div class="table-container"><table>';
			html += '<thead><tr><th>Вид грамотности</th><th>% выполнения</th><th>Уровень</th><th>Интерпретация</th></tr></thead><tbody>';
			
			Object.entries(literacyStats).forEach(([type, stats]) => {
				if (stats.count > 0) {
					const percentage = (stats.total / stats.max) * 100;
					const literacyData = functionalLiteracyTypes[type];
					
					let level = '';
					let interpretation = '';
					
					if (percentage >= 80) {
						level = 'Продвинутый';
						interpretation = 'Навык устойчиво сформирован';
					} else if (percentage >= 60) {
						level = 'Базовый';
						interpretation = 'Навык сформирован на допустимом уровне';
					} else if (percentage >= 40) {
						level = 'Ограниченный';
						interpretation = 'Навык требует развития';
					} else {
						level = 'Начальный';
						interpretation = 'Навык практически не сформирован';
					}
					
					html += `
						<tr>
							<td><strong>${literacyData.name}</strong></td>
							<td>${percentage.toFixed(1)}%</td>
							<td style="color: ${literacyData.color}; font-weight: bold;">${level}</td>
							<td>${interpretation}</td>
						</tr>
					`;
				}
			});
			
			html += '</tbody></table></div>';
			
			// Анализ по контекстам
			html += '<h4 style="margin-top: 20px;">?? Анализ по контекстам применения</h4>';
			html += '<div class="kpi-grid">';
			
			Object.entries(contextStats).forEach(([context, stats]) => {
				if (stats.count > 0) {
					const percentage = (stats.total / stats.max) * 100;
					const contextName = literacyContexts[context];
					
					html += `
						<div class="kpi-card">
							<div class="kpi-value">${percentage.toFixed(1)}%</div>
							<div class="kpi-label">${contextName} контекст</div>
							<small>${stats.count} заданий</small>
						</div>
					`;
				}
			});
			
			html += '</div>';
			
			// Анализ конкретных навыков
			if (Object.keys(skillStats).length > 0) {
				html += '<h4 style="margin-top: 20px;">??? Анализ конкретных навыков</h4>';
				html += '<div class="table-container"><table>';
				html += '<thead><tr><th>Навык</th><th>% выполнения</th><th>Статус</th><th>Рекомендации</th></tr></thead><tbody>';
				
				Object.entries(skillStats).forEach(([skill, stats]) => {
					const percentage = (stats.total / stats.max) * 100;
					
					let status = '';
					let recommendations = '';
					
					if (percentage >= 80) {
						status = 'Освоен';
						recommendations = 'Закреплять применение в новых ситуациях';
					} else if (percentage >= 60) {
						status = 'Частично освоен';
						recommendations = 'Требуется дополнительная практика';
					} else {
						status = 'Не освоен';
						recommendations = 'Необходимо целенаправленное формирование';
					}
					
					html += `
						<tr>
							<td>${skill}</td>
							<td>${percentage.toFixed(1)}%</td>
							<td>${status}</td>
							<td>${recommendations}</td>
						</tr>
					`;
				});
				
				html += '</tbody></table></div>';
			}
			
			// Радарная диаграмма
			// ПОЛНАЯ ЗАМЕНА блока с радарной диаграммой
			html += `
<div class="chart-container" style="
    height: 450px; 
    min-height: 450px; 
    position: relative; 
    margin: 25px 0; 
    border: 1px solid #e0e0e0; 
    border-radius: 10px; 
    padding: 20px; 
    background: white;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
">
    <h4 style="margin: 0 0 20px 0; padding: 0; color: #2c3e50;">?? Визуальный профиль грамотности</h4>
    <div style="height: 380px; position: relative; background: #f8f9fa; border-radius: 6px; padding: 10px;">
        <canvas id="literacyRadarChart" 
                style="display: block; width: 100%; height: 100%; background: white; border-radius: 4px;"></canvas>
    </div>
</div>
			`;
			
			// Рекомендации по развитию
			html += generateLiteracyRecommendations(literacyStats, contextStats, skillStats);
			
			document.getElementById('specializedAnalysis').innerHTML = html;
			
			// Инициализация диаграммы
			setTimeout(() => {
				initLiteracyRadarChart();
			}, 100);
		}

		// Генерация рекомендаций по функциональной грамотности
		function generateLiteracyRecommendations(literacyStats, contextStats, skillStats) {
			let html = '<h4 style="margin-top: 20px;">?? Рекомендации по развитию функциональной грамотности</h4>';
			html += '<div class="recommendation-card">';
			
			// Анализ проблемных видов грамотности
			const problemLiteracies = Object.entries(literacyStats)
				.filter(([_, stats]) => {
					const percentage = (stats.total / stats.max) * 100;
					return percentage < 60;
				})
				.map(([type, _]) => functionalLiteracyTypes[type].name);
			
			if (problemLiteracies.length > 0) {
				html += `<strong>?? Требуют развития:</strong> ${problemLiteracies.join(', ')}<br>`;
				html += '<strong>Меры по развитию:</strong><br>';
				
				problemLiteracies.forEach(literacy => {
					switch(literacy) {
						case 'Читательская грамотность':
							html += '• Включить работу с различными типами текстов<br>';
							break;
						case 'Математическая грамотность':
							html += '• Решение прикладных математических задач<br>';
							break;
						case 'Естественнонаучная грамотность':
							html += '• Проведение исследовательских проектов<br>';
							break;
						case 'Финансовая грамотность':
							html += '• Решение практических финансовых задач<br>';
							break;
						case 'Глобальные компетенции':
							html += '• Обсуждение глобальных проблем современности<br>';
							break;
						case 'Цифровая грамотность':
							html += '• Работа с цифровыми инструментами и информацией<br>';
							break;
					}
				});
			} else {
				html += '<strong>? Все виды грамотности развиты на хорошем уровне</strong><br>';
				html += 'Рекомендуется поддерживать и углублять сформированные навыки';
			}
			
			// Анализ контекстов
			const problemContexts = Object.entries(contextStats)
				.filter(([_, stats]) => {
					const percentage = (stats.total / stats.max) * 100;
					return percentage < 60;
				})
				.map(([context, _]) => literacyContexts[context]);
			
			if (problemContexts.length > 0) {
				html += `<br><strong>?? Слабые контексты:</strong> ${problemContexts.join(', ')}<br>`;
				html += 'Необходимо разнообразить контексты применения знаний';
			}
			
			html += '</div>';
			
			// Стратегия развития
			html += `
				<div class="recommendation-card">
					<h5>?? Стратегия развития функциональной грамотности</h5>
					<ul>
						<li>Интеграция заданий на функциональную грамотность в урочную деятельность</li>
						<li>Организация межпредметных проектов</li>
						<li>Использование реальных жизненных ситуаций в обучении</li>
						<li>Развитие критического мышления и работы с информацией</li>
						<li>Формирование навыков самооценки и рефлексии</li>
					</ul>
				</div>
			`;
			
			return html;
		}

        function initLiteracyChart() {
            if (window.literacyChartInstance) {
                window.literacyChartInstance.destroy();
            }
            
            const literacyStats = {};
            Object.keys(functionalLiteracyTypes).forEach(type => {
                literacyStats[type] = { total: 0, max: 0, count: 0 };
            });
            
            appData.tasks.forEach((task, taskIndex) => {
                if (task.literacyType && literacyStats[task.literacyType]) {
                    const maxScore = task.maxScore;
                    const actualScores = appData.results.map(student => student[taskIndex] || 0);
                    const actualTotal = actualScores.reduce((sum, score) => sum + score, 0);
                    
                    literacyStats[task.literacyType].total += actualTotal;
                    literacyStats[task.literacyType].max += maxScore * appData.results.length;
                }
            });
            
            const ctx = document.getElementById('literacyChart').getContext('2d');
            const labels = Object.keys(literacyStats).map(type => functionalLiteracyTypes[type].name);
            const data = Object.values(literacyStats).map(stats => 
                stats.max > 0 ? (stats.total / stats.max) * 100 : 0
            );
            const colors = Object.keys(literacyStats).map(type => functionalLiteracyTypes[type].color);
            
            window.literacyChartInstance = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Уровень грамотности (%)',
                        data: data,
                        backgroundColor: 'rgba(54, 162, 235, 0.2)',
                        borderColor: 'rgba(54, 162, 235, 0.8)',
                        pointBackgroundColor: colors,
                        pointBorderColor: '#fff',
                        pointHoverBackgroundColor: '#fff',
                        pointHoverBorderColor: colors
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        r: {
                            beginAtZero: true,
                            max: 100,
                            ticks: {
                                callback: function(value) {
                                    return value + '%';
                                }
                            }
                        }
                    }
                }
            });
        }

        // Аналитика для ОГЭ/ЕГЭ
		function updateGIAnalysis() {
			let html = '<h3 class="section-title">?? Анализ по тематическим блокам (КЭС)</h3>';
			
			const kesStats = {};
			const puStats = {};
			
			// Группировка заданий по КЭС и ПУ
			appData.tasks.forEach((task, taskIndex) => {
				if (task.kes) {
					const kesCode = task.kes.split('.')[0];
					if (!kesStats[kesCode]) {
						kesStats[kesCode] = { 
							total: 0, 
							max: 0, 
							count: 0, 
							tasks: [],
							name: getKESName(kesCode)
						};
					}
					
					const maxScore = task.maxScore;
					const actualScores = appData.results.map(student => student[taskIndex] || 0);
					const actualTotal = actualScores.reduce((sum, score) => sum + score, 0);
					
					kesStats[kesCode].total += actualTotal;
					kesStats[kesCode].max += maxScore * appData.results.length;
					kesStats[kesCode].count++;
					kesStats[kesCode].tasks.push(taskIndex + 1);
				}
				
				// Анализ по проверяемым умениям (ПУ)
				if (task.pu) {
					if (!puStats[task.pu]) {
						puStats[task.pu] = { 
							total: 0, 
							max: 0, 
							count: 0,
							tasks: []
						};
					}
					
					const maxScore = task.maxScore;
					const actualScores = appData.results.map(student => student[taskIndex] || 0);
					const actualTotal = actualScores.reduce((sum, score) => sum + score, 0);
					
					puStats[task.pu].total += actualTotal;
					puStats[task.pu].max += maxScore * appData.results.length;
					puStats[task.pu].count++;
					puStats[task.pu].tasks.push(taskIndex + 1);
				}
			});
			
			// Если нет данных по КЭС, показываем общий анализ
			if (Object.keys(kesStats).length === 0) {
				html += `
					<div class="alert-card">
						<strong>?? Данные по КЭС не заполнены</strong>
						<p>Для анализа ОГЭ заполните коды КЭС в настройках заданий.</p>
					</div>
					
					<h4>?? Общий анализ заданий ОГЭ</h4>
					<div class="kpi-grid">
						<div class="kpi-card">
							<div class="kpi-value">${calculateAverageScore().toFixed(1)}</div>
							<div class="kpi-label">Средний балл</div>
						</div>
						<div class="kpi-card">
							<div class="kpi-value">${calculateSuccessRate().toFixed(1)}%</div>
							<div class="kpi-label">Успеваемость</div>
						</div>
						<div class="kpi-card">
							<div class="kpi-value">${calculateTaskCompletion(0).toFixed(1)}%</div>
							<div class="kpi-label">1 часть</div>
						</div>
						<div class="kpi-card">
							<div class="kpi-value">${calculateTaskCompletion(appData.tasks.length-1).toFixed(1)}%</div>
							<div class="kpi-label">2 часть</div>
						</div>
					</div>
				`;
			} else {
				// Анализ по КЭС
				html += '<div class="table-container"><table>';
				html += '<thead><tr><th>Блок КЭС</th><th>Название</th><th>Задания</th><th>% выполнения</th><th>Анализ</th></tr></thead><tbody>';
				
				Object.entries(kesStats).forEach(([kes, stats]) => {
					const percentage = stats.max > 0 ? (stats.total / stats.max) * 100 : 0;
					let analysis = "";
					let analysisIcon = "";
					
					if (percentage >= 80) {
						analysis = "Высокий уровень";
						analysisIcon = "??";
					} else if (percentage >= 60) {
						analysis = "Средний уровень";
						analysisIcon = "??";
					} else if (percentage >= 40) {
						analysis = "Требует внимания";
						analysisIcon = "??";
					} else {
						analysis = "Критический уровень";
						analysisIcon = "??";
					}
					
					html += `<tr>
						<td><strong>${kes}</strong></td>
						<td>${stats.name || 'Не указано'}</td>
						<td>${stats.tasks.join(', ')}</td>
						<td>${percentage.toFixed(1)}%</td>
						<td>${analysisIcon} ${analysis}</td>
					</tr>`;
				});
				
				html += '</tbody></table></div>';
			}
			
			// Анализ по проверяемым умениям
			if (Object.keys(puStats).length > 0) {
				html += '<h4 style="margin-top: 20px;">?? Анализ по проверяемым умениям (ПУ)</h4>';
				html += '<div class="table-container"><table>';
				html += '<thead><tr><th>Проверяемое умение</th><th>Задания</th><th>% выполнения</th><th>Уровень</th></tr></thead><tbody>';
				
				Object.entries(puStats).forEach(([pu, stats]) => {
					const percentage = stats.max > 0 ? (stats.total / stats.max) * 100 : 0;
					let level = "";
					
					if (percentage >= 80) level = "Освоено";
					else if (percentage >= 60) level = "Частично освоено";
					else if (percentage >= 40) level = "Требует доработки";
					else level = "Не освоено";
					
					html += `<tr>
						<td>${pu}</td>
						<td>${stats.tasks.join(', ')}</td>
						<td>${percentage.toFixed(1)}%</td>
						<td>${level}</td>
					</tr>`;
				});
				
				html += '</tbody></table></div>';
			}
			
			// Рекомендации по подготовке к ОГЭ
			html += generateOGERecommendations();
			
			document.getElementById('specializedAnalysis').innerHTML = html;
		}

		// Функция для получения названий блоков КЭС
		function getKESName(kesCode) {
			const kesNames = {
				'1': 'Числа и вычисления',
				'2': 'Алгебраические выражения',
				'3': 'Уравнения и неравенства',
				'4': 'Числовые последовательности',
				'5': 'Функции',
				'6': 'Координаты на прямой и плоскости',
				'7': 'Геометрические фигуры и их свойства',
				'8': 'Измерение геометрических величин',
				'9': 'Векторы на плоскости'
			};
			return kesNames[kesCode] || 'Неизвестный блок';
		}

		// Генерация рекомендаций для ОГЭ
		function generateOGERecommendations() {
			const totalScores = appData.results.map(scores => scores.reduce((sum, score) => sum + score, 0));
			const avgScore = totalScores.reduce((sum, score) => sum + score, 0) / totalScores.length;
			const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0);
			
			let html = '<h4 style="margin-top: 20px;">?? Рекомендации по подготовке к ОГЭ</h4>';
			html += '<div class="recommendation-card">';
			
			// Анализ результатов
			const percentage = (avgScore / maxPossible) * 100;
			
			if (percentage >= 80) {
				html += '<strong>? Высокий уровень подготовки</strong><br>';
				html += 'Учащиеся демонстрируют отличную подготовку к ОГЭ. ';
				html += 'Рекомендуется:<br>';
				html += '• Работа над сложными заданиями второй части<br>';
				html += '• Тренировка скорости выполнения<br>';
				html += '• Решение задач повышенной сложности<br>';
			} else if (percentage >= 60) {
				html += '<strong>?? Средний уровень подготовки</strong><br>';
				html += 'Учащиеся усвоили базовые темы, но есть пробелы. ';
				html += 'Рекомендуется:<br>';
				html += '• Повторение проблемных тем<br>';
				html += '• Отработка типовых заданий<br>';
				html += '• Работа над заданиями с развернутым ответом<br>';
			} else if (percentage >= 40) {
				html += '<strong>?? Требуется усиленная подготовка</strong><br>';
				html += 'Есть значительные пробелы в знаниях. ';
				html += 'Рекомендуется:<br>';
				html += '• Систематическое повторение базовых тем<br>';
				html += '• Индивидуальная работа с отстающими<br>';
				html += '• Решение задач базового уровня<br>';
			} else {
				html += '<strong>?? Критический уровень подготовки</strong><br>';
				html += 'Требуется срочное вмешательство. ';
				html += 'Рекомендуется:<br>';
				html += '• Интенсивная индивидуальная работа<br>';
				html += '• Фокус на базовых темах<br>';
				html += '• Привлечение родителей к контролю<br>';
			}
			
			// Анализ типов заданий
			const firstPartTasks = appData.tasks.filter(task => task.answerType === 'short');
			const secondPartTasks = appData.tasks.filter(task => task.answerType === 'detailed');
			
			if (firstPartTasks.length > 0 && secondPartTasks.length > 0) {
				const firstPartCompletion = firstPartTasks.reduce((sum, task) => {
					const taskIndex = appData.tasks.indexOf(task);
					return sum + calculateTaskCompletion(taskIndex);
				}, 0) / firstPartTasks.length;
				
				const secondPartCompletion = secondPartTasks.reduce((sum, task) => {
					const taskIndex = appData.tasks.indexOf(task);
					return sum + calculateTaskCompletion(taskIndex);
				}, 0) / secondPartTasks.length;
				
				html += `<br><strong>Анализ частей экзамена:</strong><br>`;
				html += `• 1 часть (тестовая): ${firstPartCompletion.toFixed(1)}%<br>`;
				html += `• 2 часть (развернутая): ${secondPartCompletion.toFixed(1)}%<br>`;
				
				if (secondPartCompletion < 50) {
					html += '<br><strong>?? Внимание!</strong> Низкие результаты во 2 части. Необходимо усилить подготовку к заданиям с развернутым ответом.';
				}
			}
			
			html += '</div>';
			
			return html;
		}


        // ==================== ВИЗУАЛИЗАЦИЯ ====================
		function addVisualizationButton() {
			const nav = document.querySelector('.nav-tabs, .navigation, header');
			if (nav) {
				const button = document.createElement('button');
				button.className = 'btn btn-primary';
				button.innerHTML = '?? Графики';
				button.onclick = () => {
					renderVisualizationSection();
					showNotification('Графики обновлены', 'success');
				};
				nav.appendChild(button);
			}
		}
				
		// Вызовите при загрузке
		document.addEventListener('DOMContentLoaded', function() {
			addVisualizationButton();
		});
		
		function updateVisualization() {
			console.log('=== ОБНОВЛЕНИЕ ВИЗУАЛИЗАЦИИ ===');
			
			try {
				// Проверяем, настроена ли вкладка visualization
				const vizTab = document.getElementById('visualization');
				const gradesChart = document.getElementById('gradesChart');
				
				if (!gradesChart || !vizTab || vizTab.innerHTML.trim().length < 100) {
					console.log('Вкладка visualization не настроена, настраиваем...');
					setupVisualizationTab();
					return;
				}
				
				// Уничтожаем старые графики ТУТ
				destroyAllCharts();
				
				// Ждем рендеринга DOM
				setTimeout(() => {
					try {
						// Обновляем все графики
						updateCharts();
						
						// Обновляем тепловую карту
						updateHeatmap();
						
						// Проверяем специализированные графики
						if (appData.test.workType === 'func_literacy') {
							console.log('Инициализация графиков функциональной грамотности');
							initLiteracyCharts();
						} else if (appData.test.workType === 'psychology') {
							console.log('Инициализация психологических графики');
							initPsychologyCharts();
						}
						
						// Принудительный ресайз после загрузки
						setTimeout(() => {
							safeResizeCharts();
							console.log('Все графики обновлены');
						}, 300);
						
					} catch (error) {
						console.error('Ошибка при создании графиков:', error);
						showChartError();
					}
				}, 150);
				
			} catch (error) {
				console.error('Критическая ошибка в updateVisualization:', error);
				showNotification('Ошибка обновления визуализации', 'error');
			}
		}
		// Найдите навигационные табы и добавьте обработчик
		function setupTabsNavigation() {
			const tabs = document.querySelectorAll('.nav-link');
			tabs.forEach(tab => {
				tab.addEventListener('click', function() {
					const tabId = this.getAttribute('href')?.replace('#', '');
					if (tabId === 'visualization') {
						console.log('Переход на вкладку visualization');
						
						// Небольшая задержка для рендеринга DOM
						setTimeout(() => {
							if (document.getElementById('visualization').querySelectorAll('canvas').length === 0) {
								console.log('Вкладка пустая, настраиваем...');
								setupVisualizationTab();
							} else {
								console.log('Обновляем существующие графики...');
								updateVisualization();
							}
						}, 100);
					}
				});
			});
		}

		// Вызовите при загрузке
		document.addEventListener('DOMContentLoaded', function() {
			setupTabsNavigation();
			console.log('Навигация по вкладкам настроена');
		});

        // Обновление графиков
		function updateCharts() {
			console.log('updateCharts вызвана, данные:', {
				results: appData.results.length,
				tasks: appData.tasks.length
			});
			
			if (appData.results.length === 0 || appData.tasks.length === 0) {
				console.log('Нет данных для построения графиков');
				showNoDataMessage();
				return;
			}
			
			try {
				// 1. График распределения оценок
				updateGradesChart();
				
				// 2. График решаемости заданий
				updateSolvabilityChart();
				
				// 3. График связи сложности и решаемости
				updateComplexityChart();
				
			} catch (error) {
				console.error('Ошибка в updateCharts:', error);
				throw error;
			}
		}

		function updateGradesChart() {
			const canvas = document.getElementById('gradesChart');
			if (!canvas) {
				console.warn('Canvas gradesChart не найден');
				return;
			}
			
			console.log('Создание графика оценок...');
			
			// Проверяем, нет ли уже активного графика на этом canvas
			const existingChart = Chart.getChart(canvas);
			if (existingChart) {
				console.log(`На canvas ${canvas.id} уже есть график с ID ${existingChart.id}, уничтожаем...`);
				existingChart.destroy();
			}
			
			// Проверяем canvas контекст
			if (!canvas.getContext) {
				console.error('Canvas не поддерживает getContext');
				return;
			}
			

			
			console.log('Создание графика оценок...');
			
			const totalScores = appData.results.map(scores => 
				scores.reduce((sum, score) => sum + (parseInt(score) || 0), 0)
			);
			
			const grades = totalScores.map(score => {
				const grade = calculateGrade(score);
				console.log(`Баллы: ${score}, Оценка: ${grade}`);
				return grade;
			});
			
			console.log('Все оценки:', grades);
			
			// Считаем распределение оценок
			const gradeCounts = {};
			grades.forEach(grade => {
				if (grade && grade !== '?') {
					gradeCounts[grade] = (gradeCounts[grade] || 0) + 1;
				}
			});
			
			console.log('Распределение оценок:', gradeCounts);
			
			// Создаем массив для Chart.js
			const labels = Object.keys(gradeCounts).sort();
			const data = labels.map(label => gradeCounts[label]);
			const backgroundColors = labels.map(label => getGradeColor(label));
			
			if (labels.length === 0) {
				canvas.parentElement.innerHTML = '<p style="color: #666; text-align: center; padding: 20px;">Нет данных для построения графика оценок</p>';
				return;
			}
			
			const ctx = canvas.getContext('2d');
			window.gradesChartInstance = new Chart(ctx, {
				type: 'doughnut',
				data: {
					labels: labels.map(label => `Оценка ${label}`),
					datasets: [{
						data: data,
						backgroundColor: backgroundColors,
						borderWidth: 2,
						borderColor: '#fff',
						hoverOffset: 10
					}]
				},
				options: {
					responsive: true,
					maintainAspectRatio: false,
					plugins: {
						legend: { 
							position: 'bottom',
							labels: {
								padding: 20,
								usePointStyle: true,
								font: { size: 12 }
							}
						},
						tooltip: {
							callbacks: {
								label: function(context) {
									const label = context.label || '';
									const value = context.raw || 0;
									const total = context.dataset.data.reduce((a, b) => a + b, 0);
									const percentage = Math.round((value / total) * 100);
									return `${label}: ${value} уч. (${percentage}%)`;
								}
							}
						},
						title: {
							display: true,
							text: 'Распределение оценок',
							font: { size: 16, weight: 'bold' },
							padding: { top: 10, bottom: 20 }
						}
					},
					cutout: '50%'
				}
			});
		}

		function updateSolvabilityChart() {
			const canvas = document.getElementById('solvabilityChart');
			if (!canvas) {
				console.warn('Canvas solvabilityChart не найден');
				return;
			}
			
			console.log('Создание графика решаемости...');
			
			// Рассчитываем решаемость каждого задания
			const taskStats = [];
			for (let i = 0; i < appData.tasks.length; i++) {
				const task = appData.tasks[i];
				const maxScore = parseInt(task.maxScore) || 1;
				const actualScores = appData.results.map(student => parseInt(student[i]) || 0);
				const actualTotal = actualScores.reduce((sum, score) => sum + score, 0);
				const completion = maxScore > 0 ? (actualTotal / (maxScore * appData.results.length)) * 100 : 0;
				
				taskStats.push({
					taskNumber: i + 1,
					completion: completion,
					type: task.type,
					level: task.level
				});
			}
			
			console.log('Статистика заданий:', taskStats);
			
			const ctx = canvas.getContext('2d');
			window.solvabilityChartInstance = new Chart(ctx, {
				type: 'bar',
				data: {
					labels: taskStats.map(t => `Зад. ${t.taskNumber}`),
					datasets: [{
						label: '% выполнения',
						data: taskStats.map(t => t.completion),
						backgroundColor: taskStats.map(t => complexityLevels[t.level]?.color || '#3498db'),
						borderColor: '#2c3e50',
						borderWidth: 1
					}]
				},
				options: {
					responsive: true,
					maintainAspectRatio: false,
					scales: {
						x: {
							title: { 
								display: true, 
								text: 'Номер задания',
								font: { size: 14, weight: 'bold' }
							},
							grid: { display: false }
						},
						y: {
							title: { 
								display: true, 
								text: 'Процент выполнения',
								font: { size: 14, weight: 'bold' }
							},
							min: 0,
							max: 100,
							ticks: {
								callback: function(value) {
									return value + '%';
								}
							}
						}
					},
					plugins: {
						legend: { display: false },
						tooltip: {
							callbacks: {
								label: function(context) {
									const task = taskStats[context.dataIndex];
									return [
										`Задание ${task.taskNumber}: ${task.type}`,
										`Уровень сложности: ${task.level}`,
										`Выполнение: ${context.raw.toFixed(1)}%`
									];
								}
							}
						},
						title: {
							display: true,
							text: 'Решаемость заданий',
							font: { size: 16, weight: 'bold' },
							padding: { top: 10, bottom: 20 }
						}
					}
				}
			});
		}
		function createAllCharts() {
			// Проверяем наличие всех canvas элементов
			const chartIds = ['gradesChart', 'solvabilityChart', 'complexityChart'];
			
			chartIds.forEach(id => {
				if (!document.getElementById(id)) {
					console.log(`Создаем canvas для ${id}...`);
					createChartContainer(id);
				}
			});
		}

		function createChartContainer(chartId) {
			const container = document.getElementById('chartsContainer') || createChartsSection();
			
			const chartContainer = document.createElement('div');
			chartContainer.className = 'chart-container';
			chartContainer.innerHTML = `
				<h3>${getChartTitle(chartId)}</h3>
				<div class="chart-wrapper">
					<canvas id="${chartId}"></canvas>
				</div>
			`;
			
			container.appendChild(chartContainer);
			return chartContainer;
		}

		function getChartTitle(chartId) {
			const titles = {
				'gradesChart': '?? Распределение оценок',
				'solvabilityChart': '?? Решаемость заданий',
				'complexityChart': '?? Сложность vs Решаемость'
			};
			return titles[chartId] || chartId;
		}
		// Добавьте в консоли
		function findChartsContainer() {
			console.log('=== ПОИСК КОНТЕЙНЕРА ГРАФИКОВ ===');
			
			// Возможные контейнеры
			const possibleIds = [
				'visualizationContainer', 'chartsContainer', 'graphsContainer',
				'analyticsContainer', 'statisticsContainer', 'resultsCharts'
			];
			
			const possibleClasses = [
				'charts-section', 'graphs-section', 'visualization-section',
				'analytics-tab', 'statistics-tab', 'chart-container'
			];
			
			// Ищем по ID
			console.log('Поиск по ID:');
			possibleIds.forEach(id => {
				const element = document.getElementById(id);
				if (element) {
					console.log(`? Найден: #${id}`, element);
					console.log('  Внутренний HTML:', element.innerHTML.substring(0, 200) + '...');
				}
			});
			
			// Ищем по классам
			console.log('\nПоиск по классам:');
			possibleClasses.forEach(className => {
				const elements = document.getElementsByClassName(className);
				if (elements.length > 0) {
					console.log(`? Найдены элементы с классом .${className}:`, elements.length);
					console.log('  Первый элемент:', elements[0]);
				}
			});
			
			// Ищем все canvas
			console.log('\nВсе canvas на странице:');
			const allCanvas = document.getElementsByTagName('canvas');
			console.log(`Всего canvas: ${allCanvas.length}`);
			for (let i = 0; i < allCanvas.length; i++) {
				const canvas = allCanvas[i];
				console.log(`${i+1}. id="${canvas.id}", родитель:`, canvas.parentElement);
			}
			
			// Ищем вкладки/табы
			console.log('\nВсе вкладки (tabs):');
			const tabs = document.querySelectorAll('[role="tab"], .tab-pane, .tab-content');
			tabs.forEach(tab => {
				console.log('Вкладка:', tab.id || tab.className, tab);
			});
		}

		function setupVisualizationTab() {
			console.log('=== НАСТРОЙКА ВКЛАДКИ ВИЗУАЛИЗАЦИИ ===');
			
			const vizTab = document.getElementById('visualization');
			if (!vizTab) {
				console.error('Вкладка visualization не найдена!');
				return;
			}
			
			destroyAllCharts();
			
			// Очищаем вкладку
			vizTab.innerHTML = '';
			
			// Заголовок
			vizTab.innerHTML += `
				<h2>?? Визуализация результатов</h2>
				
				<div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
					<button class="btn btn-primary" onclick="updateVisualization()" style="margin-right: 10px;">
						?? Обновить графики
					</button>
					<button class="btn btn-warning" onclick="exportAllCharts()" style="margin-right: 10px;">
						?? Экспорт всех графиков
					</button>
					<button class="btn" onclick="toggleDarkMode()" style="margin-right: 10px;">
						?? Темный режим
					</button>
					<button class="btn" onclick="debugCharts()">
						?? Отладка
					</button>
				</div>
				
				<div class="charts-grid" id="chartsGrid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 20px; margin-bottom: 30px;">
					<!-- График 1: Распределение оценок -->
					<div class="chart-card" style="background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
						<h3 style="margin-top: 0; margin-bottom: 15px; color: #2c3e50;">
							?? Распределение оценок
						</h3>
						<div style="position: relative; height: 300px;">
							<canvas id="gradesChart"></canvas>
						</div>
						<p style="margin-top: 10px; font-size: 12px; color: #666; text-align: center;">
							Распределение учащихся по полученным оценкам
						</p>
					</div>
					
					<!-- График 2: Решаемость заданий -->
					<div class="chart-card" style="background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
						<h3 style="margin-top: 0; margin-bottom: 15px; color: #2c3e50;">
							?? Решаемость заданий
						</h3>
						<div style="position: relative; height: 300px;">
							<canvas id="solvabilityChart"></canvas>
						</div>
						<p style="margin-top: 10px; font-size: 12px; color: #666; text-align: center;">
							Процент выполнения каждого задания
						</p>
					</div>
					
					<!-- График 3: Сложность vs Решаемость -->
					<div class="chart-card" style="background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
						<h3 style="margin-top: 0; margin-bottom: 15px; color: #2c3e50;">
							?? Сложность vs Решаемость
						</h3>
						<div style="position: relative; height: 300px;">
							<canvas id="complexityChart"></canvas>
						</div>
						<p style="margin-top: 10px; font-size: 12px; color: #666; text-align: center;">
							Зависимость между уровнем сложности и процентом выполнения
						</p>
					</div>
				</div>
				
				<!-- Тепловая карта -->
				<div class="chart-card" style="background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 30px;">
					<h3 style="margin-top: 0; margin-bottom: 15px; color: #2c3e50;">
						?? Тепловая карта результатов
					</h3>
					<div id="heatmapContainer"></div>
					<p style="margin-top: 10px; font-size: 12px; color: #666; text-align: center;">
						Визуализация выполнения заданий каждым учащимся
					</p>
				</div>
				
				<!-- Дополнительные графики -->
				<div id="additionalCharts"></div>
			`;
			
			console.log('Вкладка visualization настроена');
			
			// Обновляем графики
			setTimeout(() => {
				updateVisualization();
				console.log('Графики обновлены');
			}, 500);
		}

		// Функция для экспорта графиков
		// Основная функция экспорта всех графиков
		async function exportAllCharts() {
			try {
				console.log('=== ЭКСПОРТ ГРАФИКОВ ===');
				
				// Показываем меню выбора формата
				showExportMenu();
				
			} catch (error) {
				console.error('Ошибка экспорта графиков:', error);
				showNotification('Ошибка экспорта графиков', 'error');
			}
		}

		// Меню выбора формата экспорта
		function showExportMenu() {
			const menuHtml = `
				<div class="modal" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; display: flex; align-items: center; justify-content: center;">
					<div style="background: white; padding: 25px; border-radius: 10px; max-width: 500px; width: 90%; max-height: 90vh; overflow-y: auto;">
						<h3 style="margin-top: 0; color: #2c3e50;">?? Экспорт графиков</h3>
						
						<div style="margin-bottom: 20px;">
							<p style="color: #666; margin-bottom: 15px;">Выберите формат экспорта:</p>
							
							<div class="export-options" style="display: grid; grid-template-columns: 1fr; gap: 10px;">
								<button class="btn btn-primary" onclick="exportChartsAsPNG()" style="text-align: left; padding: 15px;">
									<div style="display: flex; align-items: center;">
										<span style="font-size: 24px; margin-right: 10px;">???</span>
										<div>
											<strong>PNG изображения</strong><br>
											<small>Отдельные файлы для каждого графика</small>
										</div>
									</div>
								</button>
								
								<button class="btn btn-primary" onclick="exportChartsAsHTML()" style="text-align: left; padding: 15px;">
									<div style="display: flex; align-items: center;">
										<span style="font-size: 24px; margin-right: 10px;">??</span>
										<div>
											<strong>HTML/PDF отчет</strong><br>
											<small>Все графики в одном PDF файле</small>
										</div>
									</div>
								</button>
								
								<button class="btn btn-primary" onclick="exportChartsAsSingleImage()" style="text-align: left; padding: 15px;">
									<div style="display: flex; align-items: center;">
										<span style="font-size: 24px; margin-right: 10px;">???</span>
										<div>
											<strong>Одно изображение</strong><br>
											<small>Все графики в одном PNG файле</small>
										</div>
									</div>
								</button>
								
								<button class="btn" onclick="copyChartsToClipboard()" style="text-align: left; padding: 15px;">
									<div style="display: flex; align-items: center;">
										<span style="font-size: 24px; margin-right: 10px;">??</span>
										<div>
											<strong>В буфер обмена</strong><br>
											<small>Копировать как изображение</small>
										</div>
									</div>
								</button>
							</div>
						</div>
						
						<div style="display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px;">
							<button class="btn" onclick="closeExportMenu()" style="padding: 8px 20px;">
								Отмена
							</button>
						</div>
					</div>
				</div>
			`;
			
			document.body.insertAdjacentHTML('beforeend', menuHtml);
		}

		function closeExportMenu() {
			const modal = document.querySelector('.modal');
			if (modal) modal.remove();
		}

		// Экспорт как отдельные PNG файлы
		async function exportChartsAsPNG() {
			closeExportMenu();
			
			const charts = [
				{ id: 'gradesChart', name: 'Распределение_оценок' },
				{ id: 'solvabilityChart', name: 'Решаемость_заданий' },
				{ id: 'complexityChart', name: 'Сложность_и_решаемость' }
			];
			
			// Добавляем дополнительные графики если есть
			const additionalCharts = ['literacyChart', 'psychologyProfileChart', 'normDistributionChart'];
			additionalCharts.forEach(id => {
				if (document.getElementById(id)) {
					charts.push({ id, name: id });
				}
			});
			
			const exportPromises = charts.map(chart => exportSingleChart(chart.id, chart.name));
			
			try {
				showNotification('Начинаем экспорт PNG...', 'info');
				
				// Если есть несколько файлов, предлагаем скачать архив
				if (exportPromises.length > 1) {
					const files = await Promise.all(exportPromises);
					await downloadAsZip(files, 'charts_export');
				} else if (exportPromises.length === 1) {
					await exportPromises[0];
				}
				
				showNotification('Экспорт PNG завершен', 'success');
				
			} catch (error) {
				console.error('Ошибка экспорта PNG:', error);
				showNotification('Ошибка экспорта PNG', 'error');
			}
		}

		// Экспорт одного графика
		async function exportSingleChart(canvasId, fileName) {
			const canvas = document.getElementById(canvasId);
			if (!canvas) {
				console.warn(`Canvas ${canvasId} не найден`);
				return null;
			}
			
			return new Promise((resolve, reject) => {
				try {
					// Создаем временный canvas с увеличенным разрешением
					const tempCanvas = document.createElement('canvas');
					const ctx = tempCanvas.getContext('2d');
					const scale = 2; // Увеличиваем разрешение в 2 раза
					
					tempCanvas.width = canvas.width * scale;
					tempCanvas.height = canvas.height * scale;
					
					// Настраиваем контекст для высокого качества
					ctx.scale(scale, scale);
					ctx.imageSmoothingEnabled = true;
					ctx.imageSmoothingQuality = 'high';
					
					// Копируем оригинальный canvas
					ctx.drawImage(canvas, 0, 0);
					
					// Конвертируем в blob
					tempCanvas.toBlob(blob => {
						if (!blob) {
							reject(new Error('Не удалось создать изображение'));
							return;
						}
						
						const url = URL.createObjectURL(blob);
						const link = document.createElement('a');
						link.download = `${fileName}_${getTimestamp()}.png`;
						link.href = url;
						link.style.display = 'none';
						
						document.body.appendChild(link);
						link.click();
						
						// Очистка
						setTimeout(() => {
							document.body.removeChild(link);
							URL.revokeObjectURL(url);
						}, 100);
						
						resolve({ name: link.download, blob });
						
					}, 'image/png', 1.0); // Максимальное качество
				} catch (error) {
					reject(error);
				}
			});
		}

		// Экспорт как PDF
		async function exportChartsAsPDF() {
			closeExportMenu();
			
			try {
				showNotification('Создаем PDF отчет...', 'info');
				
				// Динамически загружаем jsPDF если нет
				if (typeof window.jspdf === 'undefined') {
					await loadScript('https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js');
					await loadScript('https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js');
				}
				
				const { jsPDF } = window.jspdf;
				const pdf = new jsPDF('p', 'mm', 'a4');
				let yOffset = 20;
				
				// Заголовок
				pdf.setFontSize(20);
				pdf.setTextColor(40, 40, 40);
				pdf.text('Аналитический отчет', 105, yOffset, { align: 'center' });
				
				yOffset += 10;
				
				// Информация о тесте
				pdf.setFontSize(12);
				pdf.setTextColor(100, 100, 100);
				const testInfo = [
					`Предмет: ${appData.test.subject || 'Не указан'}`,
					`Класс: ${appData.test.class || 'Не указан'}`,
					`Тема: ${appData.test.theme || 'Не указана'}`,
					`Дата: ${appData.test.testDate || 'Не указана'}`,
					`Учащихся: ${appData.students.length}`
				];
				
				testInfo.forEach((line, i) => {
					pdf.text(line, 20, yOffset + (i * 7));
				});
				
				yOffset += testInfo.length * 7 + 10;
				
				// Экспорт каждого графика
				const charts = [
					{ id: 'gradesChart', title: 'Распределение оценок' },
					{ id: 'solvabilityChart', title: 'Решаемость заданий' },
					{ id: 'complexityChart', title: 'Связь сложности и решаемости' }
				];
				
				for (const chart of charts) {
					const canvas = document.getElementById(chart.id);
					if (!canvas) continue;
					
					// Добавляем новый лист если нужно
					if (yOffset > 250) {
						pdf.addPage();
						yOffset = 20;
					}
					
					// Заголовок графика
					pdf.setFontSize(16);
					pdf.setTextColor(40, 40, 40);
					pdf.text(chart.title, 20, yOffset);
					yOffset += 10;
					
					try {
						// Конвертируем canvas в изображение
						const imageData = canvas.toDataURL('image/png', 1.0);
						
						// Рассчитываем размеры для вставки
						const pageWidth = pdf.internal.pageSize.getWidth();
						const maxWidth = pageWidth - 40; // Отступы по 20мм с каждой стороны
						const canvasRatio = canvas.width / canvas.height;
						const imgWidth = Math.min(maxWidth, 150);
						const imgHeight = imgWidth / canvasRatio;
						
						// Вставляем изображение
						pdf.addImage(imageData, 'PNG', 20, yOffset, imgWidth, imgHeight);
						yOffset += imgHeight + 15;
						
					} catch (error) {
						console.error(`Ошибка добавления графика ${chart.id}:`, error);
						pdf.setFontSize(10);
						pdf.setTextColor(200, 0, 0);
						pdf.text(`Ошибка загрузки графика: ${chart.title}`, 20, yOffset);
						yOffset += 10;
					}
				}
				
				// Добавляем статистику
				if (yOffset > 200) {
					pdf.addPage();
					yOffset = 20;
				}
				
				pdf.setFontSize(16);
				pdf.setTextColor(40, 40, 40);
				pdf.text('Статистика', 20, yOffset);
				yOffset += 10;
				
				pdf.setFontSize(11);
				pdf.setTextColor(80, 80, 80);
				
				const stats = generateStatsSummary();
				stats.forEach((stat, i) => {
					if (yOffset > 270) {
						pdf.addPage();
						yOffset = 20;
					}
					pdf.text(stat, 20, yOffset + (i * 6));
				});
				
				// Сохраняем PDF
				pdf.save(`Аналитический_отчет_${getTimestamp()}.pdf`);
				
				showNotification('PDF отчет создан успешно', 'success');
				
			} catch (error) {
				console.error('Ошибка экспорта PDF:', error);
				showNotification('Ошибка создания PDF', 'error');
			}
		}

		// Экспорт всех графиков как одно изображение
		async function exportChartsAsSingleImage() {
			closeExportMenu();
			
			try {
				showNotification('Создаем общее изображение...', 'info');
				
				// Загружаем html2canvas если нужно
				if (typeof html2canvas === 'undefined') {
					await loadScript('https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js');
				}
				
				// Находим контейнер с графиками
				const container = document.getElementById('chartsGrid') || 
								 document.querySelector('.charts-grid') ||
								 document.getElementById('visualization');
				
				if (!container) {
					throw new Error('Контейнер графиков не найден');
				}
				
				// Создаем копию контейнера для рендеринга
				const clone = container.cloneNode(true);
				clone.style.width = container.offsetWidth + 'px';
				clone.style.background = 'white';
				clone.style.padding = '20px';
				clone.style.borderRadius = '10px';
				clone.style.boxShadow = '0 2px 10px rgba(0,0,0,0.1)';
				
				// Добавляем заголовок
				const title = document.createElement('h2');
				title.textContent = 'Аналитические графики';
				title.style.marginTop = '0';
				title.style.marginBottom = '20px';
				title.style.color = '#2c3e50';
				clone.insertBefore(title, clone.firstChild);
				
				// Добавляем информацию
				const info = document.createElement('div');
				info.style.marginBottom = '20px';
				info.style.padding = '10px';
				info.style.background = '#f8f9fa';
				info.style.borderRadius = '5px';
				info.style.fontSize = '12px';
				info.innerHTML = `
					<strong>Предмет:</strong> ${appData.test.subject || 'Не указан'} | 
					<strong>Класс:</strong> ${appData.test.class || 'Не указан'} | 
					<strong>Дата:</strong> ${appData.test.testDate || 'Не указана'} |
					<strong>Учащихся:</strong> ${appData.students.length}
				`;
				clone.insertBefore(info, clone.children[1]);
				
				// Скрываем оригинальный элемент
				clone.style.position = 'fixed';
				clone.style.top = '-9999px';
				clone.style.left = '-9999px';
				clone.style.zIndex = '-1000';
				document.body.appendChild(clone);
				
				// Конвертируем в изображение
				const canvas = await html2canvas(clone, {
					scale: 2,
					useCORS: true,
					backgroundColor: '#ffffff',
					logging: false
				});
				
				// Удаляем клон
				document.body.removeChild(clone);
				
				// Создаем ссылку для скачивания
				const link = document.createElement('a');
				link.download = `Все_графики_${getTimestamp()}.png`;
				link.href = canvas.toDataURL('image/png', 1.0);
				link.style.display = 'none';
				
				document.body.appendChild(link);
				link.click();
				
				// Очистка
				setTimeout(() => {
					document.body.removeChild(link);
				}, 100);
				
				showNotification('Общее изображение создано', 'success');
				
			} catch (error) {
				console.error('Ошибка создания общего изображения:', error);
				showNotification('Ошибка создания изображения', 'error');
			}
		}

		// Копирование графика в буфер обмена
		async function copyChartsToClipboard() {
			closeExportMenu();
			
			try {
				// Берем первый график или complexityChart как наиболее информативный
				const canvas = document.getElementById('complexityChart') || 
							  document.getElementById('gradesChart') || 
							  document.getElementById('solvabilityChart');
				
				if (!canvas) {
					showNotification('Нет графиков для копирования', 'warning');
					return;
				}
				
				// Создаем blob из canvas
				const blob = await new Promise(resolve => {
					canvas.toBlob(resolve, 'image/png', 1.0);
				});
				
				// Копируем в буфер обмена
				await navigator.clipboard.write([
					new ClipboardItem({
						[blob.type]: blob
					})
				]);
				
				showNotification('График скопирован в буфер обмена', 'success');
				
			} catch (error) {
				console.error('Ошибка копирования в буфер обмена:', error);
				
				// Fallback для браузеров без поддержки Clipboard API
				const canvas = document.getElementById('complexityChart');
				if (canvas) {
					canvas.toBlob(blob => {
						const item = new ClipboardItem({ [blob.type]: blob });
						navigator.clipboard.write([item])
							.then(() => showNotification('График скопирован', 'success'))
							.catch(() => showNotification('Используйте Ctrl+C или экспорт', 'warning'));
					});
				} else {
					showNotification('Не удалось скопировать график', 'error');
				}
			}
		}

		// Вспомогательные функции

		function loadScript(src) {
			return new Promise((resolve, reject) => {
				const script = document.createElement('script');
				script.src = src;
				script.onload = resolve;
				script.onerror = reject;
				document.head.appendChild(script);
			});
		}

		function getTimestamp() {
			const now = new Date();
			return `${now.getFullYear()}-${(now.getMonth()+1).toString().padStart(2,'0')}-${now.getDate().toString().padStart(2,'0')}_${now.getHours().toString().padStart(2,'0')}-${now.getMinutes().toString().padStart(2,'0')}`;
		}

		function generateStatsSummary() {
			const totalScores = appData.results.map(scores => 
				scores.reduce((sum, score) => sum + (parseInt(score) || 0), 0)
			);
			const averageScore = totalScores.reduce((a, b) => a + b, 0) / totalScores.length;
			const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0);
			const averagePercentage = (averageScore / maxPossible) * 100;
			
			return [
				`Всего учащихся: ${appData.students.length}`,
				`Средний балл: ${averageScore.toFixed(1)} из ${maxPossible}`,
				`Средний процент: ${averagePercentage.toFixed(1)}%`,
				`Заданий: ${appData.tasks.length}`,
				`Уровни сложности: ${[...new Set(appData.tasks.map(t => t.level))].join(', ')}`
			];
		}

		// Функция для скачивания архива (использует JSZip)
		async function downloadAsZip(files, zipName) {
			try {
				// Динамически загружаем JSZip
				if (typeof JSZip === 'undefined') {
					await loadScript('https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js');
				}
				
				const zip = new JSZip();
				
				// Добавляем файлы в архив
				files.filter(f => f && f.blob).forEach(file => {
					zip.file(file.name, file.blob);
				});
				
				// Добавляем README файл
				const readmeText = `
Аналитические графики
Дата экспорта: ${new Date().toLocaleString()}
Предмет: ${appData.test.subject || 'Не указан'}
Класс: ${appData.test.class || 'Не указан'}
Тема: ${appData.test.theme || 'Не указана'}
Всего учащихся: ${appData.students.length}
Всего заданий: ${appData.tasks.length}

Содержимое архива:
${files.map(f => f ? `- ${f.name}` : '').join('\n')}
				`.trim();
				
				zip.file('README.txt', readmeText);
				
				// Генерируем архив
				const content = await zip.generateAsync({ type: 'blob' });
				
				// Скачиваем архив
				const link = document.createElement('a');
				link.href = URL.createObjectURL(content);
				link.download = `${zipName}_${getTimestamp()}.zip`;
				link.style.display = 'none';
				
				document.body.appendChild(link);
				link.click();
				
				// Очистка
				setTimeout(() => {
					document.body.removeChild(link);
					URL.revokeObjectURL(link.href);
				}, 100);
				
			} catch (error) {
				console.error('Ошибка создания архива:', error);
				showNotification('Ошибка создания архива', 'error');
				throw error;
			}
		}

		// Функция для переключения темы
		function toggleDarkMode() {
			document.body.classList.toggle('dark-mode');
			updateVisualization();
			showNotification('Тема переключена', 'info');
		}
		function updateComplexityChart() {
			const canvas = document.getElementById('complexityChart');
			if (!canvas) {
				console.error('Canvas complexityChart не найден!');
				return;
			}
			
			// Проверяем данные
			if (!appData.results || appData.results.length === 0 || !appData.tasks || appData.tasks.length === 0) {
				console.warn('Нет данных для complexity chart');
				return;
			}
			
			console.log('Создание графика сложности...');
			
			// Подготавливаем данные с отладкой
			const taskStats = [];
			
			for (let i = 0; i < appData.tasks.length; i++) {
				const task = appData.tasks[i];
				const maxScore = parseInt(task.maxScore) || 1;
				const level = parseInt(task.level) || 1;
				
				console.log(`Задание ${i+1}: уровень=${level}, maxScore=${maxScore}`);
				
				// Собираем оценки за это задание
				const scores = [];
				for (let j = 0; j < appData.results.length; j++) {
					const studentScore = appData.results[j][i];
					const normalizedScore = Math.min(parseInt(studentScore) || 0, maxScore);
					scores.push(normalizedScore);
				}
				
				// Рассчитываем процент выполнения
				const totalPossible = maxScore * scores.length;
				const actualTotal = scores.reduce((sum, score) => sum + score, 0);
				const completion = totalPossible > 0 ? (actualTotal / totalPossible) * 100 : 0;
				
				console.log(`  Оценки: ${scores.slice(0, 5).join(', ')}...`);
				console.log(`  Выполнение: ${completion.toFixed(1)}% (${actualTotal}/${totalPossible})`);
				
				taskStats.push({
					taskNumber: i + 1,
					completion: completion,
					level: level,
					type: task.type || `Задание ${i+1}`,
					actualTotal: actualTotal,
					totalPossible: totalPossible
				});
			}
			
			// Сортируем по уровню сложности для лучшего отображения
			taskStats.sort((a, b) => a.level - b.level);
			
			console.log('Итоговая статистика:', taskStats);
			
			// Создаем график
			const ctx = canvas.getContext('2d');
			
			// Уничтожаем старый график если есть
			if (window.complexityChartInstance) {
				window.complexityChartInstance.destroy();
			}
			
			window.complexityChartInstance = new Chart(ctx, {
				type: 'scatter',
				data: {
					datasets: [{
						label: 'Задания',
						data: taskStats.map(t => ({
							x: t.level,
							y: t.completion,
							taskNumber: t.taskNumber,
							type: t.type,
							details: `${t.actualTotal}/${t.totalPossible}`
						})),
						backgroundColor: taskStats.map(t => 
							complexityLevels[t.level]?.color || '#3498db'
						),
						pointRadius: 10,
						pointHoverRadius: 12,
						pointBorderWidth: 2,
						pointBorderColor: '#ffffff'
					}]
				},
				options: {
					responsive: true,
					maintainAspectRatio: false,
					scales: {
						x: {
							type: 'linear',
							title: { 
								display: true, 
								text: 'Уровень сложности',
								font: { size: 14, weight: 'bold' },
								color: '#2c3e50'
							},
							min: 0.5,
							max: 4.5,
							ticks: {
								stepSize: 1,
								callback: function(value) {
									if (Number.isInteger(value)) {
										const level = complexityLevels[value];
										return level ? `${value}. ${level.name}` : value;
									}
									return value;
								},
								font: { size: 12 }
							},
							grid: {
								color: 'rgba(0,0,0,0.05)'
							}
						},
						y: {
							title: { 
								display: true, 
								text: 'Процент выполнения (%)',
								font: { size: 14, weight: 'bold' },
								color: '#2c3e50'
							},
							min: 0,
							max: 100,
							ticks: {
								callback: function(value) {
									return value + '%';
								},
								font: { size: 12 }
							},
							grid: {
								color: 'rgba(0,0,0,0.05)'
							}
						}
					},
					plugins: {
						tooltip: {
							backgroundColor: 'rgba(0, 0, 0, 0.8)',
							titleColor: '#fff',
							bodyColor: '#fff',
							borderColor: '#3498db',
							borderWidth: 1,
							callbacks: {
								title: function(context) {
									const point = context[0].raw;
									return `Задание ${point.taskNumber}: ${point.type}`;
								},
								label: function(context) {
									const point = context.raw;
									return [
										`Уровень сложности: ${complexityLevels[point.x]?.name || point.x}`,
										`Выполнение: ${point.y.toFixed(1)}%`,
										`Баллы: ${point.details}`
									];
								}
							}
						},
						legend: { 
							display: false 
						},
						title: {
							display: true,
							text: 'Связь уровня сложности и решаемости заданий',
							font: { size: 16, weight: 'bold' },
							color: '#2c3e50',
							padding: { top: 10, bottom: 30 }
						}
					}
				}
			});
			
			console.log('График сложности создан успешно');
		}

		// Вспомогательные функции
		function getGradeColor(grade) {
			const colorMap = {
				'1': '#c0392b', '2': '#e74c3c', '3': '#f39c12',
				'4': '#3498db', '5': '#27ae60',
				'?': '#95a5a6'
			};
			return colorMap[grade] || '#3498db';
		}

		function safeResizeCharts() {
			const charts = [
				window.gradesChartInstance,
				window.complexityChartInstance,
				window.solvabilityChartInstance
			];
			
			charts.forEach(chart => {
				if (chart) {
					try {
						chart.resize();
					} catch (error) {
						console.warn('Ошибка ресайза графика:', error);
					}
				}
			});
		}

		function showNoDataMessage() {
			const containers = [
				document.getElementById('gradesChart')?.parentElement,
				document.getElementById('solvabilityChart')?.parentElement,
				document.getElementById('complexityChart')?.parentElement
			];
			
			containers.forEach(container => {
				if (container) {
					container.innerHTML = `
						<div style="text-align: center; padding: 40px 20px; color: #666;">
							<div style="font-size: 48px; margin-bottom: 10px;">??</div>
							<h4 style="margin-bottom: 10px;">Нет данных для отображения</h4>
							<p style="font-size: 14px;">Введите результаты тестирования в таблице</p>
						</div>
					`;
				}
			});
		}

		function showChartError() {
			const containers = [
				document.getElementById('gradesChart')?.parentElement,
				document.getElementById('solvabilityChart')?.parentElement,
				document.getElementById('complexityChart')?.parentElement
			];
			
			containers.forEach(container => {
				if (container) {
					container.innerHTML = `
						<div style="text-align: center; padding: 40px 20px; color: #e74c3c;">
							<div style="font-size: 48px; margin-bottom: 10px;">?</div>
							<h4 style="margin-bottom: 10px;">Ошибка построения графика</h4>
							<p style="font-size: 14px;">Попробуйте обновить страницу</p>
						</div>
					`;
				}
			});
		}

		function destroyAllCharts() {
			console.log('=== УНИЧТОЖЕНИЕ ВСЕХ ГРАФИКОВ ===');
			
			// Список всех возможных экземпляров графиков
			const chartInstances = [
				'gradesChartInstance',
				'complexityChartInstance',
				'solvabilityChartInstance',
				'literacyChartInstance',
				'literacyRadarChartInstance',
				'trendChartInstance',
				'psychologyProfileChartInstance',
				'normDistributionChartInstance',
				'radarChartInstance'
			];
			
			// Также получаем все зарегистрированные в Chart.js графики
			const chartRegistry = Chart.registry || {};
			
			// Уничтожаем экземпляры в window
			chartInstances.forEach(chartName => {
				if (window[chartName] && typeof window[chartName].destroy === 'function') {
					try {
						console.log(`Уничтожаем график: ${chartName}`);
						window[chartName].destroy();
						window[chartName] = null;
					} catch (error) {
						console.warn(`Не удалось удалить график ${chartName}:`, error);
					}
				}
			});
			
			// Уничтожаем все графики зарегистрированные в Chart.js
			try {
				const charts = Chart.instances || [];
				console.log(`Всего графиков в Chart.registry: ${Object.keys(chartRegistry).length}`);
				
				// Альтернативный способ: перебираем все canvas и смотрим есть ли у них графики
				document.querySelectorAll('canvas').forEach(canvas => {
					const chartId = canvas.id;
					if (chartId) {
						const chartInstance = Chart.getChart(canvas);
						if (chartInstance) {
							console.log(`Уничтожаем график на canvas: ${chartId}`);
							chartInstance.destroy();
						}
					}
				});
			} catch (error) {
				console.warn('Ошибка при очистке реестра Chart.js:', error);
			}
			
			// Очищаем все canvas
			document.querySelectorAll('canvas').forEach(canvas => {
				const ctx = canvas.getContext('2d');
				if (ctx) {
					ctx.clearRect(0, 0, canvas.width, canvas.height);
				}
			});
			
			console.log('Все графики уничтожены');
		}
		function destroyAllCharts() {
			console.log('=== УНИЧТОЖЕНИЕ ВСЕХ ГРАФИКОВ ===');
			
			// Список всех возможных экземпляров графиков
			const chartInstances = [
				'gradesChartInstance',
				'complexityChartInstance',
				'solvabilityChartInstance',
				'literacyChartInstance',
				'literacyRadarChartInstance',
				'trendChartInstance',
				'psychologyProfileChartInstance',
				'normDistributionChartInstance',
				'radarChartInstance'
			];
			
			// Также получаем все зарегистрированные в Chart.js графики
			const chartRegistry = Chart.registry || {};
			
			// Уничтожаем экземпляры в window
			chartInstances.forEach(chartName => {
				if (window[chartName] && typeof window[chartName].destroy === 'function') {
					try {
						console.log(`Уничтожаем график: ${chartName}`);
						window[chartName].destroy();
						window[chartName] = null;
					} catch (error) {
						console.warn(`Не удалось удалить график ${chartName}:`, error);
					}
				}
			});
			
			// Уничтожаем все графики зарегистрированные в Chart.js
			try {
				const charts = Chart.instances || [];
				console.log(`Всего графиков в Chart.registry: ${Object.keys(chartRegistry).length}`);
				
				// Альтернативный способ: перебираем все canvas и смотрим есть ли у них графики
				document.querySelectorAll('canvas').forEach(canvas => {
					const chartId = canvas.id;
					if (chartId) {
						const chartInstance = Chart.getChart(canvas);
						if (chartInstance) {
							console.log(`Уничтожаем график на canvas: ${chartId}`);
							chartInstance.destroy();
						}
					}
				});
			} catch (error) {
				console.warn('Ошибка при очистке реестра Chart.js:', error);
			}
			
			// Очищаем все canvas
			document.querySelectorAll('canvas').forEach(canvas => {
				const ctx = canvas.getContext('2d');
				if (ctx) {
					ctx.clearRect(0, 0, canvas.width, canvas.height);
				}
			});
			
			console.log('Все графики уничтожены');
		}

		// Добавить обработчик resize
		window.addEventListener('resize', debounce(safeResizeCharts, 250));

		function debounce(func, wait) {
			let timeout;
			return function executedFunction(...args) {
				const later = () => {
					clearTimeout(timeout);
					func(...args);
				};
				clearTimeout(timeout);
				timeout = setTimeout(later, wait);
			};
		}

		// ==================== СБРОС ДАННЫХ ====================
		function resetAppData() {
			if (confirm('Вы уверены, что хотите сбросить все данные?\nЭто действие невозможно отменить.')) {
				try {
					// Создаем резервную копию перед сбросом
					const backupKey = `backup_pre_reset_${new Date().toISOString().replace(/[:.]/g, '-')}`;
					localStorage.setItem(backupKey, JSON.stringify({
						data: JSON.parse(JSON.stringify(appData)),
						timestamp: new Date().toLocaleString(),
						reason: 'pre-reset'
					}));
					
					// Полностью очищаем данные
					localStorage.removeItem('testAnalyticsData');
					
					// Удаляем все резервные копии, кроме последней
					const backups = Object.keys(localStorage)
						.filter(key => key.startsWith('backup_'))
						.sort()
						.reverse()
						.slice(1);
					
					backups.forEach(key => localStorage.removeItem(key));
					
					// Перезагружаем страницу
					location.reload();
					
				} catch (error) {
					console.error('Ошибка при сбросе данных:', error);
					showNotification('Ошибка при сбросе данных', 'error');
				}
			}
		}

		function showResetDialog() {
			const html = `
				<h3>?? Сброс данных системы</h3>
				
				<div style="background: #fff3cd; padding: 15px; border-radius: 8px; margin: 15px 0;">
					<h4 style="color: #856404;">Внимание!</h4>
					<p>Это действие удалит:</p>
					<ul style="margin: 10px 0; padding-left: 20px;">
						<li>Все настройки тестов</li>
						<li>Списки учащихся</li>
						<li>Результаты и оценки</li>
						<li>Аналитику и отчеты</li>
					</ul>
					<p><strong>Данное действие необратимо!</strong></p>
				</div>
				
				<div style="background: #d1ecf1; padding: 15px; border-radius: 8px; margin: 15px 0;">
					<h4>?? Рекомендуемые действия перед сбросом:</h4>
					<ol style="margin: 10px 0; padding-left: 20px;">
						<li>Экспортируйте важные данные</li>
						<li>Сохраните нужные отчеты</li>
						<li>Убедитесь, что у вас есть резервные копии</li>
					</ol>
				</div>
				
				<div style="margin-top: 20px;">
					<button class="btn" onclick="exportAppData('json')" style="margin-right: 10px;">
						?? Сначала экспортировать данные
					</button>
					<button class="btn btn-danger" onclick="resetAppData()">
						?? Сбросить все данные
					</button>
				</div>
			`;
			
			showModal('Сброс данных системы', html);
		}

		
		function safeResizeCharts() {
			// Ждем следующего кадра анимации
			requestAnimationFrame(() => {
				const chartInstances = [
					window.gradesChartInstance,
					window.complexityChartInstance,
					window.solvabilityChartInstance,
					window.trendChartInstance,
					window.psychologyProfileChartInstance,
					window.normDistributionChartInstance,
					window.radarChartInstance
				];
				
				chartInstances.forEach(chart => {
					if (chart) {
						try {
							chart.resize();
						} catch (error) {
							console.warn('Ошибка при изменении размера графика:', error);
						}
					}
				});
			});
		}
        // Улучшенный график коридора решаемости
        function updateSolvabilityChart() {
            const taskStats = [];
            for (let i = 0; i < appData.tasks.length; i++) {
                const task = appData.tasks[i];
                const maxScore = task.maxScore;
                const actualScores = appData.results.map(student => student[i] || 0);
                const actualTotal = actualScores.reduce((sum, score) => sum + score, 0);
                const completion = (actualTotal / (maxScore * appData.results.length)) * 100;
                
                taskStats.push({
                    task: i + 1,
                    completion: completion,
                    level: task.level,
                    type: task.type
                });
            }
            
            const ctx = document.getElementById('solvabilityChart').getContext('2d');
            
            if (window.solvabilityChartInstance) {
                window.solvabilityChartInstance.destroy();
            }
            
            window.solvabilityChartInstance = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: taskStats.map(t => `Зад. ${t.task}`),
                    datasets: [{
                        label: '% выполнения',
                        data: taskStats.map(t => t.completion),
                        backgroundColor: taskStats.map(t => {
                            if (t.completion >= 90) return '#27ae60';
                            if (t.completion >= 60) return '#2ecc71';
                            if (t.completion >= 30) return '#f39c12';
                            return '#e74c3c';
                        }),
                        borderColor: taskStats.map(t => {
                            if (t.completion >= 90) return '#219a52';
                            if (t.completion >= 60) return '#27ae60';
                            if (t.completion >= 30) return '#e67e22';
                            return '#c0392b';
                        }),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            title: { 
                                display: true, 
                                text: '% выполнения',
                                font: { size: 14, weight: 'bold' }
                            },
                            ticks: {
                                callback: function(value) {
                                    return value + '%';
                                },
                                font: { size: 12 }
                            },
                            grid: {
                                color: function(context) {
                                    const value = context.tick.value;
                                    if (value === 30 || value === 60 || value === 90) {
                                        return 'rgba(0,0,0,0.3)';
                                    }
                                    return 'rgba(0,0,0,0.1)';
                                },
                                lineWidth: function(context) {
                                    const value = context.tick.value;
                                    if (value === 30 || value === 60 || value === 90) {
                                        return 2;
                                    }
                                    return 1;
                                }
                            }
                        },
                        x: {
                            title: { 
                                display: true, 
                                text: 'Номера заданий',
                                font: { size: 14, weight: 'bold' }
                            },
                            ticks: {
                                font: { size: 12 }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const task = taskStats[context.dataIndex];
                                    return [
                                        `Задание ${task.task}: ${task.completion.toFixed(1)}%`,
                                        `Тип: ${task.type}`,
                                        `Уровень: ${complexityLevels[task.level].name}`
                                    ];
                                }
                            }
                        }
                    }
                }
            });
        }

        // Тепловая карта
        function updateHeatmap() {
            let html = '<div class="table-container"><table>';
            
            html += '<thead><tr><th>Учащийся</th>';
            for (let i = 0; i < appData.tasks.length; i++) {
                html += `<th>${i+1}</th>`;
            }
            html += '<th>?</th><th>Оценка</th></tr></thead><tbody>';
            
            appData.students.forEach((student, studentIndex) => {
                const scores = appData.results[studentIndex] || [];
                const totalScore = scores.reduce((sum, score) => sum + score, 0);
                const grade = calculateGrade(totalScore);
                
                html += `<tr>
                    <td><strong>${student}</strong></td>`;
                
                for (let taskIndex = 0; taskIndex < appData.tasks.length; taskIndex++) {
                    const maxScore = appData.tasks[taskIndex].maxScore;
                    const score = scores[taskIndex] || 0;
                    const percentage = maxScore > 0 ? (score / maxScore) * 100 : 0;
                    const heatmapClass = `heatmap-${Math.floor(percentage / 20) * 20}`;
                    
                    html += `<td class="heatmap-cell ${heatmapClass}" title="Задание ${taskIndex+1}: ${score}/${maxScore} (${percentage.toFixed(0)}%)">
                        ${score}
                    </td>`;
                }
                
                html += `<td><strong>${totalScore}</strong></td>
                    <td class="grade-${grade}"><strong>${grade}</strong></td>
                </tr>`;
            });
            
            html += '</tbody></table></div>';
            document.getElementById('heatmapContainer').innerHTML = html;
        }

        // Визуализация для функциональной грамотности
        function updateLiteracyVisualization() {
            let html = '<div class="chart-container">';
            html += `
<div class="chart-container" style="
    height: 450px; 
    min-height: 450px; 
    position: relative; 
    margin: 25px 0; 
    border: 1px solid #e0e0e0; 
    border-radius: 10px; 
    padding: 20px; 
    background: white;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
">
    <h4 style="margin: 0 0 20px 0; padding: 0; color: #2c3e50;">?? Визуальный профиль грамотности</h4>
    <div style="height: 380px; position: relative; background: #f8f9fa; border-radius: 6px; padding: 10px;">
        <canvas id="literacyRadarChart" 
                style="display: block; width: 100%; height: 100%; background: white; border-radius: 4px;"></canvas>
    </div>
</div>
			`;
            
            document.getElementById('specializedCharts').innerHTML = html;
            
            setTimeout(() => {
                initLiteracyRadarChart();
            }, 100);
        }

		// Функция анализа для рубежной контрольной
		function updateMilestoneAnalysis() {
			let html = '<h3 class="section-title">?? Анализ рубежной контрольной работы</h3>';
			
			const totalScores = appData.results.map(scores => scores.reduce((sum, score) => sum + score, 0));
			const grades = totalScores.map(score => calculateGrade(score));
			const avgScore = totalScores.reduce((sum, score) => sum + score, 0) / totalScores.length;
			
			// Анализ динамики с начала учебного периода
			const history = JSON.parse(localStorage.getItem('workHistory') || '[]')
				.filter(item => item.data.test.subject === appData.test.subject && 
							   item.data.test.class === appData.test.class &&
							   item.data.test.workType === 'current') // Только текущие работы
				.sort((a, b) => new Date(a.data.test.testDate) - new Date(b.data.test.testDate));
			
			html += `
				<div class="stats-grid">
					<div class="stat-card">
						<div class="stat-value">${avgScore.toFixed(1)}</div>
						<div class="stat-label">Средний балл</div>
					</div>
					<div class="stat-card">
						<div class="stat-value">${calculateSuccessRate().toFixed(1)}%</div>
						<div class="stat-label">Успеваемость</div>
					</div>
					<div class="stat-card">
						<div class="stat-value">${calculateQualityRate().toFixed(1)}%</div>
						<div class="stat-label">Качество</div>
					</div>
					<div class="stat-card">
						<div class="stat-value">${history.length + 1}</div>
						<div class="stat-label">Работа №</div>
					</div>
				</div>
			`;
			
			// Анализ динамики, если есть предыдущие работы
			if (history.length > 0) {
				const currentSummary = generateWorkSummary();
				const previousSummary = history[history.length - 1].summary;
				
				html += `
					<h4>?? Динамика с предыдущей работы</h4>
					<div class="comparative-grid">
						<div class="comparative-card">
							<h5>Средний балл</h5>
							<div class="comparative-value ${currentSummary.avgScore > previousSummary.avgScore ? 'positive' : 'negative'}">
								${currentSummary.avgScore.toFixed(1)} 
								<span class="trend">${currentSummary.avgScore > previousSummary.avgScore ? '?' : '?'}</span>
							</div>
							<div class="comparative-previous">Предыдущий: ${previousSummary.avgScore.toFixed(1)}</div>
						</div>
						<div class="comparative-card">
							<h5>Успеваемость</h5>
							<div class="comparative-value ${currentSummary.successRate > previousSummary.successRate ? 'positive' : 'negative'}">
								${currentSummary.successRate.toFixed(1)}%
								<span class="trend">${currentSummary.successRate > previousSummary.successRate ? '?' : '?'}</span>
							</div>
							<div class="comparative-previous">Предыдущий: ${previousSummary.successRate.toFixed(1)}%</div>
						</div>
						<div class="comparative-card">
							<h5>Качество</h5>
							<div class="comparative-value ${currentSummary.qualityRate > previousSummary.qualityRate ? 'positive' : 'negative'}">
								${currentSummary.qualityRate.toFixed(1)}%
								<span class="trend">${currentSummary.qualityRate > previousSummary.qualityRate ? '?' : '?'}</span>
							</div>
							<div class="comparative-previous">Предыдущий: ${previousSummary.qualityRate.toFixed(1)}%</div>
						</div>
					</div>
				`;
			}
			
			// Анализ освоения учебных элементов
			html += generateLearningElementsAnalysis();
			
			// Прогноз итоговой успеваемости
			html += generateProgressForecast();
			
			// Рекомендации для следующего этапа
			html += generateMilestoneRecommendations();
			
			document.getElementById('specializedAnalysis').innerHTML = html;
		}

		// Функция анализа для текущей контрольной
		function updateCurrentAnalysis() {
			let html = '<h3 class="section-title">?? Анализ текущей контрольной работы</h3>';
			
			const totalScores = appData.results.map(scores => scores.reduce((sum, score) => sum + score, 0));
			const avgScore = totalScores.reduce((sum, score) => sum + score, 0) / totalScores.length;
			
			html += `
				<div class="stats-grid">
					<div class="stat-card">
						<div class="stat-value">${avgScore.toFixed(1)}</div>
						<div class="stat-label">Средний балл</div>
					</div>
					<div class="stat-card">
						<div class="stat-value">${calculateSuccessRate().toFixed(1)}%</div>
						<div class="stat-label">Успеваемость</div>
					</div>
					<div class="stat-card">
						<div class="stat-value">${countStudentsByPerformanceLevel('mastered')}</div>
						<div class="stat-label">Освоили тему</div>
					</div>
					<div class="stat-card">
						<div class="stat-value">${countStudentsByPerformanceLevel('need_help')}</div>
						<div class="stat-label">Нужна помощь</div>
					</div>
				</div>
			`;
			
			// Оперативный анализ освоения темы
			html += generateTopicMasteryAnalysis();
			
			// Анализ типичных ошибок
			html += generateCurrentErrorsAnalysis();
			
			// Рекомендации для урока
			html += generateLessonRecommendations();
			
			document.getElementById('specializedAnalysis').innerHTML = html;
		}

		// Функция анализа для диагностической работы
		function updateDiagnosticAnalysis() {
			let html = '<h3 class="section-title">?? Диагностический анализ</h3>';
			
			const totalScores = appData.results.map(scores => scores.reduce((sum, score) => sum + score, 0));
			const avgScore = totalScores.reduce((sum, score) => sum + score, 0) / totalScores.length;
			
			html += `
				<div class="stats-grid">
					<div class="stat-card">
						<div class="stat-value">${avgScore.toFixed(1)}</div>
						<div class="stat-label">Средний балл</div>
					</div>
					<div class="stat-card">
						<div class="stat-value">${calculateBaselineLevel()}</div>
						<div class="stat-label">Базовый уровень</div>
					</div>
					<div class="stat-card">
						<div class="stat-value">${identifyGaps().length}</div>
						<div class="stat-label">Выявлено пробелов</div>
					</div>
					<div class="stat-card">
						<div class="stat-value">${calculateReadinessLevel()}</div>
						<div class="stat-label">Готовность к обучению</div>
					</div>
				</div>
			`;
			
			// Диагностика пробелов
			html += generateGapsAnalysis();
			
			// Группировка учащихся по уровням
			html += generateDiagnosticGroups();
			
			// Индивидуальные рекомендации
			html += generateDiagnosticRecommendations();
			
			document.getElementById('specializedAnalysis').innerHTML = html;
		}

		// Вспомогательные функции для анализа

		// Анализ учебных элементов для рубежной работы
		function generateLearningElementsAnalysis() {
			let html = '<h4>?? Анализ освоения учебных элементов</h4>';
			
			const elementStats = {};
			
			appData.tasks.forEach((task, taskIndex) => {
				const element = task.knowledge || 'Учебный элемент';
				if (!elementStats[element]) {
					elementStats[element] = {
						completion: 0,
						count: 0,
						importance: task.level // Уровень сложности как показатель важности
					};
				}
				
				const completion = calculateTaskCompletion(taskIndex);
				elementStats[element].completion += completion;
				elementStats[element].count++;
			});
			
			// Вычисляем среднее выполнение
			Object.keys(elementStats).forEach(element => {
				elementStats[element].completion = elementStats[element].completion / elementStats[element].count;
			});
			
			html += '<div class="table-container"><table>';
			html += '<thead><tr><th>Учебный элемент</th><th>Важность</th><th>% освоения</th><th>Статус</th></tr></thead><tbody>';
			
			Object.entries(elementStats).forEach(([element, stats]) => {
				let status = '';
				let statusIcon = '';
				
				if (stats.completion >= 80) {
					status = 'Освоен';
					statusIcon = '??';
				} else if (stats.completion >= 60) {
					status = 'Частично освоен';
					statusIcon = '??';
				} else {
					status = 'Не освоен';
					statusIcon = '??';
				}
				
				// Определяем важность
				const importance = stats.importance <= 2 ? 'Базовая' : 'Ключевая';
				
				html += `
					<tr>
						<td>${element}</td>
						<td>${importance}</td>
						<td>${stats.completion.toFixed(1)}%</td>
						<td>${statusIcon} ${status}</td>
					</tr>
				`;
			});
			
			html += '</tbody></table></div>';
			
			return html;
		}

		// Прогноз успеваемости для рубежной работы
		function generateProgressForecast() {
			const totalScores = appData.results.map(scores => scores.reduce((sum, score) => sum + score, 0));
			const avgScore = totalScores.reduce((sum, score) => sum + score, 0) / totalScores.length;
			const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0);
			const percentage = (avgScore / maxPossible) * 100;
			
			let forecast = '';
			let forecastColor = '';
			
			if (percentage >= 80) {
				forecast = 'Высокая вероятность отличных результатов';
				forecastColor = '#27ae60';
			} else if (percentage >= 60) {
				forecast = 'Стабильные результаты, хорошие перспективы';
				forecastColor = '#3498db';
			} else if (percentage >= 40) {
				forecast = 'Требуется коррекция для достижения планируемых результатов';
				forecastColor = '#f39c12';
			} else {
				forecast = 'Высокий риск не достижения планируемых результатов';
				forecastColor = '#e74c3c';
			}
			
			return `
				<div class="recommendation-card">
					<h4>?? Прогноз учебных достижений</h4>
					<p style="color: ${forecastColor}; font-weight: bold;">${forecast}</p>
					<p><strong>Текущий уровень освоения:</strong> ${percentage.toFixed(1)}%</p>
					<p><strong>Рекомендация:</strong> ${generateForecastRecommendation(percentage)}</p>
				</div>
			`;
		}

		function generateForecastRecommendation(percentage) {
			if (percentage >= 80) return 'Продолжить текущую траекторию обучения';
			if (percentage >= 60) return 'Усилить работу над сложными темами';
			if (percentage >= 40) return 'Провести коррекционные занятия';
			return 'Требуется разработка индивидуальных программ';
		}

		// Рекомендации для рубежной работы
		function generateMilestoneRecommendations() {
			return `
				<div class="recommendation-card">
					<h4>?? Рекомендации на следующий учебный период</h4>
					<ul>
						<li>Скорректировать тематическое планирование с учетом выявленных трудностей</li>
						<li>Запланировать повторение проблемных тем</li>
						<li>Разработать дифференцированные задания для различных групп учащихся</li>
						<li>Организовать дополнительные консультации для отстающих</li>
						<li>Вести мониторинг динамики учебных достижений</li>
					</ul>
				</div>
			`;
		}

		// Анализ освоения темы для текущей работы
		function generateTopicMasteryAnalysis() {
			const totalScores = appData.results.map(scores => scores.reduce((sum, score) => sum + score, 0));
			const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0);
			const avgPercentage = (totalScores.reduce((sum, score) => sum + score, 0) / (maxPossible * totalScores.length)) * 100;
			
			let masteryLevel = '';
			if (avgPercentage >= 80) masteryLevel = 'Тема усвоена';
			else if (avgPercentage >= 60) masteryLevel = 'Тема в основном усвоена';
			else if (avgPercentage >= 40) masteryLevel = 'Тема усвоена частично';
			else masteryLevel = 'Тема не усвоена';
			
			return `
				<div class="recommendation-card">
					<h4>?? Освоение учебной темы</h4>
					<p><strong>Тема:</strong> ${appData.test.theme}</p>
					<p><strong>Уровень освоения:</strong> ${masteryLevel}</p>
					<p><strong>Процент выполнения:</strong> ${avgPercentage.toFixed(1)}%</p>
					<p><strong>Рекомендация:</strong> ${generateTopicRecommendation(avgPercentage)}</p>
				</div>
			`;
		}

		function generateTopicRecommendation(percentage) {
			if (percentage >= 80) return 'Можно переходить к следующей теме';
			if (percentage >= 60) return 'Рекомендуется провести урок обобщения';
			if (percentage >= 40) return 'Требуется дополнительный урок по теме';
			return 'Необходимо повторное изучение темы';
		}

		// Анализ ошибок для текущей работы
		function generateCurrentErrorsAnalysis() {
			if (appData.errors.length === 0) {
				return `
					<div class="recommendation-card">
						<h4>? Анализ ошибок</h4>
						<p>Типичные ошибки не выявлены. Учащиеся успешно справились с заданиями.</p>
					</div>
				`;
			}
			
			const errorStats = {};
			appData.errors.forEach(error => {
				errorStats[error.type] = (errorStats[error.type] || 0) + 1;
			});
			
			const topErrors = Object.entries(errorStats)
				.sort(([,a], [,b]) => b - a)
				.slice(0, 3);
			
			let html = '<div class="recommendation-card">';
			html += '<h4>?? Типичные ошибки</h4>';
			html += '<ul>';
			
			topErrors.forEach(([type, count]) => {
				html += `<li>${errorTypes[type].name}: ${count} случаев</li>`;
			});
			
			html += '</ul>';
			html += '<p><strong>Рекомендации:</strong></p>';
			html += '<ul>';
			
			topErrors.forEach(([type, _]) => {
				switch(type) {
					case 'calculation':
						html += '<li>Провести минутку вычислений на уроке</li>';
						break;
					case 'conceptual':
						html += '<li>Повторить основные понятия темы</li>';
						break;
					case 'attention':
						html += '<li>Тренировать внимательность при чтении заданий</li>';
						break;
					default:
						html += '<li>Проработать типичные ошибки</li>';
				}
			});
			
			html += '</ul></div>';
			
			return html;
		}

		// Рекомендации для урока
		function generateLessonRecommendations() {
			const needHelpCount = countStudentsByPerformanceLevel('need_help');
			
			let html = '<div class="recommendation-card">';
			html += '<h4>?? Рекомендации для следующего урока</h4>';
			
			if (needHelpCount === 0) {
				html += '<p>Все учащиеся успешно освоили тему. Можно переходить к новому материалу.</p>';
			} else if (needHelpCount <= 5) {
				html += `
					<p><strong>Индивидуальная работа:</strong> ${needHelpCount} учащимся требуется дополнительная помощь</p>
					<ul>
						<li>Организовать работу в парах</li>
						<li>Подготовить индивидуальные карточки-помощники</li>
						<li>Провести консультацию после уроков</li>
					</ul>
				`;
			} else {
				html += `
					<p><strong>Групповая работа:</strong> ${needHelpCount} учащимся требуется помощь</p>
					<ul>
						<li>Провести урок повторения и коррекции</li>
						<li>Организовать работу в малых группах</li>
						<li>Использовать дифференцированные задания</li>
					</ul>
				`;
			}
			
			html += '</div>';
			return html;
		}

		// Подсчет учащихся по уровням успеваемости
		function countStudentsByPerformanceLevel(level) {
			const totalScores = appData.results.map(scores => scores.reduce((sum, score) => sum + score, 0));
			const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0);
			const percentages = totalScores.map(score => (score / maxPossible) * 100);
			
			switch(level) {
				case 'mastered':
					return percentages.filter(p => p >= 70).length;
				case 'need_help':
					return percentages.filter(p => p < 50).length;
				default:
					return 0;
			}
		}

		// Диагностические функции
		function calculateBaselineLevel() {
			const totalScores = appData.results.map(scores => scores.reduce((sum, score) => sum + score, 0));
			const avgScore = totalScores.reduce((sum, score) => sum + score, 0) / totalScores.length;
			const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0);
			const percentage = (avgScore / maxPossible) * 100;
			
			if (percentage >= 70) return 'Высокий';
			if (percentage >= 50) return 'Средний';
			if (percentage >= 30) return 'Ниже среднего';
			return 'Низкий';
		}

		function identifyGaps() {
			const gaps = [];
			
			appData.tasks.forEach((task, index) => {
				const completion = calculateTaskCompletion(index);
				if (completion < 50) {
					gaps.push({
						task: task.type,
						completion: completion,
						knowledge: task.knowledge
					});
				}
			});
			
			return gaps;
		}

		function calculateReadinessLevel() {
			const totalScores = appData.results.map(scores => scores.reduce((sum, score) => sum + score, 0));
			const avgScore = totalScores.reduce((sum, score) => sum + score, 0) / totalScores.length;
			const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0);
			const percentage = (avgScore / maxPossible) * 100;
			
			if (percentage >= 80) return 'Готов';
			if (percentage >= 60) return 'Условно готов';
			if (percentage >= 40) return 'Требует подготовки';
			return 'Не готов';
		}

		// Анализ пробелов для диагностической работы
		function generateGapsAnalysis() {
			const gaps = identifyGaps();
			
			if (gaps.length === 0) {
				return `
					<div class="recommendation-card">
						<h4>? Диагностика пробелов</h4>
						<p>Значительные пробелы в знаниях не выявлены.</p>
					</div>
				`;
			}
			
			let html = '<div class="recommendation-card">';
			html += '<h4>?? Выявленные пробелы в знаниях</h4>';
			html += '<div class="table-container"><table>';
			html += '<thead><tr><th>Область знаний</th><th>Задание</th><th>% выполнения</th><th>Критичность</th></tr></thead><tbody>';
			
			gaps.forEach(gap => {
				let criticality = '';
				let color = '';
				
				if (gap.completion < 30) {
					criticality = 'Критический';
					color = '#e74c3c';
				} else if (gap.completion < 40) {
					criticality = 'Высокий';
					color = '#f39c12';
				} else {
					criticality = 'Средний';
					color = '#3498db';
				}
				
				html += `
					<tr>
						<td>${gap.knowledge}</td>
						<td>${gap.task}</td>
						<td>${gap.completion.toFixed(1)}%</td>
						<td style="color: ${color}; font-weight: bold;">${criticality}</td>
					</tr>
				`;
			});
			
			html += '</tbody></table></div></div>';
			
			return html;
		}

		// Группировка учащихся для диагностики
		function generateDiagnosticGroups() {
			const totalScores = appData.results.map(scores => scores.reduce((sum, score) => sum + score, 0));
			const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0);
			const percentages = totalScores.map(score => (score / maxPossible) * 100);
			
			const groups = {
				advanced: percentages.filter(p => p >= 80).length,
				proficient: percentages.filter(p => p >= 60 && p < 80).length,
				basic: percentages.filter(p => p >= 40 && p < 60).length,
				below_basic: percentages.filter(p => p < 40).length
			};
			
			return `
				<div class="recommendation-card">
					<h4>?? Группы учащихся по уровню подготовки</h4>
					<div class="kpi-grid">
						<div class="kpi-card" style="border-left-color: #27ae60">
							<div class="kpi-value">${groups.advanced}</div>
							<div class="kpi-label">Продвинутый</div>
							<small>> 80%</small>
						</div>
						<div class="kpi-card" style="border-left-color: #3498db">
							<div class="kpi-value">${groups.proficient}</div>
							<div class="kpi-label">Базовый</div>
							<small>60-79%</small>
						</div>
						<div class="kpi-card" style="border-left-color: #f39c12">
							<div class="kpi-value">${groups.basic}</div>
							<div class="kpi-label">Ограниченный</div>
							<small>40-59%</small>
						</div>
						<div class="kpi-card" style="border-left-color: #e74c3c">
							<div class="kpi-value">${groups.below_basic}</div>
							<div class="kpi-label">Низкий</div>
							<small>< 40%</small>
						</div>
					</div>
				</div>
			`;
		}

		// Рекомендации по диагностике
		function generateDiagnosticRecommendations() {
			const gaps = identifyGaps();
			const readiness = calculateReadinessLevel();
			
			let html = '<div class="recommendation-card">';
			html += '<h4>?? Диагностические рекомендации</h4>';
			
			html += `<p><strong>Общая готовность:</strong> ${readiness}</p>`;
			html += `<p><strong>Выявлено пробелов:</strong> ${gaps.length}</p>`;
			
			html += '<p><strong>Рекомендуемые действия:</strong></p>';
			html += '<ul>';
			
			if (gaps.length > 5) {
				html += '<li>Разработать коррекционную программу</li>';
				html += '<li>Организовать дополнительные занятия</li>';
				html += '<li>Вести индивидуальные дневники прогресса</li>';
			} else if (gaps.length > 0) {
				html += '<li>Провести целевые уроки по проблемным темам</li>';
				html += '<li>Организовать взаимопомощь в классе</li>';
				html += '<li>Использовать дифференцированные задания</li>';
			} else {
				html += '<li>Продолжить обучение по текущей программе</li>';
				html += '<li>Включить элементы углубленного изучения</li>';
				html += '<li>Развивать творческие способности учащихся</li>';
			}
			
			html += '</ul></div>';
			
			return html;
		}

		// Функции для генерации специализированных отчетов
		function generateMilestoneSpecializedReport() {
			updateMilestoneAnalysis();
			return `
				<h3>?? Анализ рубежной контрольной работы</h3>
				<p>Оценка учебных достижений за учебный период с анализом динамики и прогнозом дальнейшего развития.</p>
				${document.getElementById('specializedAnalysis').innerHTML}
			`;
		}

		function generateCurrentSpecializedReport() {
			updateCurrentAnalysis();
			return `
				<h3>?? Анализ текущей контрольной работы</h3>
				<p>Оперативный анализ освоения учебной темы с рекомендациями для последующей работы на уроке.</p>
				${document.getElementById('specializedAnalysis').innerHTML}
			`;
		}

		function generateDiagnosticSpecializedReport() {
			updateDiagnosticAnalysis();
			return `
				<h3>?? Диагностический анализ</h3>
				<p>Выявление уровня подготовленности учащихся, диагностика пробелов в знаниях и определение индивидуальных образовательных траекторий.</p>
				${document.getElementById('specializedAnalysis').innerHTML}
			`;
		}

		// Обновляем функцию exportSpecializedReport()
		function exportSpecializedReport() {
			const workType = appData.test.workType;
			let reportTitle = "";
			let reportDescription = "";
			let specializedContent = "";
			
			switch(workType) {
				case 'vpr': 
					updateVPRAnalysis();
					specializedContent = generateVPRSpecializedReport();
					reportTitle = "Специализированный отчет по ВПР";
					reportDescription = "Детальный анализ результатов Всероссийской проверочной работы";
					break;
				case 'oge': 
					updateGIAnalysis();
					specializedContent = generateOGESpecializedReport();
					reportTitle = "Анализ результатов ОГЭ";
					reportDescription = "Отчет с анализом выполнения заданий по кодам КЭС и подготовке к экзамену";
					break;
				case 'ege': 
					updateGIAnalysis();
					specializedContent = generateEGESpecializedReport();
					reportTitle = "Анализ результатов ЕГЭ";
					reportDescription = "Детальный анализ подготовки к единому государственному экзамену";
					break;
				case 'func_literacy': 
					updateLiteracyAnalysis();
					specializedContent = generateLiteracySpecializedReport();
					reportTitle = "Отчет по функциональной грамотности";
					reportDescription = "Анализ уровня сформированности функциональной грамотности учащихся";
					break;
				case 'final':
					updateFinalAnalysis();
					specializedContent = generateFinalSpecializedReport();
					reportTitle = "Итоговый педагогический анализ";
					reportDescription = "Комплексный анализ образовательных результатов за учебный период";
					break;
				case 'milestone':
					updateMilestoneAnalysis();
					specializedContent = generateMilestoneSpecializedReport();
					reportTitle = "Анализ рубежной контрольной работы";
					reportDescription = "Оценка учебных достижений за учебный период";
					break;
				case 'current':
					updateCurrentAnalysis();
					specializedContent = generateCurrentSpecializedReport();
					reportTitle = "Анализ текущей контрольной работы";
					reportDescription = "Оперативный анализ освоения учебной темы";
					break;
				case 'diagnostic':
					updateDiagnosticAnalysis();
					specializedContent = generateDiagnosticSpecializedReport();
					reportTitle = "Диагностический анализ";
					reportDescription = "Выявление уровня подготовленности учащихся";
					break;
				case 'psychology': 
					specializedContent = generatePsychologyPrintReport();
					reportTitle = "Психологическое заключение";
					reportDescription = "Анализ результатов психологической диагностики";
					break;
				default: 
					specializedContent = generateStandardSpecializedReport();
					reportTitle = "Специализированный педагогический анализ";
					reportDescription = "Комплексный анализ образовательных результатов";
			}
			
			const fullReport = generateSpecializedReportHTML(reportTitle, reportDescription, specializedContent);
			
			const blob = new Blob([fullReport], { type: 'text/html' });
			const url = URL.createObjectURL(blob);
			const a = document.createElement('a');
			a.href = url;
			a.download = `${reportTitle.toLowerCase().replace(/\s+/g, '_')}_${new Date().toLocaleDateString()}.html`;
			a.click();
			URL.revokeObjectURL(url);
			showNotification("Специализированный отчет экспортирован", "success");
		}

		function initLiteracyRadarChart() {
		    const canvas = document.getElementById('literacyRadarChart');
			const container = canvas.parentElement;
			
			// Устанавливаем размеры относительно родителя
			canvas.width = container.offsetWidth;
			canvas.height = container.offsetHeight - 50; // Минус место для заголовка
			
			if (window.literacyRadarChartInstance) {
				window.literacyRadarChartInstance.destroy();
			}
			
			const literacyStats = {};
			Object.keys(functionalLiteracyTypes).forEach(type => {
				literacyStats[type] = { total: 0, max: 0, count: 0 };
			});
			
			appData.tasks.forEach((task, taskIndex) => {
				if (task.literacyType && literacyStats[task.literacyType]) {
					const maxScore = task.maxScore;
					const actualScores = appData.results.map(student => student[taskIndex] || 0);
					const actualTotal = actualScores.reduce((sum, score) => sum + score, 0);
					
					literacyStats[task.literacyType].total += actualTotal;
					literacyStats[task.literacyType].max += maxScore * appData.results.length;
				}
			});
			
			const ctx = document.getElementById('literacyRadarChart').getContext('2d');
			const labels = Object.keys(literacyStats).map(type => functionalLiteracyTypes[type].name);
			const data = Object.values(literacyStats).map(stats => 
				stats.max > 0 ? (stats.total / stats.max) * 100 : 0
			);
			const colors = Object.keys(literacyStats).map(type => functionalLiteracyTypes[type].color);
			
			window.literacyRadarChartInstance = new Chart(ctx, {
				type: 'radar',
				data: {
					labels: labels,
					datasets: [{
						label: 'Уровень сформированности (%)',
						data: data,
						backgroundColor: 'rgba(54, 162, 235, 0.2)',
						borderColor: 'rgba(54, 162, 235, 0.8)',
						pointBackgroundColor: colors,
						pointBorderColor: '#fff',
						pointHoverBackgroundColor: '#fff',
						pointHoverBorderColor: colors,
						pointRadius: 4,
						pointBorderWidth: 2
					}]
				},
				options: {
					responsive: true,
					maintainAspectRatio: false,
					scales: {
						r: {
							beginAtZero: true,
							max: 100,
							ticks: {
								callback: function(value) {
									return value + '%';
								},
								stepSize: 20
							},
							pointLabels: {
								font: {
									size: 11
								}
							}
						}
					},
					plugins: {
						legend: {
							display: true,
							position: 'top'
						},
						tooltip: {
							callbacks: {
								label: function(context) {
									return `${context.label}: ${context.raw.toFixed(1)}%`;
								}
							}
						}
					}
				}
			});
			// Принудительный рефлоу для стабилизации layout
			setTimeout(() => {
				const chartContainer = document.querySelector('.chart-container');
				if (chartContainer) {
					chartContainer.style.display = 'none';
					chartContainer.offsetHeight; // trigger reflow
					chartContainer.style.display = 'block';
				}
			}, 100);
		}

        // ==================== РЕКОМЕНДАЦИИ ====================

        function updateRecommendations() {
            updatePrintHeaders();
            updateKeyConclusions();
            updateCorrectionPlan();
            updateNextSteps();
        }

        function updatePrintHeaders() {
            document.getElementById('printSubjectClass').textContent = `${appData.test.subject}, ${appData.test.class}`;
            document.getElementById('printTheme').textContent = appData.test.theme;
            document.getElementById('printDate').textContent = new Date(appData.test.testDate).toLocaleDateString();
        }

        // Ключевые выводы
        function updateKeyConclusions() {
            const totalScores = appData.results.map(scores => scores.reduce((sum, score) => sum + score, 0));
            const grades = totalScores.map(score => calculateGrade(score));
            const avgScore = totalScores.reduce((sum, score) => sum + score, 0) / totalScores.length;
            const successRate = (grades.filter(grade => grade >= 3).length / grades.length * 100);
            
            let html = '<div class="recommendation-card">';
            
            if (successRate >= 80) {
                html += '<strong>? Высокий уровень усвоения материала</strong><br>';
                html += 'Большинство учащихся успешно справились с работой. ';
            } else if (successRate >= 60) {
                html += '<strong>?? Средний уровень усвоения материала</strong><br>';
                html += 'Требуется коррекционная работа с отдельными группами учащихся. ';
            } else {
                html += '<strong>?? Низкий уровень усвоения материала</strong><br>';
                html += 'Необходимо пересмотреть методы преподавания и провести повторение. ';
            }
            
            const difficultTasks = [];
            appData.tasks.forEach((task, index) => {
                const completion = calculateTaskCompletion(index);
                if (completion < 50) {
                    difficultTasks.push({ task: index + 1, completion: completion, type: task.type });
                }
            });
            
            if (difficultTasks.length > 0) {
                html += `<br><strong>Проблемные задания:</strong> `;
                html += difficultTasks.map(t => `№${t.task} (${t.completion.toFixed(1)}%)`).join(', ');
            }
            
            if (appData.errors.length > 0) {
                const topErrorType = getTopErrorType();
                html += `<br><strong>Преобладающие ошибки:</strong> ${errorTypes[topErrorType].name}`;
            }
            
            const workType = appData.test.workType;
            if (workType === 'vpr') {
                html += `<br><strong>Особенности ВПР:</strong> Необходимо уделить внимание формированию базовых компетенций.`;
            } else if (workType === 'func_literacy') {
                html += `<br><strong>Особенности функциональной грамотности:</strong> Требуется развитие практических умений применения знаний в реальных ситуациях.`;
            } else if (workType === 'oge' || workType === 'ege') {
                html += `<br><strong>Особенности ГИА:</strong> Необходимо продолжить целенаправленную подготовку к экзамену.`;
            }
            
            html += '</div>';
            document.getElementById('keyConclusions').innerHTML = html;
        }

        // План коррекционных мероприятий
        function updateCorrectionPlan() {
            let html = '';
            
            html += '<div class="sub-section"><h4>????? Для всего класса:</h4>';
            html += '<div class="recommendation-card">';
            html += '• Проведение работы над ошибками<br>';
            html += '• Повторение проблемных тем<br>';
            html += '• Разработка дополнительных упражнений<br>';
            html += '• Изменение подходов к преподаванию сложных тем';
            
            const workType = appData.test.workType;
            if (workType === 'vpr') {
                html += '<br>• Акцент на формирование базовых компетенций ВПР';
            } else if (workType === 'func_literacy') {
                html += '<br>• Включение заданий с реальными жизненными ситуациями';
                html += '<br>• Развитие критического мышления и работы с информацией';
            } else if (workType === 'oge' || workType === 'ege') {
                html += '<br>• Тренировка выполнения заданий в формате ГИА';
                html += '<br>• Работа с кодификатором и спецификацией';
            }
            
            html += '</div></div>';
            
            const unsatisfactory = appData.results.map((scores, index) => ({
                name: appData.students[index],
                score: scores.reduce((sum, score) => sum + score, 0),
                grade: calculateGrade(scores.reduce((sum, score) => sum + score, 0))
            })).filter(s => s.grade === 2);
            
            if (unsatisfactory.length > 0) {
                html += '<div class="sub-section"><h4>?? Для учащихся с неудовлетворительными результатами:</h4>';
                unsatisfactory.forEach(student => {
                    html += `<div class="recommendation-card">
                        <strong>${student.name}</strong><br>
                        • Индивидуальные консультации<br>
                        • Повторение базовых тем<br>
                        • Дополнительные задания<br>
                        • Вовлечение родителей
                    </div>`;
                });
                html += '</div>';
            }
            
            document.getElementById('correctionPlan').innerHTML = html;
        }

        // Дальнейшие шаги
        function updateNextSteps() {
            let html = `
                <div class="recommendation-card">
                    <strong>?? Ближайшие мероприятия:</strong><br>
                    • Срок работы над ошибками: 1 неделя<br>
                    • Индивидуальные консультации: по графику<br>
                    • Информирование родителей: в течение 3 дней<br>
                    • Повторный контроль: через 2 недели<br>
                    • Коррекция КТП: до следующей темы
            `;
            
            const workType = appData.test.workType;
            if (workType === 'vpr') {
                html += '<br>• Анализ результатов на методическом объединении';
                html += '<br>• Планирование работы по устранению выявленных дефицитов';
            } else if (workType === 'func_literacy') {
                html += '<br>• Включение заданий на функциональную грамотность в текущий урок';
                html += '<br>• Участие в диагностиках функциональной грамотности';
            } else if (workType === 'oge' || workType === 'ege') {
                html += '<br>• Составление индивидуальных образовательных маршрутов';
                html += '<br>• Участие в пробных экзаменах';
            }
            
            html += '</div>';
            document.getElementById('nextSteps').innerHTML = html;
        }

        // Вспомогательные функции
        function calculateTaskCompletion(taskIndex) {
			try {
				if (!appData.tasks || !appData.results || appData.results.length === 0) {
					return 0;
				}
				
				const task = appData.tasks[taskIndex];
				if (!task || typeof task.maxScore !== 'number' || task.maxScore <= 0) {
					return 0;
				}
				
				const maxScore = task.maxScore;
				const actualScores = appData.results.map(student => 
					student && student[taskIndex] !== undefined ? student[taskIndex] : 0
				);
				const actualTotal = actualScores.reduce((sum, score) => sum + score, 0);
				const totalPossible = maxScore * appData.results.length;
				
				return totalPossible > 0 ? (actualTotal / totalPossible) * 100 : 0;
				
			} catch (error) {
				console.error('Ошибка расчета выполнения задания:', error, taskIndex);
				return 0;
			}
		}

        function getTopErrorType() {
            const errorStats = {};
            appData.errors.forEach(error => {
                errorStats[error.type] = (errorStats[error.type] || 0) + 1;
            });
            return Object.entries(errorStats).sort(([,a], [,b]) => b - a)[0][0];
        }

        // ==================== ЭКСПОРТ И ПЕЧАТЬ ====================

		function generateFullReportForPrint() {
			if (!appData.test.subject && !appData.test.class) {
				return `
					<div class="header">
						<h1>?? Аналитический отчет по диагностической работе</h1>
						<p>Данные не заполнены. Пожалуйста, заполните настройки работы и введите результаты.</p>
					</div>
				`;
			}

			const totalScores = appData.results.map(scores => scores.reduce((sum, score) => sum + score, 0));
			const grades = totalScores.map(score => calculateGrade(score));
			const avgScore = totalScores.length > 0 ? totalScores.reduce((sum, score) => sum + score, 0) / totalScores.length : 0;
			const successRate = totalScores.length > 0 ? (grades.filter(grade => grade >= 3).length / grades.length * 100) : 0;
			const qualityRate = totalScores.length > 0 ? (grades.filter(grade => grade >= 4).length / grades.length * 100) : 0;
			
			const gradeCounts = {5: 0, 4: 0, 3: 0, 2: 0};
			grades.forEach(grade => gradeCounts[grade]++);

			const taskAnalysis = appData.tasks.map((task, index) => {
				const completion = calculateTaskCompletion(index);
				let zone = '';
				let zoneColor = '';
				if (completion >= 90) { zone = 'Отличная'; zoneColor = '#27ae60'; }
				else if (completion >= 60) { zone = 'Зеленая'; zoneColor = '#2ecc71'; }
				else if (completion >= 30) { zone = 'Желтая'; zoneColor = '#f39c12'; }
				else { zone = 'Красная'; zoneColor = '#e74c3c'; }
				
				return { task, index, completion, zone, zoneColor };
			});

			const levelAnalysis = {};
			Object.keys(complexityLevels).forEach(level => {
				const levelTasks = appData.tasks.filter(task => task.level == level);
				if (levelTasks.length > 0) {
					let totalMaxScore = 0;
					let totalActualScore = 0;
					
					levelTasks.forEach(task => {
						const taskIndex = appData.tasks.indexOf(task);
						const maxScore = task.maxScore;
						const actualScores = appData.results.map(student => student[taskIndex] || 0);
						const actualTotal = actualScores.reduce((sum, score) => sum + score, 0);
						
						totalMaxScore += maxScore * appData.results.length;
						totalActualScore += actualTotal;
					});
					
					const completion = totalMaxScore > 0 ? (totalActualScore / totalMaxScore) * 100 : 0;
					levelAnalysis[level] = { completion, count: levelTasks.length };
				}
			});

			let reportContent = `
				<div class="header">
					<h1>?? Аналитический отчет по диагностической работе</h1>
					<h2>${appData.test.subject || 'Предмет не указан'}, ${appData.test.class || 'Класс не указан'}</h2>
					<p><strong>Тема:</strong> ${appData.test.theme || 'Не указана'} | <strong>Дата:</strong> ${appData.test.testDate ? new Date(appData.test.testDate).toLocaleDateString() : 'Не указана'}</p>
					<p><strong>Тип работы:</strong> ${workTypes[appData.test.workType]?.name || appData.test.workType}</p>
				</div>

				<div class="section">
					<h3 class="section-title">?? Общая статистика</h3>
					<div class="stats-grid">
						<div class="stat-card">
							<div class="stat-value">${avgScore.toFixed(1)}</div>
							<div class="stat-label">Средний балл</div>
						</div>
						<div class="stat-card">
							<div class="stat-value">${successRate.toFixed(1)}%</div>
							<div class="stat-label">Успеваемость</div>
						</div>
						<div class="stat-card">
							<div class="stat-value">${qualityRate.toFixed(1)}%</div>
							<div class="stat-label">Качество знаний</div>
						</div>
						<div class="stat-card">
							<div class="stat-value">${appData.students.length}</div>
							<div class="stat-label">Учащихся</div>
						</div>
					</div>
					
					<div class="kpi-grid">
						<div class="kpi-card">
							<div style="font-size: 1.4em; font-weight: bold; color: #2c3e50;">${gradeCounts[5]}</div>
							<div style="color: #7f8c8d; font-size: 0.9em;">Оценка 5</div>
						</div>
						<div class="kpi-card">
							<div style="font-size: 1.4em; font-weight: bold; color: #2c3e50;">${gradeCounts[4]}</div>
							<div style="color: #7f8c8d; font-size: 0.9em;">Оценка 4</div>
						</div>
						<div class="kpi-card">
							<div style="font-size: 1.4em; font-weight: bold; color: #2c3e50;">${gradeCounts[3]}</div>
							<div style="color: #7f8c8d; font-size: 0.9em;">Оценка 3</div>
						</div>
						<div class="kpi-card">
							<div style="font-size: 1.4em; font-weight: bold; color: #2c3e50;">${gradeCounts[2]}</div>
							<div style="color: #7f8c8d; font-size: 0.9em;">Оценка 2</div>
						</div>
					</div>
				</div>

				<div class="section print-break">
					<h3 class="section-title">?? Анализ выполнения заданий</h3>
					${taskAnalysis.length > 0 ? `
						<table>
							<thead>
								<tr>
									<th>№</th>
									<th>Тип задания</th>
									<th>Уровень</th>
									<th>Макс. балл</th>
									<th>% выполнения</th>
									<th>Зона</th>
								</tr>
							</thead>
							<tbody>
								${taskAnalysis.map(item => `
									<tr>
										<td><strong>${item.index + 1}</strong></td>
										<td>${item.task.type}</td>
										<td>${item.task.level}. ${complexityLevels[item.task.level]?.name || 'Не указан'}</td>
										<td>${item.task.maxScore}</td>
										<td>${item.completion.toFixed(1)}%</td>
										<td style="color: ${item.zoneColor}; font-weight: bold;">${item.zone}</td>
									</tr>
								`).join('')}
							</tbody>
						</table>
					` : '<p>Задания не добавлены</p>'}
				</div>

				<div class="section">
					<h3 class="section-title">?? Анализ по уровням сложности</h3>
					${Object.keys(levelAnalysis).length > 0 ? `
						<table>
							<thead>
								<tr>
									<th>Уровень сложности</th>
									<th>Кол-во заданий</th>
									<th>% выполнения</th>
									<th>Анализ</th>
								</tr>
							</thead>
							<tbody>
								${Object.entries(levelAnalysis).map(([level, data]) => {
									let analysis = "";
									if (data.completion >= 80) analysis = "?? Высокий уровень усвоения";
									else if (data.completion >= 60) analysis = "?? Средний уровень усвоения";
									else if (data.completion >= 40) analysis = "?? Требуется коррекция";
									else analysis = "?? Серьезные проблемы";
									
									return `
										<tr>
											<td><strong>${level}. ${complexityLevels[level]?.name || 'Не указан'}</strong></td>
											<td>${data.count}</td>
											<td>${data.completion.toFixed(1)}%</td>
											<td>${analysis}</td>
										</tr>
									`;
								}).join('')}
							</tbody>
						</table>
					` : '<p>Нет данных для анализа</p>'}
				</div>
			`;
			reportContent += generateCriteriaSummary();
			// ДОБАВЛЯЕМ ПСИХОЛОГИЧЕСКИЙ АНАЛИЗ ЕСЛИ ЭТО ПСИХОЛОГИЯ
			if (appData.test.workType === 'psychology') {
				reportContent += generatePsychologyPrintReport();
			}

			reportContent += `
				<div class="section print-break">
					<h3 class="section-title">?? Ключевые выводы и рекомендации</h3>
					<div class="recommendation-card">
						${generateKeyConclusionsText()}
					</div>
					
					<h4 style="margin-top: 20px;">?? План коррекционных мероприятий:</h4>
					<div class="recommendation-card">
						<ul style="margin: 0; padding-left: 20px;">
							<li>Проведение работы над ошибками в течение недели</li>
							<li>Организация дополнительных консультаций для отстающих учащихся</li>
							<li>Разработка дополнительных упражнений по проблемным темам</li>
							<li>Информирование родителей о результатах работы</li>
							<li>Повторный контроль через 2 недели</li>
						</ul>
					</div>
				</div>

				<div class="section small-text text-center">
					<p><em>Отчет сгенерирован ${new Date().toLocaleDateString()} системой анализа образовательных результатов</em></p>
				</div>
			`;
			
			return reportContent;
		}		
        
		// Добавим кнопки пресетов
		function addCriteriaPresets() {
			return `
				<div style="margin: 15px 0; padding: 10px; background: #f8f9fa; border-radius: 8px;">
					<h5 style="margin: 0 0 10px 0; font-size: 14px;">?? Быстрые пресеты:</h5>
					<div style="display: flex; flex-wrap: wrap; gap: 5px;">
						<button class="btn btn-sm" onclick="applyPreset('standard_5')" 
								style="font-size: 12px; padding: 5px 10px;">
							?? Стандартная (2-5)
						</button>
						<button class="btn btn-sm" onclick="applyPreset('five_point')" 
								style="font-size: 12px; padding: 5px 10px;">
							1?? Пятибалльная (1-5)
						</button>
						<button class="btn btn-sm" onclick="applyPreset('vpr_percent')" 
								style="font-size: 12px; padding: 5px 10px;">
							?? ВПР (проценты)
						</button>
						<button class="btn btn-sm" onclick="applyPreset('ege_points')" 
								style="font-size: 12px; padding: 5px 10px;">
							?? ЕГЭ (баллы)
						</button>
					</div>
					<small style="display: block; margin-top: 8px; color: #666;">
						Применение пресета сбросит текущие настройки критериев
					</small>
				</div>
			`;
		}
		function addCriteriaPresets() {
			return `
				<div style="margin: 15px 0; padding: 10px; background: #f8f9fa; border-radius: 8px;">
					<h5 style="margin: 0 0 10px 0; font-size: 14px;">?? Быстрые пресеты:</h5>
					<div style="display: flex; flex-wrap: wrap; gap: 5px;">
						<button class="btn btn-sm" onclick="applyPreset('standard_5')" 
								style="font-size: 12px; padding: 5px 10px;">
							?? Стандартная (2-5)
						</button>
						<button class="btn btn-sm" onclick="applyPreset('five_point')" 
								style="font-size: 12px; padding: 5px 10px;">
							1?? Пятибалльная (1-5)
						</button>
						<button class="btn btn-sm" onclick="applyPreset('vpr_percent')" 
								style="font-size: 12px; padding: 5px 10px;">
							?? ВПР (проценты)
						</button>
						<button class="btn btn-sm" onclick="applyPreset('ege_points')" 
								style="font-size: 12px; padding: 5px 10px;">
							?? ЕГЭ (баллы)
						</button>
					</div>
					<small style="display: block; margin-top: 8px; color: #666;">
						Применение пресета сбросит текущие настройки критериев
					</small>
				</div>
			`;
		}

		function applyPreset(presetName) {
			const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0) || 100;
			
			switch(presetName) {
				case 'standard_5':
					appData.test.criteriaType = 'points';
					appData.test.criteriaSystem = 'standard';
					appData.test.criteriaCount = 4;
					appData.test.criteria = {
						1: { min: 0, max: Math.round(maxPossible * 0.49) },
						2: { min: Math.round(maxPossible * 0.5), max: Math.round(maxPossible * 0.69) },
						3: { min: Math.round(maxPossible * 0.7), max: Math.round(maxPossible * 0.84) },
						4: { min: Math.round(maxPossible * 0.85), max: maxPossible }
					};
					break;
					
				case 'five_point':
					appData.test.criteriaType = 'points';
					appData.test.criteriaSystem = 'five_point';
					appData.test.criteriaCount = 5;
					appData.test.criteria = {
						1: { min: 0, max: Math.round(maxPossible * 0.2) },
						2: { min: Math.round(maxPossible * 0.21), max: Math.round(maxPossible * 0.4) },
						3: { min: Math.round(maxPossible * 0.41), max: Math.round(maxPossible * 0.6) },
						4: { min: Math.round(maxPossible * 0.61), max: Math.round(maxPossible * 0.8) },
						5: { min: Math.round(maxPossible * 0.81), max: maxPossible }
					};
					break;
					
				case 'vpr_percent':
					appData.test.criteriaType = 'percentage';
					appData.test.criteriaSystem = 'standard';
					appData.test.criteriaCount = 4;
					appData.test.criteria = {
						1: { min: 0, max: 44 },
						2: { min: 45, max: 64 },
						3: { min: 65, max: 84 },
						4: { min: 85, max: 100 }
					};
					break;
					
				case 'psychology_levels':
					appData.test.criteriaType = 'percentage';
					appData.test.criteriaSystem = 'custom';
					appData.test.criteriaCount = 5;
					appData.test.customCriteria = [
						{
							name: "Очень низкий",
							min: 0,
							max: 29,
							description: "Требуется развитие базовых навыков",
							color: "#c0392b"
						},
						{
							name: "Низкий",
							min: 30,
							max: 49,
							description: "Выраженные трудности",
							color: "#e74c3c"
						},
						{
							name: "Средний",
							min: 50,
							max: 69,
							description: "Соответствует возрастной норме",
							color: "#f39c12"
						},
						{
							name: "Высокий",
							min: 70,
							max: 84,
							description: "Хорошо развитые способности",
							color: "#3498db"
						},
						{
							name: "Очень высокий",
							min: 85,
							max: 100,
							description: "Выдающиеся способности",
							color: "#27ae60"
						}
					];
					appData.test.criteria = {
						1: { min: 0, max: 29 },
						2: { min: 30, max: 49 },
						3: { min: 50, max: 69 },
						4: { min: 70, max: 84 },
						5: { min: 85, max: 100 }
					};
					break;
			}
			
			renderCriteriaSettings();
			showNotification(`Применен пресет: ${presetName}`, "success");
		}
		
		function generatePsychologyPrintReport() {
			if (appData.test.workType !== 'psychology') return '';
			
			const settings = appData.test.psychologySettings;
			const levels = settings?.levels || [];
			
			// Рассчитываем распределение по уровням
			const totalScores = appData.results.map(scores => {
				const total = scores.reduce((sum, score) => sum + score, 0);
				const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0);
				return (total / maxPossible) * 100;
			});
			
			const levelCounts = {};
			levels.forEach(level => {
				levelCounts[level.name] = totalScores.filter(score => 
					score >= level.min && score <= level.max
				).length;
			});
			
			// Рассчитываем средние по измерениям
			const dimensions = settings?.dimensions || [];
			const dimensionStats = [];
			
			dimensions.forEach(dimension => {
				const dimensionTasks = appData.tasks.filter(task => task.dimension === dimension.id);
				if (dimensionTasks.length === 0) return;
				
				let totalScore = 0;
				let totalMax = 0;
				
				dimensionTasks.forEach(task => {
					const taskIndex = appData.tasks.indexOf(task);
					const maxScore = task.maxScore;
					const actualScores = appData.results.map(student => student[taskIndex] || 0);
					const actualTotal = actualScores.reduce((sum, score) => sum + score, 0);
					
					totalScore += actualTotal;
					totalMax += maxScore * appData.results.length;
				});
				
				const percentage = totalMax > 0 ? (totalScore / totalMax) * 100 : 0;
				dimensionStats.push({
					name: dimension.name,
					percentage: percentage,
					description: dimension.description || ''
				});
			});
			
			// Находим особенности группы
			const groupFeatures = [];
			if (appData.psychologyFeatures && appData.psychologyFeatures.length > 0) {
				const featureCounts = {};
				appData.psychologyFeatures.forEach(feature => {
					featureCounts[feature.name] = (featureCounts[feature.name] || 0) + 1;
				});
				
				// Берем 3 самые частые особенности
				Object.entries(featureCounts)
					.sort(([,a], [,b]) => b - a)
					.slice(0, 3)
					.forEach(([name, count]) => {
						const percentage = (count / appData.students.length) * 100;
						if (percentage >= 20) { // Если у 20% и более учащихся
							groupFeatures.push(`${name} (${count} чел., ${percentage.toFixed(0)}%)`);
						}
					});
			}
			
			return `
				<div class="section print-break">
					<h3 class="section-title">?? Психологический анализ результатов</h3>
					
					<div class="recommendation-card">
						<h4>?? Общая характеристика</h4>
						<p><strong>Методика:</strong> ${appData.test.theme || 'Не указана'}</p>
						<p><strong>Нормативная выборка:</strong> ${settings?.normGroup || 'Не указана'}</p>
						<p><strong>Надежность теста:</strong> ${settings?.reliability ? settings.reliability.toFixed(2) : 'Не указана'}</p>
						<p><strong>Метод интерпретации:</strong> ${settings?.interpretationMethod === 'normative' ? 'Нормативный (сравнение с нормой)' : 
																   settings?.interpretationMethod === 'ipsative' ? 'Ипсативный (сравнение с самим собой)' : 
																   settings?.interpretationMethod === 'criterion' ? 'Критериальный (достижение цели)' : 'Не указан'}</p>
					</div>
					
					<h4>?? Распределение по уровням развития</h4>
					<table>
						<thead>
							<tr>
								<th>Уровень</th>
								<th>Диапазон</th>
								<th>Кол-во учащихся</th>
								<th>% от группы</th>
								<th>Характеристика</th>
							</tr>
						</thead>
						<tbody>
							${levels.map(level => {
								const count = levelCounts[level.name] || 0;
								const percentage = (count / appData.students.length) * 100;
								return `
									<tr>
										<td style="color: ${level.color}; font-weight: bold;">${level.name}</td>
										<td>${level.min}-${level.max}%</td>
										<td>${count}</td>
										<td>${percentage.toFixed(1)}%</td>
										<td>${level.interpretation || ''}</td>
									</tr>
								`;
							}).join('')}
						</tbody>
					</table>
					
					${dimensionStats.length > 0 ? `
						<h4 style="margin-top: 20px;">?? Профиль по измерениям</h4>
						<table>
							<thead>
								<tr>
									<th>Измерение</th>
									<th>Уровень группы</th>
									<th>% выполнения</th>
									<th>Описание</th>
								</tr>
							</thead>
							<tbody>
								${dimensionStats.map(dim => {
									let levelText = '';
									let levelColor = '';
									
									if (dim.percentage >= 85) {
										levelText = 'Очень высокий';
										levelColor = '#27ae60';
									} else if (dim.percentage >= 70) {
										levelText = 'Высокий';
										levelColor = '#3498db';
									} else if (dim.percentage >= 50) {
										levelText = 'Средний';
										levelColor = '#f39c12';
									} else if (dim.percentage >= 30) {
										levelText = 'Низкий';
										levelColor = '#e74c3c';
									} else {
										levelText = 'Очень низкий';
										levelColor = '#c0392b';
									}
									
									return `
										<tr>
											<td><strong>${dim.name}</strong></td>
											<td style="color: ${levelColor}; font-weight: bold;">${levelText}</td>
											<td>${dim.percentage.toFixed(1)}%</td>
											<td><small>${dim.description}</small></td>
										</tr>
									`;
								}).join('')}
							</tbody>
						</table>
					` : ''}
					
					${groupFeatures.length > 0 ? `
						<div class="recommendation-card" style="margin-top: 20px;">
							<h4>?? Выявленные групповые особенности</h4>
							<ul style="margin: 0; padding-left: 20px;">
								${groupFeatures.map(feature => `<li>${feature}</li>`).join('')}
							</ul>
						</div>
					` : ''}
					
					<div class="recommendation-card" style="margin-top: 20px;">
						<h4>?? Психолого-педагогические рекомендации</h4>
						${generatePsychologyRecommendationsText()}
					</div>
				</div>
			`;
		}

		function generatePsychologyRecommendationsText() {
			const totalScores = appData.results.map(scores => {
				const total = scores.reduce((sum, score) => sum + score, 0);
				const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0);
				return (total / maxPossible) * 100;
			});
			
			const avgScore = totalScores.reduce((sum, score) => sum + score, 0) / totalScores.length;
			
			let recommendations = '';
			
			if (avgScore >= 70) {
				recommendations = `
					<p><strong>Высокий уровень развития группы.</strong> Большинство учащихся демонстрируют хорошие результаты.</p>
					<p><strong>Рекомендуется:</strong></p>
					<ul style="margin: 10px 0; padding-left: 20px;">
						<li>Поддерживать и развивать достигнутый уровень</li>
						<li>Включать элементы углубленного изучения</li>
						<li>Развивать творческие и лидерские качества</li>
						<li>Использовать потенциал группы для помощи отстающим</li>
					</ul>
				`;
			} else if (avgScore >= 50) {
				recommendations = `
					<p><strong>Средний уровень развития группы.</strong> Учащиеся соответствуют возрастной норме, но есть резервы для развития.</p>
					<p><strong>Рекомендуется:</strong></p>
					<ul style="margin: 10px 0; padding-left: 20px;">
						<li>Провести развивающие занятия по проблемным темам</li>
						<li>Организовать работу в малых группах</li>
						<li>Использовать практико-ориентированные задания</li>
						<li>Развивать навыки самоконтроля и рефлексии</li>
					</ul>
				`;
			} else {
				recommendations = `
					<p><strong>Требуется психолого-педагогическое сопровождение.</strong> Выявлены значительные трудности у группы.</p>
					<p><strong>Рекомендуется:</strong></p>
					<ul style="margin: 10px 0; padding-left: 20px;">
						<li>Разработать коррекционную программу</li>
						<li>Организовать индивидуальные консультации</li>
						<li>Привлечь родителей к совместной работе</li>
						<li>Использовать щадящие методы оценивания</li>
						<li>Провести повторную диагностику через месяц</li>
					</ul>
				`;
			}
			
			// Добавляем индивидуальные рекомендации для крайних случаев
			const individualRisks = [];
			totalScores.forEach((score, index) => {
				if (score < 30) {
					individualRisks.push(appData.students[index]);
				}
			});
			
			if (individualRisks.length > 0) {
				recommendations += `
					<p><strong>Индивидуальная работа:</strong> ${individualRisks.length} учащимся требуется особое внимание (${individualRisks.slice(0, 3).join(', ')}${individualRisks.length > 3 ? ' и другие' : ''})</p>
				`;
			}
			
			return recommendations;
		}
		
        // Печать полного отчета
        function printFullReport() {
			const printContent = generateFullReportForPrint();
			
			const printWindow = window.open('', '_blank');
			
			printWindow.document.write(`
				<!DOCTYPE html>
				<html>
				<head>
					<title>Аналитический отчет - ${appData.test.theme || 'Диагностическая работа'}</title>
					<meta charset="UTF-8">
					<style>
						body { 
							font-family: 'Arial', sans-serif; 
							margin: 0; 
							padding: 15mm; 
							line-height: 1.4;
							color: #333;
							font-size: 12pt;
						}
						@page {
							size: A4;
							margin: 15mm;
						}
						.header { 
							text-align: center; 
							margin-bottom: 20px;
							padding-bottom: 15px;
							border-bottom: 2px solid #3498db;
							background: linear-gradient(135deg, #2c3e50, #3498db);
							color: white;
							padding: 20px;
							border-radius: 8px;
						}
						.section { 
							margin: 25px 0; 
							page-break-inside: avoid;
						}
						.section-title {
							color: #2c3e50;
							margin: 15px 0 10px 0;
							padding-bottom: 8px;
							border-bottom: 1px solid #3498db;
							font-size: 1.2em;
						}
						.stats-grid { 
							display: grid; 
							grid-template-columns: repeat(2, 1fr); 
							gap: 10px; 
							margin: 15px 0; 
						}
						.stat-card { 
							background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
							color: white; 
							padding: 15px; 
							border-radius: 8px; 
							text-align: center; 
							box-shadow: 0 3px 10px rgba(0,0,0,0.2);
						}
						.stat-value { 
							font-size: 1.6em; 
							font-weight: bold; 
							margin: 8px 0; 
						}
						.stat-label { 
							font-size: 0.8em; 
							opacity: 0.9; 
						}
						table { 
							width: 100%; 
							border-collapse: collapse; 
							margin: 10px 0;
							font-size: 10pt;
							page-break-inside: avoid;
						}
						th, td { 
							border: 1px solid #ddd; 
							padding: 8px; 
							text-align: left; 
						}
						th { 
							background-color: #34495e; 
							color: white; 
							font-weight: bold;
						}
						.kpi-grid { 
							display: grid; 
							grid-template-columns: repeat(4, 1fr); 
							gap: 10px; 
							margin: 15px 0; 
						}
						.kpi-card { 
							background: #f8f9fa; 
							padding: 12px; 
							border-radius: 6px; 
							text-align: center; 
							border-left: 4px solid #3498db; 
						}
						.kpi-card.success { border-left-color: #27ae60 !important; }
						.kpi-card.warning { border-left-color: #f39c12 !important; }
						.kpi-card.danger { border-left-color: #e74c3c !important; }

						.kpi-card.success .kpi-value { color: #27ae60; }
						.kpi-card.warning .kpi-value { color: #f39c12; }
						.kpi-card.danger .kpi-value { color: #e74c3c; }
						
						.psychology-level {
							display: inline-block;
							padding: 2px 8px;
							border-radius: 12px;
							font-size: 11px;
							margin: 2px;
							color: white;
						}
						.level-very-high { background: #27ae60; }
						.level-high { background: #3498db; }
						.level-medium { background: #f39c12; }
						.level-low { background: #e74c3c; }
						.level-very-low { background: #c0392b; }
						
						.recommendation-card {
							background: #e8f4fc;
							padding: 12px;
							margin: 8px 0;
							border-radius: 6px;
							border-left: 4px solid #3498db;
						}
						.task-analysis {
							background: #f8f9fa;
							padding: 10px;
							margin: 5px 0;
							border-radius: 4px;
							border-left: 3px solid #3498db;
						}
						.print-break { 
							page-break-before: always; 
						}
						.no-print { display: none; }
						.small-text { font-size: 10pt; }
						.text-center { text-align: center; }
						.grade-5 { background-color: #d4edda !important; }
						.grade-4 { background-color: #fff3cd !important; }
						.grade-3 { background-color: #ffeaa7 !important; }
						.grade-2 { background-color: #f8d7da !important; }
						/* Стили для психологических особенностей */
						.psychology-feature {
							display: inline-block;
							background: #f8f9fa;
							border: 1px solid #ddd;
							padding: 3px 8px;
							margin: 2px;
							border-radius: 4px;
							font-size: 10pt;
						}
						ul {
							margin: 10px 0;
							padding-left: 20px;
						}
						li {
							margin: 5px 0;
						}
						.dimension-table {
							margin: 15px 0;
						}
						.dimension-table td {
							vertical-align: top;
						}
						.interpretation-box {
							background: #f8f9fa;
							border-left: 4px solid #3498db;
							padding: 10px;
							margin: 10px 0;
							border-radius: 0 4px 4px 0;
						}
					</style>
				</head>
				<body>
					${printContent}
				</body>
				</html>
			`);
			
			printWindow.document.close();
			
			setTimeout(() => {
				printWindow.print();
				setTimeout(() => {
					printWindow.close();
				}, 500);
			}, 500);
		}

        function exportHTML() {
            const reportContent = generateFullReport();
            const blob = new Blob([reportContent], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `анализ_${appData.test.subject}_${appData.test.class}_${new Date().toLocaleDateString()}.html`;
            a.click();
            URL.revokeObjectURL(url);
            showNotification("HTML отчет экспортирован", "success");
        }

        function generateFullReport() {
            const totalScores = appData.results.map(scores => scores.reduce((sum, score) => sum + score, 0));
            const grades = totalScores.map(score => calculateGrade(score));
            const avgScore = totalScores.reduce((sum, score) => sum + score, 0) / totalScores.length;
            const successRate = (grades.filter(grade => grade >= 3).length / grades.length * 100);
            const qualityRate = (grades.filter(grade => grade >= 4).length / grades.length * 100);
            const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0);
            const completionRate = (totalScores.reduce((sum, score) => sum + score, 0) / (maxPossible * totalScores.length)) * 100;
            
            const gradeCounts = {5: 0, 4: 0, 3: 0, 2: 0};
            grades.forEach(grade => gradeCounts[grade]++);
            
            return `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Аналитический отчет: ${appData.test.theme}</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 40px; 
            line-height: 1.6;
            color: #333;
        }
        .header { 
            text-align: center; 
            margin-bottom: 40px; 
            padding-bottom: 20px; 
            border-bottom: 2px solid #3498db; 
        }
        .section { 
            margin: 30px 0; 
        }
        table { 
            width: 100%; 
            border-collapse: collapse; 
            margin: 15px 0; 
        }
        th, td { 
            border: 1px solid #ddd; 
            padding: 10px; 
            text-align: left; 
        }
        th { 
            background-color: #34495e; 
            color: white; 
        }
        .stats-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); 
            gap: 15px; 
            margin: 20px 0; 
        }
        .stat-card { 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white; 
            padding: 20px; 
            border-radius: 10px; 
            text-align: center; 
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .stat-value { 
            font-size: 2em; 
            font-weight: bold; 
            margin: 10px 0; 
        }
        .stat-label { 
            font-size: 0.9em; 
            opacity: 0.9; 
        }
        .recommendation-card {
            background: #e8f4fc;
            padding: 15px;
            margin: 10px 0;
            border-radius: 6px;
            border-left: 4px solid #3498db;
        }
        .kpi-grid { 
            display: grid; 
            grid-template-columns: repeat(4, 1fr); 
            gap: 15px; 
            margin: 20px 0; 
        }
        .kpi-card { 
            background: #f8f9fa; 
            padding: 15px; 
            border-radius: 8px; 
            text-align: center; 
            border-left: 4px solid #3498db; 
        }
		.kpi-card.success { border-left-color: #27ae60 !important; }
		.kpi-card.warning { border-left-color: #f39c12 !important; }
		.kpi-card.danger { border-left-color: #e74c3c !important; }

		.kpi-card.success .kpi-value { color: #27ae60; }
		.kpi-card.warning .kpi-value { color: #f39c12; }
		.kpi-card.danger .kpi-value { color: #e74c3c; }
        .print-break { 
            page-break-before: always; 
        }
		/* Фикс для радарной диаграммы */
		#literacyRadarChart {
			max-height: 400px !important;
			width: 100% !important;
			margin: 0 auto;
		}

		/* Контейнер для графика */
		.chart-container {
			position: relative;
			height: 400px;
			min-height: 400px;
		}
    </style>
</head>
<body>
    <div class="header">
        <h1>?? Аналитический отчет по диагностической работе</h1>
        <h2>${appData.test.subject}, ${appData.test.class}</h2>
        <p><strong>Тема:</strong> ${appData.test.theme} | <strong>Дата:</strong> ${new Date(appData.test.testDate).toLocaleDateString()}</p>
        <p><strong>Тип работы:</strong> ${workTypes[appData.test.workType].name}</p>
    </div>
    
    <div class="section">
        <h3>?? Общая статистика</h3>
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-value">${avgScore.toFixed(1)}</div>
                <div class="stat-label">Средний балл</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">${successRate.toFixed(1)}%</div>
                <div class="stat-label">Успеваемость</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">${qualityRate.toFixed(1)}%</div>
                <div class="stat-label">Качество знаний</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">${completionRate.toFixed(1)}%</div>
                <div class="stat-label">Общее выполнение</div>
            </div>
        </div>
        
        <div class="kpi-grid">
            <div class="kpi-card">
                <div style="font-size: 1.4em; font-weight: bold; color: #2c3e50;">${gradeCounts[5]}</div>
                <div style="color: #7f8c8d; font-size: 0.9em;">Оценка 5</div>
            </div>
            <div class="kpi-card">
                <div style="font-size: 1.4em; font-weight: bold; color: #2c3e50;">${gradeCounts[4]}</div>
                <div style="color: #7f8c8d; font-size: 0.9em;">Оценка 4</div>
            </div>
            <div class="kpi-card">
                <div style="font-size: 1.4em; font-weight: bold; color: #2c3e50;">${gradeCounts[3]}</div>
                <div style="color: #7f8c8d; font-size: 0.9em;">Оценка 3</div>
            </div>
            <div class="kpi-card">
                <div style="font-size: 1.4em; font-weight: bold; color: #2c3e50;">${gradeCounts[2]}</div>
                <div style="color: #7f8c8d; font-size: 0.9em;">Оценка 2</div>
            </div>
        </div>
    </div>
    
    <div class="section print-break">
        <h3>?? Таксономический анализ</h3>
        ${document.getElementById('taxonomyAnalysis').innerHTML}
    </div>
    
    <div class="section">
        <h3>?? Выводы и рекомендации</h3>
        ${document.getElementById('keyConclusions').innerHTML}
        ${document.getElementById('correctionPlan').innerHTML}
        ${document.getElementById('nextSteps').innerHTML}
    </div>

    <div class="section">
        <p style="text-align: center; color: #7f8c8d; font-size: 0.9em;">
            Отчет сгенерирован ${new Date().toLocaleDateString()} системой анализа образовательных результатов
        </p>
    </div>
</body>
</html>`;
        }

        // Функция для оптимизированной печати
        function printOptimizedReport() {
            const printWindow = window.open('', '_blank');
            const reportContent = generatePrintableReport();
            
            printWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>Аналитический отчет - ${appData.test.theme}</title>
                    <meta charset="UTF-8">
                    <style>
                        body { 
                            font-family: 'Arial', sans-serif; 
                            margin: 0; 
                            padding: 15mm; 
                            line-height: 1.4;
                            color: #333;
                            font-size: 12pt;
                        }
                        @page {
                            size: A4;
                            margin: 15mm;
                        }
                        .header { 
                            text-align: center; 
                            margin-bottom: 20px;
                            padding-bottom: 15px;
                            border-bottom: 2px solid #3498db;
                        }
                        .stats-grid { 
                            display: grid; 
                            grid-template-columns: repeat(2, 1fr); 
                            gap: 10px; 
                            margin: 15px 0; 
                        }
                        .stat-card { 
                            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                            color: white; 
                            padding: 15px; 
                            border-radius: 8px; 
                            text-align: center; 
                            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
                        }
                        .stat-value { 
                            font-size: 1.6em; 
                            font-weight: bold; 
                            margin: 8px 0; 
                        }
                        .stat-label { 
                            font-size: 0.8em; 
                            opacity: 0.9; 
                        }
                        .section { 
                            margin: 20px 0; 
                            page-break-inside: avoid;
                        }
                        table { 
                            width: 100%; 
                            border-collapse: collapse; 
                            margin: 10px 0;
                            font-size: 10pt;
                            page-break-inside: avoid;
                        }
                        th, td { 
                            border: 1px solid #ddd; 
                            padding: 8px; 
                            text-align: left; 
                        }
                        th { 
                            background-color: #34495e; 
                            color: white; 
                        }
                        .recommendation-card {
                            background: #e8f4fc;
                            padding: 12px;
                            margin: 8px 0;
                            border-radius: 6px;
                            border-left: 4px solid #3498db;
                        }
                        .no-print { display: none; }
                        .print-break { page-break-before: always; }
                        .small-text { font-size: 10pt; }
						/* Фикс для радарной диаграммы */
						#literacyRadarChart {
							max-height: 400px !important;
							width: 100% !important;
							margin: 0 auto;
						}

						/* Контейнер для графика */
						.chart-container {
							position: relative;
							height: 400px;
							min-height: 400px;
						}
                    </style>
                </head>
                <body>
                    ${reportContent}
                </body>
                </html>
            `);
            
            printWindow.document.close();
            
            setTimeout(() => {
                printWindow.print();
            }, 500);
        }
        
        // Генерация отчета для печати
        function generatePrintableReport() {
            const totalScores = appData.results.map(scores => scores.reduce((sum, score) => sum + score, 0));
            const grades = totalScores.map(score => calculateGrade(score));
            const avgScore = totalScores.reduce((sum, score) => sum + score, 0) / totalScores.length;
            const successRate = (grades.filter(grade => grade >= 3).length / grades.length * 100);
            const qualityRate = (grades.filter(grade => grade >= 4).length / grades.length * 100);
            const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0);
            const completionRate = (totalScores.reduce((sum, score) => sum + score, 0) / (maxPossible * totalScores.length)) * 100;
            
            const gradeCounts = {5: 0, 4: 0, 3: 0, 2: 0};
            grades.forEach(grade => gradeCounts[grade]++);
            
            const taskAnalysis = appData.tasks.map((task, index) => {
                const completion = calculateTaskCompletion(index);
                let zone = '';
                let zoneColor = '';
                if (completion >= 90) { zone = 'Отличная'; zoneColor = '#27ae60'; }
                else if (completion >= 60) { zone = 'Зеленая'; zoneColor = '#2ecc71'; }
                else if (completion >= 30) { zone = 'Желтая'; zoneColor = '#f39c12'; }
                else { zone = 'Красная'; zoneColor = '#e74c3c'; }
                
                return { task, index, completion, zone, zoneColor };
            });
            
            return `
                <div class="header">
                    <h1>Аналитический отчет по диагностической работе</h1>
                    <h2>${appData.test.subject}, ${appData.test.class}</h2>
                    <p><strong>Тема:</strong> ${appData.test.theme}</p>
                    <p><strong>Дата проведения:</strong> ${new Date(appData.test.testDate).toLocaleDateString()}</p>
                    <p><strong>Тип работы:</strong> ${workTypes[appData.test.workType].name}</p>
                </div>

                <div class="section">
                    <h3>?? Общая статистика</h3>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-value">${avgScore.toFixed(1)}</div>
                            <div class="stat-label">Средний балл</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${successRate.toFixed(1)}%</div>
                            <div class="stat-label">Успеваемость</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${qualityRate.toFixed(1)}%</div>
                            <div class="stat-label">Качество знаний</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${completionRate.toFixed(1)}%</div>
                            <div class="stat-label">Общее выполнение</div>
                        </div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin: 15px 0;">
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 5px; text-align: center; border-left: 3px solid #27ae60;">
                            <div style="font-size: 1.2em; font-weight: bold; color: #2c3e50;">${gradeCounts[5]}</div>
                            <div style="color: #7f8c8d; font-size: 0.8em;">Оценка 5</div>
                        </div>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 5px; text-align: center; border-left: 3px solid #2ecc71;">
                            <div style="font-size: 1.2em; font-weight: bold; color: #2c3e50;">${gradeCounts[4]}</div>
                            <div style="color: #7f8c8d; font-size: 0.8em;">Оценка 4</div>
                        </div>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 5px; text-align: center; border-left: 3px solid #f39c12;">
                            <div style="font-size: 1.2em; font-weight: bold; color: #2c3e50;">${gradeCounts[3]}</div>
                            <div style="color: #7f8c8d; font-size: 0.8em;">Оценка 3</div>
                        </div>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 5px; text-align: center; border-left: 3px solid #e74c3c;">
                            <div style="font-size: 1.2em; font-weight: bold; color: #2c3e50;">${gradeCounts[2]}</div>
                            <div style="color: #7f8c8d; font-size: 0.8em;">Оценка 2</div>
                        </div>
                    </div>
                </div>

                <div class="section print-break">
                    <h3>?? Анализ выполнения заданий</h3>
                    <table>
                        <thead>
                            <tr>
                                <th>Задание</th>
                                <th>Уровень</th>
                                <th>% выполнения</th>
                                <th>Зона</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${taskAnalysis.map(item => `
                                <tr>
                                    <td>${item.index + 1}. ${item.task.type}</td>
                                    <td>${item.task.level}. ${complexityLevels[item.task.level].name}</td>
                                    <td>${item.completion.toFixed(1)}%</td>
                                    <td style="color: ${item.zoneColor}; font-weight: bold;">${item.zone}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>

                <div class="section">
                    <h3>?? Ключевые выводы и рекомендации</h3>
                    <div class="recommendation-card">
                        ${generateKeyConclusionsText()}
                    </div>
                </div>

                <div class="section small-text">
                    <p><em>Отчет сгенерирован ${new Date().toLocaleDateString()} системой анализа образовательных результатов</em></p>
                </div>
            `;
        }
		
		// Добавляем функцию для анализа итоговой работы
		function updateFinalAnalysis() {
			let html = '<h3 class="section-title">?? Комплексный педагогический анализ</h3>';
			
			const totalScores = appData.results.map(scores => scores.reduce((sum, score) => sum + score, 0));
			const grades = totalScores.map(score => calculateGrade(score));
			const avgScore = totalScores.reduce((sum, score) => sum + score, 0) / totalScores.length;
			const successRate = (grades.filter(grade => grade >= 3).length / grades.length * 100);
			const qualityRate = (grades.filter(grade => grade >= 4).length / grades.length * 100);
			
			// Анализ динамики (если есть исторические данные)
			const history = JSON.parse(localStorage.getItem('workHistory') || '[]')
				.filter(item => item.data.test.subject === appData.test.subject && 
							   item.data.test.class === appData.test.class)
				.sort((a, b) => new Date(a.data.test.testDate) - new Date(b.data.test.testDate));
			
			html += `
				<div class="stats-grid">
					<div class="stat-card">
						<div class="stat-value">${avgScore.toFixed(1)}</div>
						<div class="stat-label">Средний балл</div>
					</div>
					<div class="stat-card">
						<div class="stat-value">${successRate.toFixed(1)}%</div>
						<div class="stat-label">Успеваемость</div>
					</div>
					<div class="stat-card">
						<div class="stat-value">${qualityRate.toFixed(1)}%</div>
						<div class="stat-label">Качество знаний</div>
					</div>
					<div class="stat-card">
						<div class="stat-value">${calculateSou().toFixed(1)}%</div>
						<div class="stat-label">СОУ</div>
					</div>
				</div>
			`;
			
			// Анализ динамики, если есть история
			if (history.length > 1) {
				const currentSummary = generateWorkSummary();
				const firstSummary = history[0].summary;
				
				html += `
					<h4>?? Динамика за период</h4>
					<div class="comparative-grid">
						<div class="comparative-card">
							<h5>Средний балл</h5>
							<div class="comparative-value ${currentSummary.avgScore > firstSummary.avgScore ? 'positive' : 'negative'}">
								${currentSummary.avgScore.toFixed(1)} 
								<span class="trend">${currentSummary.avgScore > firstSummary.avgScore ? '?' : '?'}</span>
							</div>
							<div class="comparative-previous">Начало: ${firstSummary.avgScore.toFixed(1)}</div>
						</div>
						<div class="comparative-card">
							<h5>Успеваемость</h5>
							<div class="comparative-value ${currentSummary.successRate > firstSummary.successRate ? 'positive' : 'negative'}">
								${currentSummary.successRate.toFixed(1)}%
								<span class="trend">${currentSummary.successRate > firstSummary.successRate ? '?' : '?'}</span>
							</div>
							<div class="comparative-previous">Начало: ${firstSummary.successRate.toFixed(1)}%</div>
						</div>
						<div class="comparative-card">
							<h5>Качество знаний</h5>
							<div class="comparative-value ${currentSummary.qualityRate > firstSummary.qualityRate ? 'positive' : 'negative'}">
								${currentSummary.qualityRate.toFixed(1)}%
								<span class="trend">${currentSummary.qualityRate > firstSummary.qualityRate ? '?' : '?'}</span>
							</div>
							<div class="comparative-previous">Начало: ${firstSummary.qualityRate.toFixed(1)}%</div>
						</div>
					</div>
				`;
			}
			
			// Анализ по уровням усвоения
			html += `
				<h4>?? Уровень усвоения материала</h4>
				<div class="kpi-grid">
					<div class="kpi-card" style="border-left-color: #27ae60">
						<div class="kpi-value">${countStudentsByLevel('high')}</div>
						<div class="kpi-label">Высокий уровень</div>
						<small>Усвоили 80-100%</small>
					</div>
					<div class="kpi-card" style="border-left-color: #3498db">
						<div class="kpi-value">${countStudentsByLevel('medium')}</div>
						<div class="kpi-label">Средний уровень</div>
						<small>Усвоили 60-79%</small>
					</div>
					<div class="kpi-card" style="border-left-color: #f39c12">
						<div class="kpi-value">${countStudentsByLevel('low')}</div>
						<div class="kpi-label">Базовый уровень</div>
						<small>Усвоили 40-59%</small>
					</div>
					<div class="kpi-card" style="border-left-color: #e74c3c">
						<div class="kpi-value">${countStudentsByLevel('critical')}</div>
						<div class="kpi-label">Критический уровень</div>
						<small>Усвоили менее 40%</small>
					</div>
				</div>
			`;
			
			// Анализ ключевых тем
			html += generateKeyTopicsAnalysis();
			
			// Педагогические выводы
			html += generatePedagogicalConclusions();
			
			document.getElementById('specializedAnalysis').innerHTML = html;
		}

		// Функция для подсчета учащихся по уровням усвоения
		function countStudentsByLevel(level) {
			const totalScores = appData.results.map(scores => scores.reduce((sum, score) => sum + score, 0));
			const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0);
			
			const percentages = totalScores.map(score => (score / maxPossible) * 100);
			
			switch(level) {
				case 'high':
					return percentages.filter(p => p >= 80).length;
				case 'medium':
					return percentages.filter(p => p >= 60 && p < 80).length;
				case 'low':
					return percentages.filter(p => p >= 40 && p < 60).length;
				case 'critical':
					return percentages.filter(p => p < 40).length;
				default:
					return 0;
			}
		}

		// Анализ ключевых тем
		function generateKeyTopicsAnalysis() {
			let html = '<h4>?? Анализ ключевых тем</h4>';
			
			// Группируем задания по темам (по проверяемым элементам содержания)
			const topicStats = {};
			
			appData.tasks.forEach((task, taskIndex) => {
				const topic = task.knowledge || 'Общая тема';
				if (!topicStats[topic]) {
					topicStats[topic] = {
						completion: 0,
						count: 0,
						tasks: []
					};
				}
				
				const completion = calculateTaskCompletion(taskIndex);
				topicStats[topic].completion += completion;
				topicStats[topic].count++;
				topicStats[topic].tasks.push(taskIndex + 1);
			});
			
			// Вычисляем среднее выполнение по темам
			Object.keys(topicStats).forEach(topic => {
				topicStats[topic].completion = topicStats[topic].completion / topicStats[topic].count;
			});
			
			// Сортируем темы по выполнению
			const sortedTopics = Object.entries(topicStats)
				.sort(([,a], [,b]) => a.completion - b.completion);
			
			html += '<div class="table-container"><table>';
			html += '<thead><tr><th>Тема</th><th>Задания</th><th>% выполнения</th><th>Статус</th></tr></thead><tbody>';
			
			sortedTopics.forEach(([topic, stats]) => {
				let status = '';
				let statusIcon = '';
				
				if (stats.completion >= 80) {
					status = 'Усвоена';
					statusIcon = '??';
				} else if (stats.completion >= 60) {
					status = 'Частично усвоена';
					statusIcon = '??';
				} else if (stats.completion >= 40) {
					status = 'Требует доработки';
					statusIcon = '??';
				} else {
					status = 'Проблемная';
					statusIcon = '??';
				}
				
				html += `
					<tr>
						<td>${topic}</td>
						<td>${stats.tasks.join(', ')}</td>
						<td>${stats.completion.toFixed(1)}%</td>
						<td>${statusIcon} ${status}</td>
					</tr>
				`;
			});
			
			html += '</tbody></table></div>';
			
			return html;
		}

		// Педагогические выводы
		function generatePedagogicalConclusions() {
			const totalScores = appData.results.map(scores => scores.reduce((sum, score) => sum + score, 0));
			const avgScore = totalScores.reduce((sum, score) => sum + score, 0) / totalScores.length;
			const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0);
			const percentage = (avgScore / maxPossible) * 100;
			
			let html = '<h4>?? Педагогические выводы</h4>';
			html += '<div class="recommendation-card">';
			
			if (percentage >= 80) {
				html += '<strong>? Высокая эффективность обучения</strong><br>';
				html += 'Результаты свидетельствуют о высоком уровне усвоения учебного материала. ';
				html += '<strong>Сильные стороны:</strong><br>';
				html += '• Систематичность в изучении материала<br>';
				html += '• Эффективность применяемых методик<br>';
				html += '• Хорошая мотивация учащихся<br>';
				html += '<strong>Рекомендации:</strong><br>';
				html += '• Продолжить использование успешных практик<br>';
				html += '• Внедрять элементы углубленного изучения<br>';
				html += '• Развивать исследовательские навыки<br>';
			} else if (percentage >= 60) {
				html += '<strong>?? Стабильные результаты обучения</strong><br>';
				html += 'Учебный материал усвоен на базовом уровне. ';
				html += '<strong>Наблюдения:</strong><br>';
				html += '• Необходима дифференциация заданий<br>';
				html += '• Требуется активизация слабоуспевающих<br>';
				html += '• Нужно разнообразить формы работы<br>';
				html += '<strong>Рекомендации:</strong><br>';
				html += '• Внедрение групповых форм работы<br>';
				html += '• Индивидуализация обучения<br>';
				html += '• Использование интерактивных методов<br>';
			} else if (percentage >= 40) {
				html += '<strong>?? Требуется коррекция учебного процесса</strong><br>';
				html += 'Обнаружены значительные пробелы в знаниях. ';
				html += '<strong>Проблемы:</strong><br>';
				html += '• Недостаточное усвоение базовых понятий<br>';
				html += '• Низкая учебная мотивация<br>';
				html += '• Неэффективность текущих методик<br>';
				html += '<strong>Рекомендации:</strong><br>';
				html += '• Пересмотр подходов к объяснению материала<br>';
				html += '• Усиление индивидуальной работы<br>';
				html += '• Вовлечение родителей в учебный процесс<br>';
			} else {
				html += '<strong>?? Критическая ситуация в обучении</strong><br>';
				html += 'Требуется срочное вмешательство. ';
				html += '<strong>Причины:</strong><br>';
				html += '• Системные пробелы в знаниях<br>';
				html += '• Отсутствие учебной дисциплины<br>';
				html += '• Несоответствие методик уровню класса<br>';
				html += '<strong>Срочные меры:</strong><br>';
				html += '• Разработка индивидуальных программ<br>';
				html += '• Проведение дополнительных занятий<br>';
				html += '• Консультация с методистом<br>';
			}
			
			html += '</div>';
			
			// Рекомендации по планированию
			html += `
				<div class="recommendation-card">
					<h5>?? Рекомендации для планирования</h5>
					<ul>
						<li>Учесть результаты при составлении рабочей программы на следующий год</li>
						<li>Скорректировать календарно-тематическое планирование</li>
						<li>Запланировать повторение проблемных тем в начале следующего года</li>
						<li>Разработать систему мониторинга для слабоуспевающих учащихся</li>
						<li>Внести изменения в систему контроля знаний</li>
					</ul>
				</div>
			`;
			
			return html;
		}

		// Добавьте эту функцию в ваш JavaScript код, например перед updateVisualization()
		function debugCharts() {
			console.log('=== ОТЛАДКА ГРАФИКОВ ===');
			console.log('Chart.js доступен:', typeof Chart !== 'undefined');
			console.log('Chart версия:', Chart ? Chart.version : 'не доступен');
			
			console.log('\nCanvas элементы:');
			const canvasIds = ['gradesChart', 'solvabilityChart', 'complexityChart'];
			canvasIds.forEach(id => {
				const canvas = document.getElementById(id);
				console.log(`- ${id}:`, canvas);
				if (canvas) {
					console.log(`  Размер: ${canvas.width}x${canvas.height}`);
					console.log(`  Стиль:`, canvas.style.cssText);
				}
			});
			
			console.log('\nРодительские элементы:');
			canvasIds.forEach(id => {
				const canvas = document.getElementById(id);
				if (canvas) {
					console.log(`- ${id} родитель:`, canvas.parentElement);
					console.log(`  Видимый:`, canvas.parentElement ? canvas.parentElement.offsetParent !== null : 'нет родителя');
				}
			});
			
			console.log('\nДанные приложения:');
			console.log('- Результаты:', appData.results ? appData.results.length : 'нет');
			console.log('- Задания:', appData.tasks ? appData.tasks.length : 'нет');
			console.log('- Студенты:', appData.students ? appData.students.length : 'нет');
			
			console.log('\ncomplexityLevels:', complexityLevels);
			
			console.log('\nТекущие экземпляры графиков:');
			const chartInstances = [
				'gradesChartInstance',
				'complexityChartInstance',
				'solvabilityChartInstance'
			];
			chartInstances.forEach(name => {
				console.log(`- ${name}:`, window[name]);
			});
			
			// Проверяем данные для первого задания
			if (appData.results && appData.results.length > 0 && appData.tasks && appData.tasks.length > 0) {
				console.log('\nПример данных первого задания:');
				const firstTaskScores = appData.results.map(student => student[0] || 0);
				console.log('- Оценки:', firstTaskScores);
				console.log('- Макс балл:', appData.tasks[0].maxScore);
			}
		}

		// Также добавьте эту функцию для простой проверки
		function testChart() {
			console.log('=== ТЕСТОВЫЙ ГРАФИК ===');
			
			// Создаем простой тестовый график
			const testCanvas = document.createElement('canvas');
			testCanvas.id = 'testChart';
			testCanvas.style.width = '400px';
			testCanvas.style.height = '300px';
			document.body.appendChild(testCanvas);
			
			const ctx = testCanvas.getContext('2d');
			const testChart = new Chart(ctx, {
				type: 'bar',
				data: {
					labels: ['Тест 1', 'Тест 2', 'Тест 3'],
					datasets: [{
						label: 'Тестовые данные',
						data: [10, 20, 30],
						backgroundColor: ['#ff6384', '#36a2eb', '#cc65fe']
					}]
				}
			});
			
			console.log('Тестовый график создан:', testChart);
			console.log('Если этот график отображается, значит Chart.js работает');
			
			// Удаляем через 5 секунд
			setTimeout(() => {
				testChart.destroy();
				testCanvas.remove();
				console.log('Тестовый график удален');
			}, 5000);
		}

		// Функция для проверки отрисовки конкретного графика
		function drawSimpleGradesChart() {
			console.log('=== ПРОСТОЙ ГРАФИК ОЦЕНОК ===');
			
			const canvas = document.getElementById('gradesChart');
			if (!canvas) {
				console.error('Canvas gradesChart не найден!');
				// Проверим, где он должен быть
				const container = document.querySelector('[id*="grade"], [class*="grade"]');
				console.log('Контейнер для графика:', container);
				return;
			}
			
			console.log('Canvas найден, создаем график...');
			
			// Простые тестовые данные
			const testData = {
				labels: ['5', '4', '3', '2'],
				datasets: [{
					data: [5, 10, 7, 3],
					backgroundColor: ['#27ae60', '#2ecc71', '#f39c12', '#e74c3c']
				}]
			};
			
			const ctx = canvas.getContext('2d');
			try {
				window.gradesChartInstance = new Chart(ctx, {
					type: 'pie',
					data: testData,
					options: {
						responsive: true,
						plugins: {
							title: {
								display: true,
								text: 'Тестовый график'
							}
						}
					}
				});
				console.log('Тестовый график создан успешно!');
			} catch (error) {
				console.error('Ошибка создания графика:', error);
			}
		}

		// Функция для генерации специализированного отчета для итоговой работы
		function generateFinalSpecializedReport() {
			updateFinalAnalysis();
			const analysisContent = document.getElementById('specializedAnalysis').innerHTML;
			
			return `
				<h3>?? Итоговый педагогический анализ</h3>
				<p>Комплексный анализ образовательных результатов за учебный период с педагогическими выводами и рекомендациями.</p>
				
				<div class="stats-grid">
					<div class="stat-card">
						<div class="stat-value">${calculateAverageScore().toFixed(1)}</div>
						<div class="stat-label">Средний балл</div>
					</div>
					<div class="stat-card">
						<div class="stat-value">${calculateSuccessRate().toFixed(1)}%</div>
						<div class="stat-label">Успеваемость</div>
					</div>
					<div class="stat-card">
						<div class="stat-value">${calculateQualityRate().toFixed(1)}%</div>
						<div class="stat-label">Качество</div>
					</div>
					<div class="stat-card">
						<div class="stat-value">${calculateSou().toFixed(1)}%</div>
						<div class="stat-label">СОУ</div>
					</div>
				</div>
				
				${analysisContent}
				
				<div class="recommendation-card" style="margin-top: 20px;">
					<h4>?? Перспективы развития</h4>
					<p>На основе анализа результатов рекомендуется:</p>
					<ul>
						<li>Скорректировать учебную программу с учетом выявленных трудностей</li>
						<li>Внедрить систему регулярного мониторинга образовательных результатов</li>
						<li>Разработать индивидуальные образовательные маршруты для учащихся</li>
						<li>Повысить квалификацию в области современных образовательных технологий</li>
						<li>Активизировать работу с родителями по сопровождению обучения</li>
					</ul>
				</div>
			`;
		}
		
		
        // Текстовая версия ключевых выводов для печати
		function generateKeyConclusionsText() {
			const totalScores = appData.results.map(scores => scores.reduce((sum, score) => sum + score, 0));
			const grades = totalScores.map(score => calculateGrade(score));
			const avgScore = totalScores.reduce((sum, score) => sum + score, 0) / totalScores.length;
			const successRate = (grades.filter(grade => grade >= 3).length / grades.length * 100);
			
			let conclusions = '';
			
			if (appData.test.workType === 'psychology') {
				const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0);
				const avgPercentage = (totalScores.reduce((sum, score) => sum + score, 0) / (maxPossible * totalScores.length)) * 100;
				
				const levels = appData.test.psychologySettings?.levels || [];
				let dominantLevel = 'Не определен';
				
				for (let level of levels) {
					const count = totalScores.filter(score => {
						const percentage = (score / maxPossible) * 100;
						return percentage >= level.min && percentage <= level.max;
					}).length;
					
					if (count >= totalScores.length * 0.4) { // Если 40% и более в одном уровне
						dominantLevel = level.name;
						break;
					}
				}
				
				conclusions = `
					<strong>Психологический профиль группы:</strong> ${dominantLevel} уровень развития<br>
					<strong>Средний показатель:</strong> ${avgPercentage.toFixed(1)}%<br>
					<strong>Распределение:</strong> ${grades.filter(g => g === 5).length} чел. - высокий уровень, 
					${grades.filter(g => g === 4).length} чел. - выше среднего,
					${grades.filter(g => g === 3).length} чел. - средний уровень,
					${grades.filter(g => g <= 2).length} чел. - низкий уровень<br>
				`;
				
				// Добавляем особенности психологической диагностики
				if (appData.test.psychologySettings?.dimensions) {
					const dimensions = appData.test.psychologySettings.dimensions;
					const weakestDimension = findWeakestDimension();
					if (weakestDimension) {
						conclusions += `<strong>Требует внимания:</strong> ${weakestDimension.name} (${weakestDimension.percentage.toFixed(1)}%)<br>`;
					}
				}
			} else {
				// Старая логика для других типов работ
				if (successRate >= 80) {
					conclusions = '<strong>? Высокий уровень усвоения материала</strong><br>';
					conclusions += 'Большинство учащихся успешно справились с работой. ';
				} else if (successRate >= 60) {
					conclusions = '<strong>?? Средний уровень усвоения материала</strong><br>';
					conclusions += 'Требуется коррекционная работа с отдельными группами учащихся. ';
				} else {
					conclusions = '<strong>?? Низкий уровень усвоения материала</strong><br>';
					conclusions += 'Необходимо пересмотреть методы преподавания и провести повторение. ';
				}
				
				const difficultTasks = [];
				appData.tasks.forEach((task, index) => {
					const completion = calculateTaskCompletion(index);
					if (completion < 50) {
						difficultTasks.push({ task: index + 1, completion: completion, type: task.type });
					}
				});
				
				if (difficultTasks.length > 0) {
					conclusions += `<br><strong>Проблемные задания:</strong> `;
					conclusions += difficultTasks.map(t => `№${t.task} (${t.completion.toFixed(1)}%)`).join(', ');
				}
				
				if (appData.errors.length > 0) {
					const topErrorType = getTopErrorType();
					conclusions += `<br><strong>Преобладающие ошибки:</strong> ${errorTypes[topErrorType].name}`;
				}
			}
			
			return conclusions;
		}

		function findWeakestDimension() {
			if (!appData.test.psychologySettings?.dimensions) return null;
			
			const dimensions = appData.test.psychologySettings.dimensions;
			let weakest = null;
			let minPercentage = 100;
			
			dimensions.forEach(dimension => {
				const dimensionTasks = appData.tasks.filter(task => task.dimension === dimension.id);
				if (dimensionTasks.length === 0) return;
				
				let totalScore = 0;
				let totalMax = 0;
				
				dimensionTasks.forEach(task => {
					const taskIndex = appData.tasks.indexOf(task);
					const maxScore = task.maxScore;
					const actualScores = appData.results.map(student => student[taskIndex] || 0);
					const actualTotal = actualScores.reduce((sum, score) => sum + score, 0);
					
					totalScore += actualTotal;
					totalMax += maxScore * appData.results.length;
				});
				
				const percentage = totalMax > 0 ? (totalScore / totalMax) * 100 : 0;
				if (percentage < minPercentage) {
					minPercentage = percentage;
					weakest = { name: dimension.name, percentage: percentage };
				}
			});
			
			return weakest;
		}
        function updateReportPreview() {
            const totalScores = appData.results.map(scores => scores.reduce((sum, score) => sum + score, 0));
            const grades = totalScores.map(score => calculateGrade(score));
            const avgScore = totalScores.reduce((sum, score) => sum + score, 0) / totalScores.length;
            
            document.getElementById('reportPreview').innerHTML = `
                <div class="recommendation-card">
                    <h4>Предварительный просмотр отчета</h4>
                    <p><strong>Предмет:</strong> ${appData.test.subject || 'Не указан'}</p>
                    <p><strong>Класс:</strong> ${appData.test.class || 'Не указан'}</p>
                    <p><strong>Тема:</strong> ${appData.test.theme || 'Не указана'}</p>
                    <p><strong>Тип работы:</strong> ${workTypes[appData.test.workType].name}</p>
                    <p><strong>Учащихся:</strong> ${appData.students.length} из ${appData.test.presentStudents}</p>
                    <p><strong>Заданий:</strong> ${appData.tasks.length}</p>
                    <p><strong>Средний балл:</strong> ${totalScores.length > 0 ? avgScore.toFixed(1) : 'Нет данных'}</p>
                </div>
            `;
        }
        
        // Специализированный отчет


		// Улучшенная функция для специализированного отчета ВПР
		function generateVPRSpecializedReport() {
			updateVPRAnalysis();
			
			const totalScores = appData.results.map(scores => scores.reduce((sum, score) => sum + score, 0));
			const grades = totalScores.map(score => calculateGrade(score));
			const successRate = (grades.filter(grade => grade >= 3).length / grades.length * 100);
			const qualityRate = (grades.filter(grade => grade >= 4).length / grades.length * 100);
			
			// Анализ выполнения критериев ВПР
			const vprCriteriaAnalysis = analyzeVPRCriteria();
			
			return `
				<h3>?? Комплексный анализ Всероссийской проверочной работы</h3>
				<p>Детальный анализ результатов ВПР с оценкой сформированности ключевых компетенций и рекомендациями по подготовке.</p>
				
				<div class="stats-grid">
					<div class="stat-card">
						<div class="stat-value">${calculateAverageScore().toFixed(1)}</div>
						<div class="stat-label">Средний балл</div>
					</div>
					<div class="stat-card">
						<div class="stat-value">${successRate.toFixed(1)}%</div>
						<div class="stat-label">Успеваемость</div>
					</div>
					<div class="stat-card">
						<div class="stat-value">${qualityRate.toFixed(1)}%</div>
						<div class="stat-label">Качество</div>
					</div>
					<div class="stat-card">
						<div class="stat-value">${appData.students.length}</div>
						<div class="stat-label">Учащихся</div>
					</div>
				</div>
				
				${vprCriteriaAnalysis}
				
				<div class="section-title">?? Оценка сформированности компетенций</div>
				${document.getElementById('specializedAnalysis').innerHTML}
				
				<div class="recommendation-card" style="margin-top: 20px;">
					<h4>?? Итоговые рекомендации</h4>
					<p>На основе анализа результатов ВПР рекомендуется:</p>
					<ul>
						<li>Включить в учебный план регулярную работу с заданиями ВПР</li>
						<li>Разработать индивидуальные траектории для учащихся с низкими результатами</li>
						<li>Провести методическую работу по проблемным компетенциям</li>
						<li>Организовать систему внутреннего мониторинга подготовки к ВПР</li>
						<li>Обеспечить преемственность подготовки между классами</li>
					</ul>
				</div>
			`;
		}

		// Анализ выполнения критериев ВПР
		function analyzeVPRCriteria() {
			const totalScores = appData.results.map(scores => scores.reduce((sum, score) => sum + score, 0));
			const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0);
			const avgPercentage = (totalScores.reduce((sum, score) => sum + score, 0) / (maxPossible * totalScores.length)) * 100;
			
			let html = '<div class="recommendation-card">';
			html += '<h4>?? Выполнение критериев ВПР</h4>';
			
			if (avgPercentage >= 80) {
				html += '<strong>? Высокий уровень подготовки</strong><br>';
				html += 'Класс демонстрирует отличную подготовку к ВПР. ';
				html += 'Результаты превышают среднероссийские показатели.';
			} else if (avgPercentage >= 60) {
				html += '<strong>?? Средний уровень подготовки</strong><br>';
				html += 'Класс соответствует базовым требованиям ВПР. ';
				html += 'Результаты на уровне среднероссийских показателей.';
			} else if (avgPercentage >= 40) {
				html += '<strong>?? Требуется усиление подготовки</strong><br>';
				html += 'Обнаружены пробелы в подготовке к ВПР. ';
				html += 'Необходима систематическая работа над компетенциями.';
			} else {
				html += '<strong>?? Критический уровень подготовки</strong><br>';
				html += 'Требуется срочное вмешательство в учебный процесс. ';
				html += 'Результаты ниже базовых требований ВПР.';
			}
			
			html += `<br><strong>Общий процент выполнения:</strong> ${avgPercentage.toFixed(1)}%`;
			html += '</div>';
			
			return html;
		}

		function generateLiteracySpecializedReport() {
			updateLiteracyAnalysis();
			
			const totalScores = appData.results.map(scores => scores.reduce((sum, score) => sum + score, 0));
			const avgScore = totalScores.reduce((sum, score) => sum + score, 0) / totalScores.length;
			const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0);
			const avgPercentage = (avgScore / maxPossible) * 100;
			
			// Анализ общего уровня функциональной грамотности
			const overallLevel = analyzeOverallLiteracyLevel(avgPercentage);
			
			return `
				<h3>?? Комплексный анализ функциональной грамотности</h3>
				<p>Оценка уровня сформированности ключевых компетенций, необходимых для успешной жизни в современном обществе.</p>
				
				<div class="stats-grid">
					<div class="stat-card">
						<div class="stat-value">${avgScore.toFixed(1)}</div>
						<div class="stat-label">Средний балл</div>
					</div>
					<div class="stat-card">
						<div class="stat-value">${avgPercentage.toFixed(1)}%</div>
						<div class="stat-label">Общее выполнение</div>
					</div>
					<div class="stat-card">
						<div class="stat-value">${overallLevel.level}</div>
						<div class="stat-label">Уровень грамотности</div>
					</div>
					<div class="stat-card">
						<div class="stat-value">${appData.tasks.length}</div>
						<div class="stat-label">Компетенций оценено</div>
					</div>
				</div>
				
				<div class="recommendation-card">
					<h4>?? Общая характеристика уровня функциональной грамотности</h4>
					<p><strong>${overallLevel.title}</strong></p>
					<p>${overallLevel.description}</p>
					<p><strong>Интерпретация:</strong> ${overallLevel.interpretation}</p>
				</div>
				
				<div class="section-title">?? Детальный анализ компетенций</div>
				${document.getElementById('specializedAnalysis').innerHTML}
				
				<div class="recommendation-card" style="margin-top: 20px;">
					<h4>?? Программа развития функциональной грамотности</h4>
					<p>На основе проведенного анализа рекомендуется:</p>
					<ul>
						<li>Разработать индивидуальные траектории развития для учащихся</li>
						<li>Внедрить систему регулярного мониторинга функциональной грамотности</li>
						<li>Организовать методическое сопровождение педагогов</li>
						<li>Создать банк заданий для развития различных видов грамотности</li>
						<li>Обеспечить преемственность в формировании компетенций между классами</li>
					</ul>
				</div>
			`;
		}
		
		// ==================== ЭКСПОРТ/ИМПОРТ ДАННЫХ ====================
		
		// 1. Экспорт данных в файл JSON
		function exportToFile() {
			try {
				// Создаем объект для экспорта с правильной структурой
				const dataToExport = {
					appData: appData,
					timestamp: new Date().toISOString(),
					version: '1.0',
					metadata: {
						exportedBy: 'Система анализа образовательных результатов',
						exportedAt: new Date().toLocaleString('ru-RU'),
						subject: appData.test.subject,
						class: appData.test.class,
						workType: appData.test.workType,
						studentCount: appData.students.length,
						taskCount: appData.tasks.length,
						theme: appData.test.theme
					}
				};
				
				const dataStr = JSON.stringify(dataToExport, null, 2);
				const blob = new Blob([dataStr], { type: 'application/json' });
				const url = URL.createObjectURL(blob);
				
				const a = document.createElement('a');
				a.href = url;
				a.download = generateExportFilename();
				a.click();
				
				URL.revokeObjectURL(url);
				
				showNotification('Данные успешно экспортированы в файл', 'success');
				
				// Сохраняем информацию о последнем экспорте
				saveExportHistory();
				
			} catch (error) {
				console.error('Ошибка при экспорте:', error);
				showNotification('Ошибка при экспорте данных: ' + error.message, 'error');
			}
		}

		// ТЕСТОВАЯ ФУНКЦИЯ для создания тестового файла
		function createTestImportFile() {
			const testData = {
				test: {
					subject: "Математика",
					class: "5А",
					testDate: new Date().toISOString().split('T')[0],
					theme: "Тестовая работа",
					goals: "Тестовые цели",
					workType: "current",
					workFormat: "mixed",
					timeLimit: 45,
					totalStudents: 25,
					presentStudents: 23,
					absentReason: "",
					criteria: {
						5: { min: 18, max: 20 },
						4: { min: 15, max: 17 },
						3: { min: 10, max: 14 },
						2: { min: 0, max: 9 }
					}
				},
				tasks: [
					{ type: "Тестовое задание 1", maxScore: 2, level: 1, knowledge: "тест" },
					{ type: "Тестовое задание 2", maxScore: 3, level: 2, knowledge: "тест" }
				],
				students: ["Иванов А.", "Петрова М.", "Сидоров Д."],
				results: [
					[2, 3],
					[1, 2],
					[2, 3]
				],
				errors: [],
				_metadata: {
					exportedAt: new Date().toLocaleString('ru-RU'),
					system: 'Система анализа образовательных результатов',
					version: '1.0'
				}
			};
			
			const dataStr = JSON.stringify(testData, null, 2);
			
			// Добавляем BOM для правильной кодировки UTF-8
			const BOM = '\uFEFF';
			const blob = new Blob([BOM + dataStr], { 
				type: 'application/json;charset=utf-8' 
			});
			
			const url = URL.createObjectURL(blob);
			
			const a = document.createElement('a');
			a.href = url;
			a.download = 'тестовый_файл_для_импорта.json';
			document.body.appendChild(a);
			a.click();
			document.body.removeChild(a);
			
			URL.revokeObjectURL(url);
			
			showNotification('Тестовый файл создан', 'success');
		}

		// ЗАМЕНИТЕ ИНИЦИАЛИЗАЦИЮ
		//document.addEventListener('DOMContentLoaded', function() {
		//	setTimeout(() => {
		//		addFixedTransferButtons();
		//	}, 1000);
		//});

		// 2. Генерация имени файла
		function generateExportFilename() {
			const date = new Date().toISOString().split('T')[0];
			const time = new Date().toTimeString().split(' ')[0].replace(/:/g, '-');
			const subject = appData.test.subject || 'предмет';
			const className = appData.test.class || 'класс';
			
			return `анализ_${subject}_${className}_${date}_${time}.json`;
		}

		// 3. Импорт данных из файла
		function importFromFile() {
			const input = document.createElement('input');
			input.type = 'file';
			input.accept = '.json,.txt,application/json';
			
			input.onchange = function(event) {
				const file = event.target.files[0];
				if (!file) return;
				
				// Показываем индикатор загрузки
				showNotification('Чтение файла...', 'info');
				
				const reader = new FileReader();
				
				reader.onload = function(e) {
					try {
						const content = e.target.result;
						console.log('Размер файла:', content.length, 'символов');
						
						const importedData = JSON.parse(content);
						console.log('Парсинг JSON успешен');
						
						// Валидация данных
						if (validateImportedData(importedData)) {
							console.log('Данные прошли валидацию');
							showImportConfirmationDialog(importedData);
						} else {
							console.error('Данные не прошли валидацию');
							
							// Альтернативный метод валидации
							if (alternativeValidate(importedData)) {
								console.log('Данные прошли альтернативную валидацию');
								showImportConfirmationDialog(importedData);
								return;
							}
							
							// Показываем подробную информацию об ошибке
							let errorHtml = `
								<h3>? Ошибка валидации данных</h3>
								<p>Файл содержит некорректные данные. Проверьте структуру файла.</p>
								
								<div style="background: #f8d7da; padding: 15px; border-radius: 8px; margin: 15px 0;">
									<h4>Что можно сделать:</h4>
									<ol>
										<li>Убедитесь, что файл был экспортирован из этой системы</li>
										<li>Проверьте, что файл не был изменен вручную</li>
										<li>Попробуйте экспортировать данные снова</li>
										<li>Проверьте кодировку файла (должна быть UTF-8)</li>
									</ol>
								</div>
							`;
							
							// Показываем первые 1000 символов для диагностики
							errorHtml += `
								<div class="form-group">
									<h4>Первые 1000 символов файла:</h4>
									<div style="max-height: 200px; overflow-y: auto; background: #f8f9fa; padding: 10px; border-radius: 6px; font-family: monospace; font-size: 10px;">
										${content.substring(0, 1000).replace(/</g, '&lt;').replace(/>/g, '&gt;')}
									</div>
								</div>
							`;
							
							errorHtml += `
								<div style="margin-top: 20px;">
									<button class="btn btn-warning" onclick="tryForceImport('${content.replace(/\\/g, '\\\\').replace(/'/g, "\\'").substring(0, 5000)}')">
										Попробовать принудительный импорт
									</button>
									<button class="btn" onclick="hideModal()" style="margin-left: 10px;">Закрыть</button>
								</div>
							`;
							
							showModal('Ошибка импорта', errorHtml);
						}
					} catch (error) {
						console.error('Ошибка при чтении файла:', error);
						
						let errorMessage = `
							<h3>? Ошибка при чтении файла</h3>
							<p><strong>${error.name}:</strong> ${error.message}</p>
							
							<div style="background: #f8d7da; padding: 15px; border-radius: 8px; margin: 15px 0;">
								<h4>Возможные причины:</h4>
								<ul>
									<li>Файл поврежден</li>
									<li>Неверный формат файла (не JSON)</li>
									<li>Файл был изменен вручную</li>
									<li>Проблемы с кодировкой (должна быть UTF-8)</li>
								</ul>
							</div>
							
							<div class="form-group">
								<h4>Проверка формата файла:</h4>
								<div style="background: #f8f9fa; padding: 10px; border-radius: 6px; font-family: monospace; font-size: 10px;">
									${file.name}<br>
									Размер: ${file.size} байт<br>
									Тип: ${file.type || 'не определен'}
								</div>
							</div>
						`;
						
						errorMessage += `
							<div style="margin-top: 20px;">
								<button class="btn" onclick="hideModal()">Закрыть</button>
							</div>
						`;
						
						showModal('Ошибка импорта', errorMessage);
					}
				};
				
				reader.onerror = function(e) {
					console.error('Ошибка FileReader:', e);
					showNotification('Ошибка при чтении файла', 'error');
				};
				
				reader.readAsText(file, 'UTF-8');
			};
			
			input.click();
		}

		// АЛЬТЕРНАТИВНАЯ ВАЛИДАЦИЯ (более мягкая)
		function alternativeValidate(data) {
			try {
				// Проверяем различные возможные структуры
				if (!data) return false;
				
				// Вариант 1: новый формат с appData
				if (data.appData && typeof data.appData === 'object') {
					const appData = data.appData;
					if (appData.test && appData.tasks && appData.students && appData.results) {
						return true;
					}
				}
				
				// Вариант 2: старый формат без appData
				if (data.test && data.tasks && data.students && data.results) {
					return true;
				}
				
				// Вариант 3: минимальная структура
				if (Array.isArray(data.tasks) && Array.isArray(data.students)) {
					return true;
				}
				
				return false;
			} catch (error) {
				return false;
			}
		}

		// ФУНКЦИЯ ПРИНУДИТЕЛЬНОГО ИМПОРТА
		function tryForceImport(content) {
			try {
				// Пробуем очистить данные от возможных проблем
				let cleanedContent = content;
				
				// Удаляем BOM (байтовую метку порядка)
				if (cleanedContent.charCodeAt(0) === 0xFEFF) {
					cleanedContent = cleanedContent.substring(1);
				}
				
				// Пробуем разные методы парсинга
				let importedData;
				
				try {
					// Метод 1: обычный JSON.parse
					importedData = JSON.parse(cleanedContent);
				} catch (e1) {
					try {
						// Метод 2: пытаемся исправить возможные проблемы
						cleanedContent = cleanedContent
							.replace(/\r\n/g, '\n') // Нормализуем переводы строк
							.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, ''); // Удаляем управляющие символы
						
						importedData = JSON.parse(cleanedContent);
					} catch (e2) {
						try {
							// Метод 3: пытаемся найти JSON в тексте
							const jsonMatch = cleanedContent.match(/\{.*\}/s);
							if (jsonMatch) {
								importedData = JSON.parse(jsonMatch[0]);
							} else {
								throw new Error('JSON не найден');
							}
						} catch (e3) {
							showNotification('Не удалось распознать данные', 'error');
							return;
						}
					}
				}
				
				// Показываем диалог импорта
				hideModal();
				setTimeout(() => {
					showImportConfirmationDialog(importedData);
				}, 100);
				
			} catch (error) {
				showNotification('Ошибка при принудительном импорте: ' + error.message, 'error');
			}
		}


		// УПРОЩЕННАЯ ФУНКЦИЯ ЭКСПОРТА/ИМПОРТА (простой вариант)
		function simpleImport() {
			const input = document.createElement('input');
			input.type = 'file';
			input.accept = '.json';
			
			input.onchange = function(e) {
				const file = e.target.files[0];
				const reader = new FileReader();
				
				reader.onload = function(event) {
					try {
						// ИСПРАВЛЯЕМ: очищаем JSON
						const cleanedContent = cleanJSON(event.target.result);
						const importedData = JSON.parse(cleanedContent);
						
						// Проверяем, это шаблон или обычные данные
						if (importedData.test && importedData.tasks) {
							if (importedData.test.workType && importedData.tasks.length > 0) {
								// Это похоже на шаблон - предлагаем оба варианта
								showImportOptions(importedData, file.name);
							} else {
								// Обычные данные
								showImportConfirmationSimple(importedData);
							}
						} else {
							showNotification('Некорректный формат файла', 'error');
						}
					} catch (error) {
						console.error('Ошибка парсинга JSON:', error);
						showNotification('Ошибка чтения файла: ' + error.message, 'error');
					}
				};
				
				reader.onerror = function() {
					showNotification('Ошибка чтения файла', 'error');
				};
				
				reader.readAsText(file);
			};
			
			input.click();
		}

		// Функция для проверки JSON файла
		function debugJSONFile(file) {
			const reader = new FileReader();
			reader.onload = function(e) {
				console.log('=== DEBUG JSON FILE ===');
				console.log('Имя файла:', file.name);
				console.log('Размер:', file.size, 'байт');
				console.log('Первые 200 символов:', e.target.result.substring(0, 200));
				console.log('Последние 200 символов:', e.target.result.substring(e.target.result.length - 200));
				
				// Проверяем проблемные символы
				const content = e.target.result;
				for (let i = 0; i < content.length; i++) {
					if (content.charCodeAt(i) > 127 && content.charCodeAt(i) < 256) {
						console.log(`Символ ${i}: '${content[i]}' (код: ${content.charCodeAt(i)})`);
					}
				}
				
				try {
					const cleaned = cleanJSON(e.target.result);
					const parsed = JSON.parse(cleaned);
					console.log('? JSON валиден после очистки');
					console.log('Структура:', {
						test: !!parsed.test,
						tasks: parsed.tasks?.length || 0,
						students: parsed.students?.length || 0
					});
				} catch (error) {
					console.error('? Ошибка парсинга:', error.message);
				}
			};
			reader.readAsText(file);
		}

		// ПРОСТОЙ ЭКСПОРТ
		function simpleExport() {
			try {
				const data = {
					test: appData.test,
					tasks: appData.tasks,
					students: appData.students,
					results: appData.results,
					errors: appData.errors,
					timestamp: new Date().toISOString()
				};
				
				const dataStr = JSON.stringify(data, null, 2);
				const blob = new Blob([dataStr], { type: 'application/json' });
				const url = URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.href = url;
				a.download = `данные_${appData.test.subject || 'предмет'}_${new Date().toLocaleDateString()}.json`;
				a.click();
				URL.revokeObjectURL(url);
				
				showNotification('Данные успешно экспортированы', 'success');
			} catch (error) {
				showNotification('Ошибка экспорта: ' + error.message, 'error');
			}
		}

		// ПРОСТОЙ ИМПОРТ
		function simpleImport() {
			const input = document.createElement('input');
			input.type = 'file';
			input.accept = '.json';
			
			input.onchange = function(e) {
				const file = e.target.files[0];
				const reader = new FileReader();
				
				reader.onload = function(event) {
					try {
						const importedData = JSON.parse(event.target.result);
						
						// Проверяем, это шаблон или обычные данные
						if (importedData.test && importedData.tasks) {
							if (importedData.test.workType && importedData.tasks.length > 0) {
								// Это похоже на шаблон - предлагаем оба варианта
								showImportOptions(importedData, file.name);
							} else {
								// Обычные данные
								showImportConfirmationSimple(importedData);
							}
						} else {
							showNotification('Некорректный формат файла', 'error');
						}
					} catch (error) {
						showNotification('Ошибка чтения файла: ' + error.message, 'error');
					}
				};
				
				reader.readAsText(file);
			};
			
			input.click();
		}
		
		// 5. ДИАЛОГ ПОДТВЕРЖДЕНИЯ ИМПОРТА
		function showImportConfirmationSimple(dataToImport, exportInfo = {}) {
			const studentCount = dataToImport.students?.length || 0;
			const taskCount = dataToImport.tasks?.length || 0;
			const subject = dataToImport.test?.subject || 'Не указан';
			const className = dataToImport.test?.class || 'Не указан';
			const exportDate = exportInfo.date || 'Неизвестно';
			
			const html = `
				<div style="max-width: 600px;">
					<h3>?? Импорт данных</h3>
					
					<div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0;">
						<h4>?? Информация о файле:</h4>
						<p><strong>Предмет:</strong> ${subject}</p>
						<p><strong>Класс:</strong> ${className}</p>
						<p><strong>Учащихся:</strong> ${studentCount}</p>
						<p><strong>Заданий:</strong> ${taskCount}</p>
						<p><strong>Дата экспорта:</strong> ${exportDate}</p>
						<p><strong>Версия:</strong> ${exportInfo.version || '1.0'}</p>
					</div>
					
					<div style="background: #fff3cd; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #f39c12;">
						<h4>?? Внимание!</h4>
						<p>Все текущие данные будут заменены. Это действие нельзя отменить.</p>
					</div>
					
					<div class="form-group">
						<label>
							<input type="radio" name="importMode" value="replace" checked>
							Полная замена данных (рекомендуется)
						</label>
						<small style="display: block; color: #666; margin-left: 20px;">
							Заменит все текущие данные импортированными
						</small>
					</div>
					
					<div class="form-group">
						<label>
							<input type="radio" name="importMode" value="merge">
							Объединить данные (экспериментально)
						</label>
						<small style="display: block; color: #666; margin-left: 20px;">
							Попытается объединить старые и новые данные
						</small>
					</div>
				</div>
			`;
			
			showModal('Подтверждение импорта', html + `
				<div style="margin-top: 20px; display: flex; gap: 10px; justify-content: flex-end;">
					<button class="btn btn-danger" onclick="hideModal()">Отмена</button>
					<button class="btn btn-success" onclick="performImport('${encodeURIComponent(JSON.stringify(dataToImport))}')">
						Импортировать
					</button>
				</div>
			`);
		}

		// 6. ВЫПОЛНЕНИЕ ИМПОРТА
		function performImport(encodedData) {
			try {
				// Декодируем данные
				const jsonString = decodeURIComponent(encodedData);
				const dataToImport = JSON.parse(jsonString);
				
				// Получаем выбранный режим
				const importMode = document.querySelector('input[name="importMode"]:checked').value;
				
				if (importMode === 'replace') {
					// Полная замена
					appData = JSON.parse(JSON.stringify(dataToImport));
				} else if (importMode === 'merge') {
					// Объединение данных
					smartMergeData(dataToImport);
				}
				
				// Синхронизируем массивы
				robustSyncData();
				
				// Сохраняем
				saveData();
				
				// Обновляем интерфейс
				renderAll();
				
				// Закрываем модальное окно
				hideModal();
				
				// Показываем уведомление
				showNotification('? Данные успешно импортированы!', 'success');
				
			} catch (error) {
				console.error('Ошибка при импорте:', error);
				showNotification('? Ошибка при импорте: ' + error.message, 'error');
			}
		}
		function smartMergeData(newData) {
			const oldData = JSON.parse(JSON.stringify(appData));
			
			// 1. Обновляем настройки теста (новые важнее)
			appData.test = { ...oldData.test, ...newData.test };
			
			// 2. Умное слияние задач
			// Создаем карту существующих задач по ID или тексту (если ID нет)
			const existingTasksMap = new Map();
			oldData.tasks.forEach((t, i) => existingTasksMap.set(t.id || t.type + t.maxScore, i));

			newData.tasks.forEach(newTask => {
				const key = newTask.id || newTask.type + newTask.maxScore;
				if (!existingTasksMap.has(key)) {
					// Это новая задача - добавляем
					appData.tasks.push(newTask);
				}
			});

			// 3. Умное слияние студентов
			const existingStudentsMap = new Map(); // Нормализованное имя -> Индекс
			appData.students.forEach((s, i) => existingStudentsMap.set(s.trim().toLowerCase(), i));

			// Карта соответствия индексов импорта -> текущие индексы
			const importIndexToCurrentIndex = {};

			newData.students.forEach((newStudentName, importIdx) => {
				const normName = newStudentName.trim().toLowerCase();
				
				if (existingStudentsMap.has(normName)) {
					// Студент уже есть, запоминаем его текущий индекс
					importIndexToCurrentIndex[importIdx] = existingStudentsMap.get(normName);
				} else {
					// Студента нет, добавляем
					appData.students.push(newStudentName);
					const newIndex = appData.students.length - 1;
					importIndexToCurrentIndex[importIdx] = newIndex;
					// Создаем ему пустой массив результатов (синхронизация заполнит позже, но лучше сразу)
					appData.results[newIndex] = new Array(appData.tasks.length).fill(0);
				}
			});

			// 4. Слияние результатов
			// Сначала вызовем синхронизацию, чтобы выровнять матрицы под новые задачи и студентов
			robustSyncData();

			// Теперь переносим оценки из импорта
			newData.results.forEach((scoresRow, importStudentIdx) => {
				const targetStudentIdx = importIndexToCurrentIndex[importStudentIdx];
				
				if (targetStudentIdx !== undefined) {
					scoresRow.forEach((score, taskIdx) => {
						// Если задача существовала, переносим оценку
						// ВАЖНО: Тут нужно сложное сопоставление задач, если их порядок разный.
						// Для простоты предполагаем, что новые задачи добавляются в конец.
						// Если оценка > 0, обновляем (не затираем существующие данные нулями)
						if (score > 0 && appData.results[targetStudentIdx][taskIdx] === 0) {
							appData.results[targetStudentIdx][taskIdx] = parseInt(score) || 0;
						}
					});
				}
			});
			
			// 5. Слияние критериев (полная замена, так как смешивать системы оценивания нельзя)
			if (newData.test.criteria) {
				appData.test.criteria = JSON.parse(JSON.stringify(newData.test.criteria));
				appData.test.criteriaType = newData.test.criteriaType;
				appData.test.criteriaSystem = newData.test.criteriaSystem;
				
				// Обновляем UI селекторы
				const typeSelect = document.getElementById('criteriaType');
				if(typeSelect) typeSelect.value = appData.test.criteriaType;
			}

			saveData();
			renderAll();
			showNotification('Данные успешно объединены', 'success');
		}
		// 7. ОБЪЕДИНЕНИЕ ДАННЫХ
		function mergeData(newData) {
			// Сохраняем старые данные
			const oldData = JSON.parse(JSON.stringify(appData));
			
			// Объединяем настройки теста (новые имеют приоритет)
			appData.test = { ...oldData.test, ...newData.test };
			
			// Объединяем критерии
			if (newData.test.criteria) {
				appData.test.criteria = { ...oldData.test.criteria, ...newData.test.criteria };
			}
			
			// Объединяем задания (добавляем только новые)
			const oldTaskKeys = oldData.tasks.map(t => `${t.type}|${t.maxScore}|${t.level}`).join('|');
			newData.tasks.forEach(newTask => {
				const newTaskKey = `${newTask.type}|${newTask.maxScore}|${newTask.level}`;
				if (!oldTaskKeys.includes(newTaskKey)) {
					appData.tasks.push(newTask);
				}
			});
			
			// Объединяем учащихся (добавляем только новых)
			const oldStudentsLower = oldData.students.map(s => s.toLowerCase().trim());
			newData.students.forEach(newStudent => {
				if (!oldStudentsLower.includes(newStudent.toLowerCase().trim())) {
					appData.students.push(newStudent);
					// Добавляем пустые результаты для нового ученика
					appData.results.push(new Array(appData.tasks.length).fill(0));
				}
			});
			
			// Объединяем ошибки
			appData.errors = [...oldData.errors, ...(newData.errors || [])];
			
			// Объединяем результаты (сложная логика)
			mergeResults(oldData, newData);
		}

		// 8. СИНХРОНИЗАЦИЯ МАССИВОВ
		function syncDataArrays() {
			// Убеждаемся, что количество результатов соответствует количеству учащихся
			while (appData.results.length < appData.students.length) {
				appData.results.push(new Array(appData.tasks.length).fill(0));
			}
			
			// Удаляем лишние результаты
			if (appData.results.length > appData.students.length) {
				appData.results = appData.results.slice(0, appData.students.length);
			}
			
			// Корректируем длину каждого массива результатов
			appData.results.forEach((studentResults, index) => {
				while (studentResults.length < appData.tasks.length) {
					studentResults.push(0);
				}
				if (studentResults.length > appData.tasks.length) {
					appData.results[index] = studentResults.slice(0, appData.tasks.length);
				}
			});
		}
		// 9. МЕНЮ ИМПОРТА/ЭКСПОРТА
		function showImportExportMenu() {
			// Убедимся, что templates существует
			if (!appData.templates) {
				appData.templates = {
					loadedTemplates: [],
					lastTemplatePath: "",
					lastTemplateName: "",
					availableSubjects: []
				};
			}
			
			const hasLastTemplate = appData.templates.lastTemplatePath && appData.templates.lastTemplatePath.trim() !== "";
			
			const html = `
				<div style="text-align: center; padding: 20px;">
					<h3>?? Импорт/Экспорт данных</h3>
					
					<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 30px 0;">
						<div style="background: #d4edda; padding: 20px; border-radius: 10px; text-align: center;">
							<div style="font-size: 3em; margin-bottom: 10px;">??</div>
							<h4>Экспорт данных</h4>
							<p>Сохранить все данные в файл JSON</p>
							<button class="btn btn-success" onclick="simpleExport()" style="width: 100%; margin-top: 10px;">
								Экспортировать
							</button>
						</div>
						
						<div style="background: #fff3cd; padding: 20px; border-radius: 10px; text-align: center;">
							<div style="font-size: 3em; margin-bottom: 10px;">??</div>
							<h4>Импорт данных</h4>
							<p>Загрузить данные из файла JSON</p>
							<button class="btn btn-warning" onclick="simpleImport()" style="width: 100%; margin-top: 10px;">
								Простой импорт
							</button>
						</div>
					</div>
					
					<!-- НОВЫЙ БЛОК: ИМПОРТ ИЗ ШАБЛОНОВ -->
					<div style="background: #d6eaf8; padding: 20px; border-radius: 10px; text-align: center; margin: 20px 0;">
						<div style="font-size: 3em; margin-bottom: 10px;">??</div>
						<h4>Импорт из шаблонов DeepSeek</h4>
						<p>Автоматическое сканирование папки с шаблонами</p>
						
						<div style="display: flex; gap: 10px; margin-top: 15px;">
							<button class="btn btn-primary" onclick="scanTemplateFolder()" style="flex: 1; padding: 12px;">
								?? Выбрать/Сменить папку
							</button>
							<button class="btn btn-success" onclick="showTemplateSelection()" style="flex: 1; padding: 12px;">
								?? Показать шаблоны
							</button>
						</div>
						
						<small style="display: block; margin-top: 10px; color: #666;">
							Поддерживает: ОГЭ, ЕГЭ, ВПР, функциональную грамотность, психологическую диагностику
						</small>
						
						${hasLastTemplate ? `
						<div style="margin-top: 15px; padding: 10px; background: white; border-radius: 6px;">
							<small>Последний шаблон: <strong>${appData.templates.lastTemplateName || 'Без названия'}</strong></small>
							<button class="btn btn-sm btn-outline-primary" onclick="importLastTemplate()" style="margin-left: 10px;">
								Повторить импорт
							</button>
						</div>
						` : ''}
						
						<!-- Статус сканера -->
						<div id="templateScannerStatus" style="margin-top: 15px; padding: 10px; background: rgba(255,255,255,0.8); border-radius: 6px; font-size: 0.85em;">
							<small>Инициализация сканера...</small>
						</div>
					</div>
					
					<div style="background: #d1ecf1; padding: 15px; border-radius: 8px; text-align: left; margin-top: 20px;">
						<h5>?? Как работать с шаблонами:</h5>
						<ol>
							<li><strong>Сгенерируйте шаблоны</strong> в DeepSeek для нужных предметов</li>
							<li><strong>Сохраните JSON файлы</strong> в отдельную папку</li>
							<li><strong>Нажмите "Выбрать папку"</strong> и выберите эту папку</li>
							<li><strong>Выберите нужный шаблон</strong> из списка и импортируйте</li>
						</ol>
					</div>
					
					<div style="margin-top: 20px; text-align: left;">
						<h5>?? Дополнительные инструменты:</h5>
						<button class="btn" onclick="createSampleFile()" style="margin-right: 10px;">
							?? Создать пример файла
						</button>
						<button class="btn" onclick="checkDataStructure()">
							?? Проверить структуру данных
						</button>
					</div>
				</div>
			`;
			
			showModal('Импорт/Экспорт данных', html);
		}
		// 12. ДОБАВЛЕНИЕ КНОПОК В ИНТЕРФЕЙС
		function addImportExportButtons() {
			// Находим контейнер для кнопок экспорта
			const exportSection = document.getElementById('export');
			if (!exportSection) return;
			<!--
			// Добавляем кнопки в начало
			const buttonsContainer = exportSection.querySelector('.export-buttons');
			if (buttonsContainer) {
				buttonsContainer.innerHTML = `
					<button class="btn btn-success" onclick="simpleExport()">
						?? Экспорт данных (JSON)
					</button>
					<button class="btn btn-warning" onclick="simpleImport()">
						?? Импорт данных (JSON)  
					</button>
					<button class="btn" onclick="showImportExportMenu()">
						?? Меню импорта/экспорта
					</button>
					<button class="btn" onclick="createSampleFile()">
						?? Пример файла
					</button>
					${buttonsContainer.innerHTML}
				`;
			}
			-->
			// Также добавляем кнопку в верхнюю панель
			const tabsContainer = document.querySelector('.tabs');
			if (tabsContainer && !document.querySelector('.tab-btn[onclick*="showImportExportMenu"]')) {
				const transferTab = document.createElement('button');
				transferTab.className = 'tab-btn';
				transferTab.innerHTML = '?? Импорт/Экспорт';
				transferTab.onclick = showImportExportMenu;
				tabsContainer.appendChild(transferTab);
			}
		}
		
		// 10. СОЗДАНИЕ ПРИМЕРНОГО ФАЙЛА
		function createSampleFile() {
			// Создаем пустой файл с примером структуры
			const sampleData = {
				test: {
					subject: "Математика",
					class: "5А",
					testDate: new Date().toISOString().split('T')[0],
					theme: "Дроби и проценты",
					goals: "Пример целей обучения",
					workType: "current",
					workFormat: "mixed",
					timeLimit: 45,
					totalStudents: 25,
					presentStudents: 23,
					absentReason: "",
					criteria: {
						5: { min: 18, max: 20 },
						4: { min: 15, max: 17 },
						3: { min: 10, max: 14 },
						2: { min: 0, max: 9 }
					}
				},
				tasks: [
					{ type: "Пример задания 1", maxScore: 2, level: 1, knowledge: "" },
					{ type: "Пример задания 2", maxScore: 3, level: 2, knowledge: "" }
				],
				students: ["Иванов А.", "Петрова М.", "Сидоров Д."],
				results: [[1, 2], [2, 2], [0, 1]],
				errors: [],
				instructions: "Это пример файла. Заполните его своими данными."
			};
			
			const dataStr = JSON.stringify(sampleData, null, 2);
			const blob = new Blob([dataStr], { type: 'application/json' });
			const url = URL.createObjectURL(blob);
			const a = document.createElement('a');
			a.href = url;
			a.download = "пример_файла_данных.json";
			a.click();
			URL.revokeObjectURL(url);
			
			showNotification('Пример файла создан', 'success');
		}

		// 11. ПРОВЕРКА СТРУКТУРЫ ДАННЫХ
		function checkDataStructure() {
			const html = `
				<div style="max-width: 800px;">
					<h3>?? Проверка структуры данных</h3>
					
					<div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0;">
						<h4>Текущие данные:</h4>
						<p><strong>Учащихся:</strong> ${appData.students.length}</p>
						<p><strong>Заданий:</strong> ${appData.tasks.length}</p>
						<p><strong>Результатов:</strong> ${appData.results.length} ? ${appData.results[0]?.length || 0}</p>
						<p><strong>Ошибок:</strong> ${appData.errors.length}</p>
					</div>
					
					<div style="background: #e8f4fc; padding: 15px; border-radius: 8px; margin: 15px 0;">
						<h4>Структура для экспорта:</h4>
						<pre style="background: white; padding: 10px; border-radius: 4px; font-size: 10px; max-height: 300px; overflow: auto;">
							${JSON.stringify({
								test: { subject: "...", class: "..." },
								tasks: ["...", "..."],
								students: ["...", "..."],
								results: [["..."], ["..."]]
							}, null, 2)}
						</pre>
					</div>
					
					<div style="margin-top: 20px;">
						<button class="btn" onclick="hideModal()">Закрыть</button>
					</div>
				</div>
			`;
			
			showModal('Проверка структуры данных', html);
		}

		// 3. ВСПОМОГАТЕЛЬНАЯ ФУНКЦИЯ для чтения файла
		function readFileAsText(file) {
			return new Promise((resolve, reject) => {
				const reader = new FileReader();
				
				reader.onload = function(e) {
					resolve(e.target.result);
				};
				
				reader.onerror = function(e) {
					reject(new Error('Не удалось прочитать файл'));
				};
				
				// Читаем как текст с UTF-8
				reader.readAsText(file, 'UTF-8');
			});
		}
		
		// 4. УПРОЩЕННАЯ ВАЛИДАЦИЯ данных
		function validateImportData(data) {
			try {
				// Проверяем базовую структуру
				if (!data || typeof data !== 'object') {
					return false;
				}
				
				// Получаем данные (новый или старый формат)
				const appData = data.appData || data;
				
				// Проверяем обязательные поля
				if (!appData.test || typeof appData.test !== 'object') {
					return false;
				}
				
				if (!Array.isArray(appData.tasks)) {
					return false;
				}
				
				if (!Array.isArray(appData.students)) {
					return false;
				}
				
				if (!Array.isArray(appData.results)) {
					return false;
				}
				
				// Проверяем соответствие размеров массивов
				if (appData.results.length !== appData.students.length) {
					console.warn('Количество результатов не соответствует количеству учащихся');
					// Не блокируем импорт, но предупреждаем
				}
				
				return true;
				
			} catch (error) {
				console.error('Ошибка валидации:', error);
				return false;
			}
		}

		
		// ДОБАВЬТЕ ЭТИ КНОПКИ В ИНТЕРФЕЙС
		function addFixedTransferButtons() {
			// В раздел экспорта
			const exportTab = document.querySelector('#export .export-buttons');
			if (exportTab) {
				// Удаляем старые кнопки и добавляем новые
				exportTab.innerHTML += `
					<button class="btn btn-success" onclick="simpleExport()">?? Экспорт (простой)</button>
					<button class="btn btn-warning" onclick="simpleImport()">?? Импорт (простой)</button>
					<button class="btn" onclick="simpleImportExport()">?? Простой импорт/экспорт</button>
					<button class="btn" onclick="createTestImportFile()">?? Тестовый файл</button>
					<button class="btn btn-danger" onclick="showResetDialog()">?? Сброс всех данных</button>
				`;
			}
		}
		
		function printPsychologyReport() {
			if (appData.test.workType !== 'psychology') {
				showNotification('Эта функция доступна только для психологических тестов', 'warning');
				return;
			}
			
			const psychologyReport = generatePsychologyPrintReport();
			const fullReport = `
				<div class="header">
					<h1>?? Психологическое заключение</h1>
					<h2>${appData.test.subject || 'Психологическая диагностика'}, ${appData.test.class || 'Класс не указан'}</h2>
					<p><strong>Методика:</strong> ${appData.test.theme || 'Не указана'} | <strong>Дата:</strong> ${appData.test.testDate ? new Date(appData.test.testDate).toLocaleDateString() : 'Не указана'}</p>
				</div>
				${psychologyReport}
				<div class="section small-text text-center">
					<p><em>Заключение составлено ${new Date().toLocaleDateString()}. Конфиденциально.</em></p>
				</div>
			`;
			
			const printWindow = window.open('', '_blank');
			printWindow.document.write(`
				<!DOCTYPE html>
				<html>
				<head>
					<title>Психологическое заключение - ${appData.test.theme}</title>
					<meta charset="UTF-8">
					<style>
						body { 
							font-family: 'Arial', sans-serif; 
							margin: 0; 
							padding: 15mm; 
							line-height: 1.5;
							color: #333;
							font-size: 11pt;
						}
						@page {
							size: A4;
							margin: 20mm;
						}
						.header { 
							text-align: center; 
							margin-bottom: 25px;
							padding-bottom: 15px;
							border-bottom: 2px solid #9b59b6;
							background: linear-gradient(135deg, #8e44ad, #9b59b6);
							color: white;
							padding: 20px;
							border-radius: 8px;
						}
						.section { 
							margin: 25px 0; 
							page-break-inside: avoid;
						}
						.section-title {
							color: #8e44ad;
							margin: 20px 0 15px 0;
							padding-bottom: 8px;
							border-bottom: 1px solid #9b59b6;
							font-size: 1.3em;
							font-weight: bold;
						}
						table { 
							width: 100%; 
							border-collapse: collapse; 
							margin: 15px 0;
							font-size: 10pt;
							page-break-inside: avoid;
						}
						th, td { 
							border: 1px solid #ddd; 
							padding: 8px; 
							text-align: left; 
							vertical-align: top;
						}
						th { 
							background-color: #8e44ad; 
							color: white; 
							font-weight: bold;
						}
						.recommendation-card {
							background: #f5eef8;
							padding: 15px;
							margin: 15px 0;
							border-radius: 6px;
							border-left: 4px solid #9b59b6;
						}
						.print-break { 
							page-break-before: always; 
						}
						.small-text { font-size: 9pt; }
						.text-center { text-align: center; }
						ul {
							margin: 10px 0;
							padding-left: 25px;
						}
						li {
							margin: 6px 0;
						}
						.level-indicator {
							display: inline-block;
							padding: 3px 10px;
							border-radius: 12px;
							font-size: 10pt;
							margin: 2px;
							color: white;
							font-weight: bold;
						}
						.psychology-note {
							background: #fff8e1;
							border: 1px solid #ffd54f;
							padding: 10px;
							margin: 15px 0;
							border-radius: 4px;
							font-size: 10pt;
						}
					</style>
				</head>
				<body>
					${fullReport}
				</body>
				</html>
			`);
			
			printWindow.document.close();
			
			setTimeout(() => {
				printWindow.print();
				setTimeout(() => {
					printWindow.close();
				}, 500);
			}, 500);
			
			showNotification('Психологическое заключение подготовлено для печати', 'success');
		}
		
		// НОВАЯ ФУНКЦИЯ: Показать сырое содержимое файла
		function showRawFileContent(encodedContent) {
			try {
				const content = atob(encodedContent);
				
				let html = `
					<h3>?? Содержимое файла</h3>
					<div style="max-height: 400px; overflow-y: auto; background: #f8f9fa; padding: 15px; border-radius: 8px;">
						<pre style="font-size: 10px; white-space: pre-wrap; word-break: break-all;">${content}</pre>
					</div>
					<div style="margin-top: 15px;">
						<button class="btn" onclick="hideModal()">Закрыть</button>
					</div>
				`;
				
				showModal('Содержимое файла', html);
				
			} catch (error) {
				showNotification('Ошибка при отображении содержимого', 'error');
			}
		}


		// 4. Валидация импортированных данных - ИСПРАВЛЕННАЯ ВЕРСИЯ
		function validateImportedData(data) {
			// Базовые проверки
			if (!data || typeof data !== 'object') {
				console.error('Данные не являются объектом:', data);
				return false;
			}
			
			// Проверяем наличие appData или прямой импорт данных
			if (!data.appData && !data.test) {
				console.error('Отсутствует appData или test:', data);
				return false;
			}
			
			// Получаем фактический объект данных
			const importedAppData = data.appData || data;
			
			try {
				// Проверяем базовую структуру
				const requiredKeys = ['test', 'tasks', 'students', 'results'];
				
				for (const key of requiredKeys) {
					if (!(key in importedAppData)) {
						console.error('Отсутствует обязательный ключ:', key);
						return false;
					}
				}
				
				// Проверяем типы данных
				if (!Array.isArray(importedAppData.tasks)) {
					console.error('tasks не является массивом:', importedAppData.tasks);
					return false;
				}
				
				if (!Array.isArray(importedAppData.students)) {
					console.error('students не является массивом:', importedAppData.students);
					return false;
				}
				
				if (!Array.isArray(importedAppData.results)) {
					console.error('results не является массивом:', importedAppData.results);
					return false;
				}
				
				// Проверяем наличие test объекта
				if (!importedAppData.test || typeof importedAppData.test !== 'object') {
					console.error('test не является объектом:', importedAppData.test);
					return false;
				}
				
				// Проверяем errors (может быть пустым массивом или отсутствовать)
				if (importedAppData.errors && !Array.isArray(importedAppData.errors)) {
					console.error('errors не является массивом:', importedAppData.errors);
					return false;
				}
				
				// Минимальная проверка структуры результатов
				if (importedAppData.results.length > 0) {
					const firstResult = importedAppData.results[0];
					if (!Array.isArray(firstResult) && typeof firstResult !== 'number') {
						console.error('Некорректная структура results:', firstResult);
						return false;
					}
				}
				
				return true;
				
			} catch (error) {
				console.error('Ошибка при валидации данных:', error);
				return false;
			}
		}

		// 5. Диалог подтверждения импорта - УЛУЧШЕННАЯ ВЕРСИЯ
		function showImportConfirmationDialog(importedData) {
			// Определяем, где находятся данные
			const actualData = importedData.appData || importedData;
			const metadata = importedData.metadata || {};
			
			// Генерируем информацию для отображения
			const subject = metadata.subject || actualData.test?.subject || 'Не указан';
			const className = metadata.class || actualData.test?.class || 'Не указан';
			const studentCount = metadata.studentCount || actualData.students?.length || 0;
			const taskCount = metadata.taskCount || actualData.tasks?.length || 0;
			const exportDate = metadata.exportedAt || importedData.timestamp || 'Не указана';
			
			// Безопасное кодирование данных для передачи
			const encodedData = safeEncode(importedData);
			
			const html = `
				<div style="max-width: 600px;">
					<h3>?? Подтверждение импорта данных</h3>
					
					<div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0;">
						<h4>?? Информация о файле:</h4>
						<p><strong>Предмет:</strong> ${subject}</p>
						<p><strong>Класс:</strong> ${className}</p>
						<p><strong>Тип работы:</strong> ${actualData.test?.workType || 'Не указан'}</p>
						<p><strong>Учащихся:</strong> ${studentCount}</p>
						<p><strong>Заданий:</strong> ${taskCount}</p>
						<p><strong>Дата экспорта:</strong> ${exportDate}</p>
						<p><strong>Версия файла:</strong> ${importedData.version || '1.0'}</p>
					</div>
					
					<div style="background: #fff3cd; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #f39c12;">
						<h4>?? Внимание!</h4>
						<p>Текущие данные будут заменены импортированными. Это действие нельзя отменить.</p>
					</div>
					
					<div class="form-group">
						<label>
							<input type="checkbox" id="mergeData" checked>
							Объединить с текущими данными (если возможно)
						</label>
						<small style="display: block; color: #666; margin-top: 5px;">
							При включении: данные будут добавлены к существующим, а не заменены полностью
						</small>
					</div>
					
					<div class="form-group">
						<label>Действие при конфликтах:</label>
						<select id="conflictResolution">
							<option value="replace">Заменить текущие данные</option>
							<option value="keep">Сохранить текущие данные</option>
							<option value="merge">Объединить данные</option>
						</select>
					</div>
					
					<div class="form-group">
						<button class="btn" onclick="showDataPreview('${encodedData}')">
							?? Предварительный просмотр данных
						</button>
					</div>
				</div>
			`;
			
			showModal('Импорт данных из файла', html + `
				<div style="margin-top: 20px; display: flex; gap: 10px; justify-content: flex-end;">
					<button class="btn btn-danger" onclick="hideModal()">Отмена</button>
					<button class="btn btn-success" onclick="confirmImport(true, '${encodedData}')">Импортировать</button>
				</div>
			`);
		}

		// В раздел экспорта добавьте кнопки для тестирования:
		function addDebugButtons() {
			const exportTab = document.querySelector('#export .export-buttons');
			if (exportTab) {
				exportTab.innerHTML += `
					<button class="btn btn-warning" onclick="createTestImportFile()">?? Создать тестовый файл</button>
					<button class="btn btn-info" onclick="testDataStructure()">?? Проверить структуру данных</button>
				`;
			}
		}

		// Функция для проверки структуры данных
		function testDataStructure() {
			console.log('Текущая структура appData:', appData);
			console.log('Проверка валидации текущих данных:', validateImportedData({appData: appData}));
			
			let html = `
				<h3>?? Проверка структуры данных</h3>
				<div style="max-height: 400px; overflow-y: auto; background: #f8f9fa; padding: 15px; border-radius: 8px;">
					<pre style="font-size: 10px; white-space: pre-wrap;">${JSON.stringify(appData, null, 2)}</pre>
				</div>
				<div style="margin-top: 15px;">
					<button class="btn" onclick="hideModal()">Закрыть</button>
				</div>
			`;
			
			showModal('Структура данных', html);
		}


		// НОВАЯ ФУНКЦИЯ: Предпросмотр структуры данных
		function showDataPreview(encodedData) {
			try {
				const importedData = safeDecode(encodedData);
				
				if (!importedData) {
					showNotification('Ошибка при декодировании данных', 'error');
					return;
				}
				
				const actualData = importedData.appData || importedData;
				
				let html = `
					<h3>?? Структура импортируемых данных</h3>
					<div style="max-height: 400px; overflow-y: auto; background: #f8f9fa; padding: 15px; border-radius: 8px;">
						<pre style="font-size: 10px; white-space: pre-wrap;">${JSON.stringify(actualData, null, 2)}</pre>
					</div>
					<div style="margin-top: 15px;">
						<button class="btn" 
								onclick="hideModal(); showImportConfirmationDialog(this)"
								data-import='${JSON.stringify(importedData).replace(/'/g, "&apos;")}'>
							Назад
						</button>
					</div>
				`;
				
				showModal('Структура данных', html);
				
			} catch (error) {
				showNotification('Ошибка при просмотре данных', 'error');
			}
		}

		// 6. Подтверждение импорта - УЛУЧШЕННАЯ ВЕРСИЯ
		function confirmImport(shouldImport, encodedData) {
			if (!shouldImport) {
				hideModal();
				return;
			}
			
			try {
				const importedData = JSON.parse(atob(encodedData));
				const mergeData = document.getElementById('mergeData')?.checked || false;
				const conflictResolution = document.getElementById('conflictResolution')?.value || 'replace';
				
				// Логирование для отладки
				console.log('Импортируемые данные:', importedData);
				
				applyImportedData(importedData, mergeData, conflictResolution);
				
				hideModal();
				showNotification('Данные успешно импортированы', 'success');
				
				// Сохраняем информацию об импорте
				if (importedData.metadata) {
					saveImportHistory(importedData.metadata);
				}
				
			} catch (error) {
				console.error('Ошибка при импорте:', error);
				showNotification('Ошибка при импорте данных: ' + error.message, 'error');
			}
		}

		// 7. Применение импортированных данных - УЛУЧШЕННАЯ ВЕРСИЯ
		function applyImportedData(importedData, mergeData, conflictResolution) {
			const newData = importedData.appData || importedData;
			
			console.log('Новые данные для импорта:', newData);
			console.log('Текущий режим:', conflictResolution);
			console.log('Объединение данных:', mergeData);
			
			if (!mergeData || conflictResolution === 'replace') {
				// Полная замена данных
				appData = JSON.parse(JSON.stringify(newData));
				console.log('Данные полностью заменены');
				
			} else if (conflictResolution === 'merge') {
				console.log('Начинаем объединение данных...');
        
				// 1. Объединяем настройки (приоритет у новых)
				appData.test = { ...appData.test, ...newData.test };
				if (newData.test.criteria) {
					appData.test.criteria = { ...appData.test.criteria, ...newData.test.criteria };
				}

				// 2. Сначала просто добавляем НОВЫЕ задания в конец, если это расширение теста
				// ВАЖНО: Если мы просто обновляем оценки существующего теста, задания дублировать НЕЛЬЗЯ.
				// Простая логика: если количество заданий совпадает, считаем что это тот же тест.
				if (newData.tasks.length > appData.tasks.length) {
					 const newTasksToAdd = newData.tasks.slice(appData.tasks.length);
					 appData.tasks = [...appData.tasks, ...newTasksToAdd];
				}

				// 3. Добавляем новых учеников
				const existingStudents = new Set(appData.students.map(s => s.toLowerCase().trim()));
				newData.students.forEach(student => {
					if (!existingStudents.has(student.toLowerCase().trim())) {
						appData.students.push(student);
						// Сразу создаем пустую строку результатов для нового ученика
						appData.results.push(new Array(appData.tasks.length).fill(0));
					}
				});

				// 4. ВАЖНО: Синхронизируем размерности массивов ПЕРЕД заливкой данных
				adjustResultsArray();

				// 5. Теперь, когда структуры готовы, заливаем данные
				mergeResults(newData); // Использует нашу новую умную функцию
				
				// Объединяем ошибки
				if (newData.errors) {
					// Простая конкатенация может создать дубли, но это безопаснее потери
					appData.errors = [...appData.errors, ...newData.errors];
				}

				console.log('Данные успешно объединены');
				
			} else if (conflictResolution === 'keep') {
				// Сохраняем текущие данные, добавляем только отсутствующее
				console.log('Сохранение текущих данных с добавлением нового...');
				
				// Добавляем только новых учащихся
				const existingStudents = new Set(appData.students.map(s => s.toLowerCase().trim()));
				
				newData.students?.forEach(student => {
					const normalizedStudent = student.toLowerCase().trim();
					if (!existingStudents.has(normalizedStudent)) {
						appData.students.push(student);
						existingStudents.add(normalizedStudent);
						// Добавляем пустые результаты
						appData.results.push(new Array(appData.tasks.length).fill(0));
					}
				});
				
				console.log('Добавлены только новые учащиеся');
			}
			
			// Синхронизируем количество учащихся
			adjustResultsArray();
			
			// Сохраняем данные
			saveData();
			
			// Обновляем интерфейс
			renderAll();
			
			// Показываем статистику импорта
			showImportStatistics(newData);
		}
		function renderPointsCriteria(system, count) {
			const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0) || 100;
			
			let html = `<h4>Настройка критериев (в баллах)</h4>
						<p style="font-size: 12px; color: #666; margin-bottom: 15px;">
							Максимально возможный балл: <strong>${maxPossible}</strong>
						</p>`;
			
			for (let i = 1; i <= count; i++) {
				const criteria = appData.test.criteria[i] || { min: 0, max: 0 };
				
				// Для стандартной системы показываем оценки 2-5
				const displayLevel = getDisplayLevel(system, i);
				const description = getLevelDescription(system, i);
				
				html += `
					<div class="form-group">
						<label>${displayLevel} ${description}:</label>
						<div style="display: flex; gap: 10px; align-items: center;">
							<input type="number" id="criteria${i}min" 
								   value="${criteria.min}" 
								   min="0" max="${maxPossible}" step="1"
								   class="criteria-min" 
								   style="flex: 1;"
								   placeholder="Мин. баллы">
							<span>—</span>
							<input type="number" id="criteria${i}max" 
								   value="${criteria.max}" 
								   min="0" max="${maxPossible}" step="1"
								   class="criteria-max" 
								   style="flex: 1;"
								   placeholder="Макс. баллы">
						</div>
					</div>
				`;
			}
			
			return html;
		}

		function getDisplayLevel(system, levelIndex) {
			switch(system) {
				case 'standard':
					// Показываем 2-5 для стандартной системы
					return levelIndex === 1 ? '2 (Неудовл.)' : 
						   levelIndex === 2 ? '3 (Удовл.)' : 
						   levelIndex === 3 ? '4 (Хорошо)' : 
						   levelIndex === 4 ? '5 (Отлично)' : 
						   `Уровень ${levelIndex + 1}`;
				
				case 'five_point':
					return levelIndex === 1 ? '1 (Очень плохо)' :
						   levelIndex === 2 ? '2 (Плохо)' :
						   levelIndex === 3 ? '3 (Средне)' :
						   levelIndex === 4 ? '4 (Хорошо)' :
						   levelIndex === 5 ? '5 (Отлично)' :
						   `Уровень ${levelIndex}`;
				
				case 'ten_point':
					return levelIndex === 10 ? '10 (Безупречно)' :
						   levelIndex >= 8 ? `${levelIndex} (Отлично)` :
						   levelIndex >= 6 ? `${levelIndex} (Хорошо)` :
						   levelIndex >= 4 ? `${levelIndex} (Удовл.)` :
						   `${levelIndex} (Плохо)`;
				
				default:
					return `Уровень ${levelIndex}`;
			}
		}

		function getLevelDescription(system, levelIndex) {
			// Возвращает короткое описание для подсказки
			if (system === 'standard') {
				return '(Диапазон %)';
			}
			return '';
		}

		function setupCriteriaListeners() {
			// Автоматически обновляем минимумы/максимумы
			document.querySelectorAll('.criteria-min').forEach(input => {
				input.addEventListener('change', function() {
					const level = this.id.replace('criteria', '').replace('min', '');
					const maxInput = document.getElementById(`criteria${level}max`);
					
					if (maxInput && parseInt(this.value) > parseInt(maxInput.value)) {
						maxInput.value = this.value;
					}
				});
			});
			
			document.querySelectorAll('.criteria-max').forEach(input => {
				input.addEventListener('change', function() {
					const level = this.id.replace('criteria', '').replace('max', '');
					const minInput = document.getElementById(`criteria${level}min`);
					
					if (minInput && parseInt(this.value) < parseInt(minInput.value)) {
						minInput.value = this.value;
					}
				});
			});
		}

		// Функции для работы с критериями
		// Функция для обновления системы критериев
		function updateCriteriaSystem() {
			const type = document.getElementById('criteriaType').value;
			const system = document.getElementById('criteriaSystem').value;
			let count = parseInt(document.getElementById('criteriaCount').value) || 4;
			
			// Ограничиваем количество уровней в зависимости от системы
			if (system === 'standard') {
				count = 4; // Стандартная система всегда имеет 4 уровня
				document.getElementById('criteriaCount').value = 4;
			} else if (system === 'five_point') {
				count = 5; // Пятибалльная система всегда имеет 5 уровней
				document.getElementById('criteriaCount').value = 5;
			} else if (system === 'ten_point') {
				count = 10; // Десятибалльная система всегда имеет 10 уровней
				document.getElementById('criteriaCount').value = 10;
			}
			
			appData.test.criteriaType = type;
			appData.test.criteriaSystem = system;
			appData.test.criteriaCount = count;
			
			// Инициализируем критерии по умолчанию если их нет
			if (!appData.test.criteria || Object.keys(appData.test.criteria).length === 0) {
				initializeDefaultCriteria();
			}
			
			renderCriteriaSettings();
		}

		function initializeDefaultCriteria() {
			const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0) || 100;
			const system = appData.test.criteriaSystem;
			const count = appData.test.criteriaCount;
			
			appData.test.criteria = {};
			
			if (system === 'standard') {
				// Стандартная система (2-5): 4 уровня
				appData.test.criteria = {
					1: { min: 0, max: Math.round(maxPossible * 0.49) },         // 2
					2: { min: Math.round(maxPossible * 0.5), max: Math.round(maxPossible * 0.69) }, // 3
					3: { min: Math.round(maxPossible * 0.7), max: Math.round(maxPossible * 0.84) }, // 4
					4: { min: Math.round(maxPossible * 0.85), max: maxPossible } // 5
				};
			} else if (system === 'five_point') {
				// Пятибалльная система (1-5): 5 уровней
				appData.test.criteria = {
					1: { min: 0, max: Math.round(maxPossible * 0.2) },          // 1
					2: { min: Math.round(maxPossible * 0.21), max: Math.round(maxPossible * 0.4) }, // 2
					3: { min: Math.round(maxPossible * 0.41), max: Math.round(maxPossible * 0.6) }, // 3
					4: { min: Math.round(maxPossible * 0.61), max: Math.round(maxPossible * 0.8) }, // 4
					5: { min: Math.round(maxPossible * 0.81), max: maxPossible } // 5
				};
			} else if (system === 'ten_point') {
				// Десятибалльная система (1-10): 10 уровней
				const step = maxPossible / 10;
				for (let i = 1; i <= 10; i++) {
					appData.test.criteria[i] = {
						min: Math.round((i - 1) * step),
						max: Math.round(i * step)
					};
				}
			}
		}

		// Упрощенная версия функции отрисовки критериев
		function renderCriteriaSettings() {
			const container = document.getElementById('criteriaSettingsContainer');
			if (!container) return;
			
			const type = appData.test.criteriaType || 'points';
			const system = appData.test.criteriaSystem || 'standard';
			let count = appData.test.criteriaCount || 4;
			
			// Для стандартной системы всегда 4 уровня
			if (system === 'standard') {
				count = 4;
			}
			
			console.log('renderCriteriaSettings:', { type, system, count });
			
			let html = `
				<div class="form-group">
					<label>Тип оценивания:</label>
					<select id="criteriaType" onchange="updateCriteriaSystem()">
						<option value="points" ${type === 'points' ? 'selected' : ''}>Баллы</option>
						<option value="percentage" ${type === 'percentage' ? 'selected' : ''}>Проценты (%)</option>
						<option value="custom" ${type === 'custom' ? 'selected' : ''}>Своя шкала</option>
					</select>
				</div>
				
				<div class="form-group">
					<label>Система оценивания:</label>
					<select id="criteriaSystem" onchange="updateCriteriaSystem()">
						<option value="standard" ${system === 'standard' ? 'selected' : ''}>Стандартная (2-5)</option>
						<option value="five_point" ${system === 'five_point' ? 'selected' : ''}>Пятибалльная (1-5)</option>
						<option value="ten_point" ${system === 'ten_point' ? 'selected' : ''}>Десятибалльная (1-10)</option>
						<option value="custom" ${system === 'custom' ? 'selected' : ''}>Своя система</option>
					</select>
				</div>
				
				<div class="form-group">
					<label>Количество уровней:</label>
					<input type="number" id="criteriaCount" min="2" max="10" 
						   value="${count}" ${system === 'standard' ? 'disabled' : ''} 
						   onchange="updateCriteriaSystem()"
						   style="${system === 'standard' ? 'background: #f0f0f0;' : ''}">
					${system === 'standard' ? '<small style="color: #666;">Для стандартной системы фиксировано 4 уровня</small>' : ''}
				</div>
			`;
			
			// Добавляем быстрые пресеты
			html += addCriteriaPresets();
			
			// Отображаем критерии
			html += '<div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">';
			
			if (type === 'percentage') {
				html += '<h4>Настройка диапазонов (в процентах)</h4>';
				html += renderPercentageCriteria(system, count);
			} else if (type === 'points') {
				const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0);
				html += `<h4>Настройка диапазонов (в баллах)</h4>
						 <p style="font-size: 12px; color: #666; margin-bottom: 15px;">
							Максимально возможный балл: <strong>${maxPossible}</strong>
						 </p>`;
				html += renderPointsCriteria(system, count, maxPossible);
			} else {
				html += '<h4>Настройка пользовательской шкалы</h4>';
				html += '<p>Используйте пресеты или создайте свою систему</p>';
			}
			
			html += '</div>';
			
			container.innerHTML = html;
			
			// Добавляем слушатели для автоматической валидации
			setupCriteriaListeners();
		}
		
		function debugCriteria() {
			console.log('=== ОТЛАДКА КРИТЕРИЕВ ===');
			console.log('Тип:', appData.test.criteriaType);
			console.log('Система:', appData.test.criteriaSystem);
			console.log('Количество:', appData.test.criteriaCount);
			console.log('Критерии:', appData.test.criteria);
			
			// Проверяем, что все уровни существуют
			const count = appData.test.criteriaCount || 0;
			for (let i = 1; i <= count; i++) {
				if (!appData.test.criteria[i]) {
					console.error(`? Критерий ${i} не определен!`);
				}
			}
		}

		function renderPercentageCriteria(system, count) {
			let html = '';
			
			for (let i = 1; i <= count; i++) {
				const criteria = appData.test.criteria[i] || { min: 0, max: 0 };
				const displayName = getCriteriaDisplayName(system, i);
				
				html += `
					<div class="form-group">
						<label>${displayName}:</label>
						<div style="display: flex; gap: 10px; align-items: center;">
							<input type="number" id="criteria${i}min" 
								   value="${criteria.min}" 
								   min="0" max="100" step="1"
								   class="criteria-input"
								   placeholder="Мин. %">
							<span style="color: #666;">—</span>
							<input type="number" id="criteria${i}max" 
								   value="${criteria.max}" 
								   min="0" max="100" step="1"
								   class="criteria-input"
								   placeholder="Макс. %">
						</div>
					</div>
				`;
			}
			
			return html;
		}

		function renderPointsCriteria(system, count, maxPossible) {
			let html = '';
			
			for (let i = 1; i <= count; i++) {
				const criteria = appData.test.criteria[i] || { min: 0, max: 0 };
				const displayName = getCriteriaDisplayName(system, i);
				
				html += `
					<div class="form-group">
						<label>${displayName}:</label>
						<div style="display: flex; gap: 10px; align-items: center;">
							<input type="number" id="criteria${i}min" 
								   value="${criteria.min}" 
								   min="0" max="${maxPossible}" step="1"
								   class="criteria-input"
								   placeholder="Мин. баллы">
							<span style="color: #666;">—</span>
							<input type="number" id="criteria${i}max" 
								   value="${criteria.max}" 
								   min="0" max="${maxPossible}" step="1"
								   class="criteria-input"
								   placeholder="Макс. баллы">
						</div>
					</div>
				`;
			}
			
			return html;
		}

		function getCriteriaDisplayName(system, level) {
			if (system === 'standard') {
				const names = ['2 (Неудовлетворительно)', '3 (Удовлетворительно)', 
							   '4 (Хорошо)', '5 (Отлично)'];
				return names[level - 1] || `Уровень ${level + 1}`;
			} else if (system === 'five_point') {
				const names = ['1 (Очень плохо)', '2 (Плохо)', '3 (Удовлетворительно)', 
							   '4 (Хорошо)', '5 (Отлично)'];
				return names[level - 1] || `Уровень ${level}`;
			} else {
				return `Уровень ${level}`;
			}
		}
		
		function renderSimplePercentageCriteria(count) {
			let html = '<h4>?? Процентные критерии</h4><div class="criteria-grid">';
			
			for (let i = 1; i <= count; i++) {
				const criteria = appData.test.criteria[i] || { min: 0, max: 0 };
				const levelName = i === 1 ? '2' : i === 2 ? '3' : i === 3 ? '4' : '5';
				
				html += `
					<div class="criteria-item">
						<label>Оценка ${levelName}:</label>
						<input type="number" id="criteria${i}min" placeholder="Мин" 
							   value="${criteria.min}" min="0" max="100" 
							   oninput="updateSimpleCriteria(${i}, 'min', this.value)">
						<input type="number" id="criteria${i}max" placeholder="Макс" 
							   value="${criteria.max}" min="0" max="100"
							   oninput="updateSimpleCriteria(${i}, 'max', this.value)">
					</div>
				`;
			}
			
			html += '</div>';
			return html;
		}
		
		function renderSimplePointsCriteria(count) {
			const maxPossible = appData.tasks.reduce((sum, task) => sum + task.maxScore, 0) || 100;
			
			let html = `<h4>?? Балльные критерии (максимум: ${maxPossible})</h4><div class="criteria-grid">`;
			
			for (let i = 1; i <= count; i++) {
				const criteria = appData.test.criteria[i] || { min: 0, max: 0 };
				const levelName = i === 1 ? '2' : i === 2 ? '3' : i === 3 ? '4' : '5';
				
				html += `
					<div class="criteria-item">
						<label>Оценка ${levelName}:</label>
						<input type="number" id="criteria${i}min" placeholder="Мин" 
							   value="${criteria.min}" min="0" max="${maxPossible}" 
							   oninput="updateSimpleCriteria(${i}, 'min', this.value)">
						<input type="number" id="criteria${i}max" placeholder="Макс" 
							   value="${criteria.max}" min="0" max="${maxPossible}"
							   oninput="updateSimpleCriteria(${i}, 'max', this.value)">
					</div>
				`;
			}
			
			html += '</div>';
			return html;
		}		
		
		function updateSimpleCriteria(level, field, value) {
			if (!appData.test.criteria[level]) {
				appData.test.criteria[level] = { min: 0, max: 0 };
			}
			appData.test.criteria[level][field] = parseInt(value) || 0;
			saveData();
		}
		
		function renderPercentageCriteria() {
			const count = appData.test.criteriaCount;
			const system = appData.test.criteriaSystem;
			
			let labels = [];
			if (system === 'standard') {
				labels = ['2 (Неудовлетворительно)', '3 (Удовлетворительно)', '4 (Хорошо)', '5 (Отлично)'];
			} else if (system === 'five_point') {
				labels = ['1 (Очень плохо)', '2 (Плохо)', '3 (Удовлетворительно)', '4 (Хорошо)', '5 (Отлично)'];
			} else if (system === 'ten_point') {
				labels = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10'];
			} else {
				labels = appData.test.customCriteria.map(c => c.name) || Array.from({length: count}, (_, i) => `Уровень ${i+1}`);
			}
			
			let html = '<h4>?? Настройка процентных критериев</h4>';
			html += '<div class="criteria-grid">';
			
			for (let i = 0; i < count; i++) {
				const label = labels[i] || `Уровень ${i+1}`;
				const min = appData.test.criteria[i+1]?.min || 0;
				const max = appData.test.criteria[i+1]?.max || 100;
				
				html += `
					<div class="criteria-item">
						<label>${label}:</label>
						<div style="display: flex; gap: 5px; align-items: center;">
							<input type="number" 
								   id="criteria${i+1}min" 
								   placeholder="Мин %" 
								   value="${min}" 
								   min="0" max="100"
								   oninput="updatePercentageCriteria(${i+1}, 'min', this.value)">
							<span>-</span>
							<input type="number" 
								   id="criteria${i+1}max" 
								   placeholder="Макс %" 
								   value="${max}" 
								   min="0" max="100"
								   oninput="updatePercentageCriteria(${i+1}, 'max', this.value)">
						</div>
						<div style="margin-top: 5px;">
							<input type="text" 
								   id="criteria${i+1}label" 
								   placeholder="Описание уровня"
								   value="${appData.test.customCriteria[i]?.description || ''}"
								   oninput="updateCriteriaLabel(${i+1}, this.value)"
								   style="width: 100%; font-size: 12px;">
						</div>
					</div>
				`;
			}
			
			html += '</div>';
			return html;
		}

		function renderPercentageCriteria(system, count) {
			let html = '<h4>Настройка критериев (в процентах)</h4>';
			
			for (let i = 1; i <= count; i++) {
				const criteria = appData.test.criteria[i] || { min: 0, max: 0 };
				
				// Для стандартной системы показываем оценки 2-5
				const displayLevel = getDisplayLevel(system, i);
				const description = getLevelDescription(system, i);
				
				html += `
					<div class="form-group">
						<label>${displayLevel} ${description}:</label>
						<div style="display: flex; gap: 10px; align-items: center;">
							<input type="number" id="criteria${i}min" 
								   value="${criteria.min}" 
								   min="0" max="100" step="1"
								   class="criteria-min" 
								   style="flex: 1;"
								   placeholder="Мин. %">
							<span>—</span>
							<input type="number" id="criteria${i}max" 
								   value="${criteria.max}" 
								   min="0" max="100" step="1"
								   class="criteria-max" 
								   style="flex: 1;"
								   placeholder="Макс. %">
						</div>
					</div>
				`;
			}
			
			return html;
		}

		function calculatePercentageRange(min, max, total) {
			if (total === 0) return '';
			const minPercent = Math.round((min / total) * 100);
			const maxPercent = Math.round((max / total) * 100);
			return `(${minPercent}% - ${maxPercent}%)`;
		}

		function renderCustomScaleCriteria() {
			const count = appData.test.criteriaCount;
			
			let html = '<h4>?? Настройка своей шкалы</h4>';
			html += '<p><small>Определите свою систему оценивания</small></p>';
			html += '<div class="criteria-grid">';
			
			for (let i = 0; i < count; i++) {
				const criterion = appData.test.customCriteria[i] || {
					name: `Уровень ${i+1}`,
					min: 0,
					max: 0,
					description: '',
					color: getDefaultColor(i, count)
				};
				
				html += `
					<div class="criteria-item" style="border-left-color: ${criterion.color}">
						<div style="display: flex; align-items: center; gap: 10px; margin-bottom: 5px;">
							<input type="color" 
								   value="${criterion.color}"
								   onchange="updateCriteriaColor(${i}, this.value)"
								   style="width: 30px; height: 30px;">
							<input type="text" 
								   value="${criterion.name}"
								   onchange="updateCriteriaName(${i}, this.value)"
								   placeholder="Название уровня"
								   style="flex: 1;">
						</div>
						
						<div style="margin: 5px 0;">
							<label>Диапазон:</label>
							<div style="display: flex; gap: 5px; align-items: center;">
								<input type="number" 
									   value="${criterion.min}"
									   onchange="updateCustomCriteria(${i}, 'min', this.value)"
									   placeholder="Мин">
								<span>-</span>
								<input type="number" 
									   value="${criterion.max}"
									   onchange="updateCustomCriteria(${i}, 'max', this.value)"
									   placeholder="Макс">
								<select onchange="updateCustomCriteria(${i}, 'type', this.value)" style="flex: 1;">
									<option value="points" ${criterion.type === 'points' ? 'selected' : ''}>баллов</option>
									<option value="percentage" ${criterion.type === 'percentage' ? 'selected' : ''}>%</option>
								</select>
							</div>
						</div>
						
						<div>
							<textarea 
								placeholder="Описание уровня (что означает этот уровень?)"
								onchange="updateCustomCriteria(${i}, 'description', this.value)"
								style="width: 100%; height: 60px; font-size: 12px; margin-top: 5px;">${criterion.description || ''}</textarea>
						</div>
					</div>
				`;
			}
			
			html += '</div>';
			return html;
		}

		function getDefaultColor(index, total) {
			const colors = [
				'#e74c3c', '#f39c12', '#3498db', '#27ae60',
				'#9b59b6', '#e67e22', '#1abc9c', '#d35400'
			];
			return colors[index % colors.length];
		}

		// Функции обновления критериев
		function updatePercentageCriteria(level, field, value) {
			if (!appData.test.criteria[level]) {
				appData.test.criteria[level] = { min: 0, max: 0 };
			}
			appData.test.criteria[level][field] = parseInt(value) || 0;
			saveData();
		}

		function updatePointsCriteria(level, field, value) {
			if (!appData.test.criteria[level]) {
				appData.test.criteria[level] = { min: 0, max: 0 };
			}
			appData.test.criteria[level][field] = parseInt(value) || 0;
			saveData();
		}

		function updateCustomCriteria(index, field, value) {
			if (!appData.test.customCriteria[index]) {
				appData.test.customCriteria[index] = {
					name: `Уровень ${index+1}`,
					min: 0,
					max: 0,
					description: '',
					color: getDefaultColor(index, appData.test.criteriaCount),
					type: 'points'
				};
			}
			appData.test.customCriteria[index][field] = value;
			saveData();
		}

		function updateCriteriaLabel(level, value) {
			if (!appData.test.customCriteria[level-1]) {
				appData.test.customCriteria[level-1] = {
					name: `Уровень ${level}`,
					description: '',
					color: getDefaultColor(level-1, appData.test.criteriaCount)
				};
			}
			appData.test.customCriteria[level-1].description = value;
			saveData();
		}

		function updateCriteriaName(index, value) {
			if (!appData.test.customCriteria[index]) {
				appData.test.customCriteria[index] = {
					name: value,
					min: 0,
					max: 0,
					description: '',
					color: getDefaultColor(index, appData.test.criteriaCount)
				};
			}
			appData.test.customCriteria[index].name = value;
			saveData();
		}

		function updateCriteriaColor(index, value) {
			if (!appData.test.customCriteria[index]) {
				appData.test.customCriteria[index] = {
					name: `Уровень ${index+1}`,
					min: 0,
					max: 0,
					description: '',
					color: value
				};
			}
			appData.test.customCriteria[index].color = value;
			saveData();
			renderCriteriaSettings();
		}

		function updateCustomLevels(value) {
			const levels = value.split(',').map(l => l.trim()).filter(l => l.length > 0);
			appData.test.customCriteria = levels.map((name, index) => ({
				name: name,
				min: 0,
				max: 0,
				description: '',
				color: getDefaultColor(index, levels.length),
				type: 'points'
			}));
			appData.test.criteriaCount = levels.length;
			saveData();
			renderCriteriaSettings();
		}

		// Обновленная функция расчета оценки
		function calculateGradeByPercentage(percentage) {
			const system = appData.test.criteriaSystem;
			const count = appData.test.criteriaCount;
			
			console.log('calculateGradeByPercentage:', { percentage, system, count });
			
			for (let i = 1; i <= count; i++) {
				const criteria = appData.test.criteria[i];
				console.log(`Checking criteria ${i}:`, criteria);
				
				if (criteria && percentage >= criteria.min && percentage <= criteria.max) {
					console.log(`Found in criteria ${i}`);
					
					if (system === 'standard') {
						// Преобразуем 1-4 в 2-5 для стандартной системы
						const grade = i === 1 ? 2 : i + 1;
						console.log('Standard system grade:', grade);
						return grade;
					} else if (system === 'five_point' || system === 'ten_point') {
						console.log('Five/Ten point system grade:', i);
						return i;
					} else if (system === 'custom') {
						const customCriterion = appData.test.customCriteria[i-1];
						const grade = customCriterion ? customCriterion.name : `Уровень ${i}`;
						console.log('Custom system grade:', grade);
						return grade;
					} else {
						console.log('Default grade:', i);
						return i;
					}
				}
			}
			
			// Если не попали ни в один диапазон
			console.log('Not found in any criteria');
			return system === 'standard' ? 2 : '?';
		}

		function calculateGradeByPercentage(percentage) {
			const system = appData.test.criteriaSystem;
			const count = appData.test.criteriaCount;
			
			for (let i = 1; i <= count; i++) {
				const criteria = appData.test.criteria[i];
				if (criteria && percentage >= criteria.min && percentage <= criteria.max) {
					if (system === 'standard') {
						// Преобразуем 1-4 в 2-5 для стандартной системы
						return i === 1 ? 2 : i + 1;
					} else if (system === 'five_point') {
						return i;
					} else if (system === 'ten_point') {
						return i;
					} else {
						// Для пользовательской системы возвращаем название уровня
						const customCriterion = appData.test.customCriteria[i-1];
						return customCriterion ? customCriterion.name : i;
					}
				}
			}
			
			return appData.test.criteriaSystem === 'standard' ? 2 : 1;
		}

		function calculateGradeByPoints(totalScore) {
			const system = appData.test.criteriaSystem;
			const count = appData.test.criteriaCount;
			
			console.log('calculateGradeByPoints:', { totalScore, system, count });
			
			for (let i = 1; i <= count; i++) {
				const criteria = appData.test.criteria[i];
				console.log(`Checking criteria ${i}:`, criteria);
				
				if (criteria && totalScore >= criteria.min && totalScore <= criteria.max) {
					console.log(`Found in criteria ${i}`);
					
					if (system === 'standard') {
						const grade = i === 1 ? 2 : i + 1;
						console.log('Standard system grade:', grade);
						return grade;
					} else if (system === 'five_point' || system === 'ten_point') {
						console.log('Five/Ten point system grade:', i);
						return i;
					} else if (system === 'custom') {
						const customCriterion = appData.test.customCriteria[i-1];
						const grade = customCriterion ? customCriterion.name : `Уровень ${i}`;
						console.log('Custom system grade:', grade);
						return grade;
					} else {
						console.log('Default grade:', i);
						return i;
					}
				}
			}
			
			console.log('Not found in any criteria');
			return system === 'standard' ? 2 : '?';
		}


		function calculateGradeByCustomScale(totalScore, maxPossible) {
			const criteria = appData.test.customCriteria;
			
			if (!criteria || criteria.length === 0) {
				console.log('No custom criteria found');
				return '?';
			}
			
			console.log('calculateGradeByCustomScale:', { totalScore, maxPossible, criteria });
			
			const percentage = maxPossible > 0 ? (totalScore / maxPossible) * 100 : 0;
			console.log('Percentage for custom scale:', percentage);
			
			for (let i = 0; i < criteria.length; i++) {
				const criterion = criteria[i];
				console.log(`Checking custom criterion ${i}:`, criterion);
				
				if (!criterion) continue;
				
				let valueToCheck = totalScore;
				if (criterion.type === 'percentage') {
					valueToCheck = percentage;
				}
				
				console.log(`Value to check for criterion ${i}:`, valueToCheck);
				
				if (valueToCheck >= criterion.min && valueToCheck <= criterion.max) {
					console.log(`Found in custom criterion ${i}:`, criterion.name);
					return criterion.name;
				}
			}
			
			console.log('Not found in any custom criteria');
			return criteria.length > 0 ? criteria[criteria.length-1].name : 'Не определено';
		}

		// НОВАЯ ФУНКЦИЯ: Показ статистики импорта
		function showImportStatistics(newData) {
			const importedStudents = newData.students?.length || 0;
			const importedTasks = newData.tasks?.length || 0;
			const importedErrors = newData.errors?.length || 0;
			
			console.log(`Импортировано: ${importedStudents} учащихся, ${importedTasks} заданий, ${importedErrors} ошибок`);
		}

		// 8. Объединение результатов
		function mergeResults(newData) {
			// 1. Создаем карту учеников: "ФИО" -> Индекс в текущей таблице
			const studentMap = {};
			appData.students.forEach((student, index) => {
				studentMap[student.toLowerCase().trim()] = index;
			});

			// 2. Создаем карту сопоставления заданий (Импорт -> Текущее)
			const taskMapping = new Map();
			
			// Пытаемся сопоставить задания
			newData.tasks.forEach((newTask, newIndex) => {
				// Стратегия 1: Если есть ID (будущая совместимость)
				if (newTask.id) {
					const existingIndex = appData.tasks.findIndex(t => t.id === newTask.id);
					if (existingIndex !== -1) {
						taskMapping.set(newIndex, existingIndex);
						return;
					}
				}

				// Стратегия 2: Строгое сопоставление по индексу и параметрам 
				// (Если структуры тестов идентичны)
				if (appData.tasks[newIndex] && 
					appData.tasks[newIndex].type === newTask.type &&
					appData.tasks[newIndex].maxScore === newTask.maxScore) {
					taskMapping.set(newIndex, newIndex);
					return;
				}

				// Стратегия 3: Поиск похожего задания (для добавленных заданий)
				// Ищем первое подходящее задание, которое еще не было сопоставлено
				const foundIndex = appData.tasks.findIndex((t, i) => 
					!Array.from(taskMapping.values()).includes(i) && // Еще не занято
					t.type === newTask.type && 
					t.maxScore === newTask.maxScore && 
					t.level === newTask.level
				);

				if (foundIndex !== -1) {
					taskMapping.set(newIndex, foundIndex);
				}
			});

			console.log('Карта сопоставления заданий:', taskMapping);

			// 3. Переносим оценки
			newData.students.forEach((studentName, sourceStudentIndex) => {
				const targetStudentIndex = studentMap[studentName.toLowerCase().trim()];
				
				// Если такой ученик найден в текущей таблице
				if (targetStudentIndex !== undefined) {
					const sourceScores = newData.results[sourceStudentIndex] || [];
					
					sourceScores.forEach((score, sourceTaskIndex) => {
						const targetTaskIndex = taskMapping.get(sourceTaskIndex);
						
						// Если мы нашли, куда положить эту оценку
						if (targetTaskIndex !== undefined) {
							const currentScore = appData.results[targetStudentIndex][targetTaskIndex] || 0;
							// Если новая оценка больше 0 или в текущей пусто - обновляем
							// (Логика: не затираем существующие данные нулями, если это не замена)
							if (score > 0 || (currentScore === 0 && score === 0)) {
								appData.results[targetStudentIndex][targetTaskIndex] = score;
							}
						}
					});
				}
			});
		}

		// 9. Корректировка массива результатов
		function adjustResultsArray() {
			const expectedLength = appData.students.length;
			const taskCount = appData.tasks.length;
			
			// Удаляем лишние результаты
			if (appData.results.length > expectedLength) {
				appData.results = appData.results.slice(0, expectedLength);
			}
			
			// Добавляем недостающие результаты
			while (appData.results.length < expectedLength) {
				appData.results.push(new Array(taskCount).fill(0));
			}
			
			// Корректируем длину каждого массива результатов
			appData.results.forEach((studentResults, index) => {
				if (studentResults.length > taskCount) {
					appData.results[index] = studentResults.slice(0, taskCount);
				} else if (studentResults.length < taskCount) {
					const missing = taskCount - studentResults.length;
					for (let i = 0; i < missing; i++) {
						studentResults.push(0);
					}
				}
			});
		}

		// 10. История экспорта/импорта
		function saveExportHistory() {
			const history = JSON.parse(localStorage.getItem('exportHistory') || '[]');
			history.push({
				timestamp: new Date().toISOString(),
				filename: generateExportFilename(),
				subject: appData.test.subject,
				class: appData.test.class,
				studentCount: appData.students.length,
				taskCount: appData.tasks.length
			});
			
			// Храним только последние 20 записей
			localStorage.setItem('exportHistory', JSON.stringify(history.slice(-20)));
		}

		function saveImportHistory(metadata) {
			const history = JSON.parse(localStorage.getItem('importHistory') || '[]');
			history.push({
				timestamp: new Date().toISOString(),
				metadata: metadata,
				subject: appData.test.subject,
				class: appData.test.class
			});
			
			// Храним только последние 20 записей
			localStorage.setItem('importHistory', JSON.stringify(history.slice(-20)));
		}

		// 11. Просмотр истории экспорта/импорта
		function showTransferHistory() {
			const exportHistory = JSON.parse(localStorage.getItem('exportHistory') || '[]');
			const importHistory = JSON.parse(localStorage.getItem('importHistory') || '[]');
			
			let html = `
				<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
					<div>
						<h4>?? История экспорта</h4>
						${exportHistory.length > 0 ? 
							exportHistory.reverse().map(item => `
								<div class="backup-item">
									<strong>${new Date(item.timestamp).toLocaleString()}</strong><br>
									<small>${item.filename}</small><br>
									<small>${item.subject} - ${item.class} (${item.studentCount} уч., ${item.taskCount} зад.)</small>
								</div>
							`).join('') : 
							'<p>Нет истории экспорта</p>'
						}
					</div>
					
					<div>
						<h4>?? История импорта</h4>
						${importHistory.length > 0 ? 
							importHistory.reverse().map(item => `
								<div class="backup-item">
									<strong>${new Date(item.timestamp).toLocaleString()}</strong><br>
									<small>${item.metadata?.subject || item.subject} - ${item.metadata?.class || item.class}</small><br>
									<small>${item.metadata?.exportedAt || ''}</small>
								</div>
							`).join('') : 
							'<p>Нет истории импорта</p>'
						}
					</div>
				</div>
				
				<div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
					<h4>?? Советы по переносу данных</h4>
					<ul>
						<li>Регулярно экспортируйте данные для создания резервных копий</li>
						<li>Используйте облачные хранилища (Google Drive, Яндекс.Диск) для синхронизации</li>
						<li>При импорте выбирайте режим "Объединить" для добавления новых данных</li>
						<li>Проверяйте целостность данных после импорта</li>
					</ul>
				</div>
			`;
			
			showModal('История экспорта и импорта', html);
		}

		// 12. Быстрое меню экспорта/импорта
		function showQuickTransferMenu() {
			const html = `
				<div style="text-align: center; padding: 20px;">
					<h3>?? Перенос данных между устройствами</h3>
					<p>Экспортируйте данные для работы на другом устройстве или создания резервной копии</p>
					
					<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 30px 0;">
						<div style="text-align: center;">
							<div style="font-size: 3em; margin-bottom: 10px;">??</div>
							<h4>Экспорт данных</h4>
							<p>Сохраните все данные в файл для переноса или резервного копирования</p>
							<button class="btn btn-success" onclick="exportToFile()" style="width: 100%;">Экспортировать в файл</button>
							<button class="btn" onclick="showExportOptions()" style="width: 100%; margin-top: 10px;">Дополнительные опции</button>
						</div>
						
						<div style="text-align: center;">
							<div style="font-size: 3em; margin-bottom: 10px;">??</div>
							<h4>Импорт данных</h4>
							<p>Загрузите ранее сохраненные данные из файла</p>
							<button class="btn btn-warning" onclick="importFromFile()" style="width: 100%;">Импортировать из файла</button>
							<button class="btn" onclick="showImportOptions()" style="width: 100%; margin-top: 10px;">Дополнительные опции</button>
						</div>
					</div>
					
					<div style="background: #e8f4fc; padding: 15px; border-radius: 8px; text-align: left;">
						<h4>?? Рекомендации для работы на разных устройствах:</h4>
						<ol>
							<li>На работе: заполните данные и экспортируйте в файл</li>
							<li>Перенесите файл на домашний компьютер (флешка, облако, email)</li>
							<li>Дома: импортируйте файл и продолжите работу</li>
							<li>После завершения работы дома снова экспортируйте данные</li>
							<li>На работе импортируйте обновленные данные</li>
						</ol>
					</div>
				</div>
			`;
			
			showModal('Перенос данных между устройствами', html);
		}

		// 13. Дополнительные опции экспорта
		function showExportOptions() {
			const html = `
				<h3>?? Дополнительные опции экспорта</h3>
				
				<div class="form-group">
					<label>Формат экспорта:</label>
					<select id="exportFormat">
						<option value="json">Полные данные (JSON) - рекомендуется</option>
						<option value="json_min">Минимальные данные (без истории и метаданных)</option>
						<option value="csv">Только результаты (CSV)</option>
					</select>
				</div>
				
				<div class="form-group">
					<label>Что экспортировать:</label>
					<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
						<label><input type="checkbox" id="exportSettings" checked> Настройки теста</label>
						<label><input type="checkbox" id="exportTasks" checked> Задания</label>
						<label><input type="checkbox" id="exportStudents" checked> Учащихся</label>
						<label><input type="checkbox" id="exportResults" checked> Результаты</label>
						<label><input type="checkbox" id="exportErrors" checked> Ошибки</label>
						<label><input type="checkbox" id="exportHistory"> Историю</label>
					</div>
				</div>
				
				<div class="form-group">
					<label>Шифрование данных:</label>
					<input type="password" id="exportPassword" placeholder="Пароль (опционально)" style="width: 100%;">
					<small style="color: #666;">При установке пароля данные будут зашифрованы</small>
				</div>
				
				<button class="btn btn-success" onclick="performCustomExport()">Выполнить экспорт</button>
			`;
			
			showModal('Дополнительные опции экспорта', html);
		}

		// 14. Дополнительные опции импорта
		function showImportOptions(data, fileName) {
			const html = `
				<div style="max-width: 600px;">
					<h3>?? Обнаружен шаблон работы</h3>
					
					<div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0;">
						<h4>${data.test.theme || 'Шаблон'}</h4>
						<p><strong>Тип:</strong> ${workTypes[data.test.workType]?.name || data.test.workType}</p>
						<p><strong>Предмет:</strong> ${data.test.subject || 'Не указан'}</p>
						<p><strong>Заданий:</strong> ${data.tasks.length}</p>
					</div>
					
					<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 20px 0;">
						<div style="background: #fff3cd; padding: 15px; border-radius: 8px; text-align: center; cursor: pointer;"
							 onclick="importAsTemplate('${encodeURIComponent(JSON.stringify(data))}', '${fileName}')">
							<div style="font-size: 2em;">??</div>
							<h5>Импорт как шаблон</h5>
							<p><small>Сохранит структуру заданий и настроек</small></p>
						</div>
						
						<div style="background: #d1ecf1; padding: 15px; border-radius: 8px; text-align: center; cursor: pointer;"
							 onclick="importAsData('${encodeURIComponent(JSON.stringify(data))}')">
							<div style="font-size: 2em;">??</div>
							<h5>Импорт как данные</h5>
							<p><small>Только данные без шаблона</small></p>
						</div>
					</div>
				</div>
			`;
			
			showModal('Выбор типа импорта', html);
		}

		function importAsTemplate(encodedData, fileName) {
			const templateData = {
				file: { name: fileName },
				data: JSON.parse(decodeURIComponent(encodedData))
			};
			
			window.templateFilesData = [templateData];
			selectTemplate(0);
		}

		function importAsData(encodedData) {
			const data = JSON.parse(decodeURIComponent(encodedData));
			showImportConfirmationSimple(data);
		}
		
		// 15. Предпросмотр файла перед импортом
		function previewImportFile() {
			const input = document.createElement('input');
			input.type = 'file';
			input.accept = '.json,.txt,application/json';
			
			input.onchange = function(event) {
				const file = event.target.files[0];
				if (!file) return;
				
				const reader = new FileReader();
				
				reader.onload = function(e) {
					try {
						const content = e.target.result;
						const importedData = JSON.parse(content);
						
						if (validateImportedData(importedData)) {
							showImportPreview(importedData);
						} else {
							showNotification('Невозможно предпросмотреть файл', 'error');
						}
					} catch (error) {
						showNotification('Ошибка при чтении файла', 'error');
					}
				};
				
				reader.readAsText(file);
			};
			
			input.click();
		}

		// 16. Предпросмотр импортируемых данных
		function showImportPreview(importedData) {
			const data = importedData.appData;
			
			let html = `
				<h3>??? Предпросмотр импортируемых данных</h3>
				
				<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 20px 0;">
					<div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
						<h4>?? Настройки теста</h4>
						<p><strong>Предмет:</strong> ${data.test.subject || 'Не указан'}</p>
						<p><strong>Класс:</strong> ${data.test.class || 'Не указан'}</p>
						<p><strong>Тема:</strong> ${data.test.theme || 'Не указана'}</p>
						<p><strong>Тип работы:</strong> ${workTypes[data.test.workType]?.name || data.test.workType || 'Не указан'}</p>
					</div>
					
					<div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">
						<h4>?? Статистика</h4>
						<p><strong>Заданий:</strong> ${data.tasks.length}</p>
						<p><strong>Учащихся:</strong> ${data.students.length}</p>
						<p><strong>Ошибок:</strong> ${data.errors.length}</p>
						<p><strong>Дата:</strong> ${data.test.testDate || 'Не указана'}</p>
					</div>
				</div>
				
				<h4>?? Учащиеся (первые 5):</h4>
				<div style="max-height: 200px; overflow-y: auto; background: #f8f9fa; padding: 10px; border-radius: 6px;">
					<ul>
						${data.students.slice(0, 5).map(student => `<li>${student}</li>`).join('')}
						${data.students.length > 5 ? `<li>... и еще ${data.students.length - 5} учащихся</li>` : ''}
					</ul>
				</div>
				
				<h4 style="margin-top: 20px;">?? Задания (первые 5):</h4>
				<div style="max-height: 200px; overflow-y: auto; background: #f8f9fa; padding: 10px; border-radius: 6px;">
					<ul>
						${data.tasks.slice(0, 5).map(task => `<li>${task.type} (макс. ${task.maxScore} баллов, уровень ${task.level})</li>`).join('')}
						${data.tasks.length > 5 ? `<li>... и еще ${data.tasks.length - 5} заданий</li>` : ''}
					</ul>
				</div>
				
				<div style="margin-top: 20px; background: #fff3cd; padding: 15px; border-radius: 8px;">
					<h4>?? Сравнение с текущими данными</h4>
					<p><strong>Текущие учащиеся:</strong> ${appData.students.length}</p>
					<p><strong>Импортируемые учащиеся:</strong> ${data.students.length}</p>
					<p><strong>Совпадающих имен:</strong> ${countCommonStudents(data.students)}</p>
				</div>
				
				<div style="margin-top: 20px; display: flex; gap: 10px;">
					<button class="btn btn-danger" onclick="hideModal()">Отмена</button>
					<button class="btn btn-success" onclick="confirmImportPreview('${btoa(JSON.stringify(importedData))}')">Продолжить импорт</button>
				</div>
			`;
			
			showModal('Предпросмотр импортируемых данных', html);
		}

		// 17. Вспомогательные функции
		function countCommonStudents(newStudents) {
			const currentStudentsSet = new Set(appData.students);
			return newStudents.filter(student => currentStudentsSet.has(student)).length;
		}

		function confirmImportPreview(encodedData) {
			hideModal();
			setTimeout(() => {
				confirmImport(true, encodedData);
			}, 300);
		}
		let autoBackupInterval = null; // Глобальная переменная для хранения ID таймера
		// 18. Автоматическое резервное копирование
		function setupAutoBackup() {
			// Защита от дублирования слушателя beforeunload
			// (лучше вынести его отдельно, но здесь используем флаг для простоты)
			if (!window.hasBackupListener) {
				window.addEventListener('beforeunload', function() {
					createBackup();
					localStorage.setItem('lastAutoBackup', new Date().toISOString());
				});
				window.hasBackupListener = true;
			}
			
			// Очищаем предыдущий таймер, если он был
			if (autoBackupInterval) {
				clearInterval(autoBackupInterval);
			}
			
			// Запускаем новый
			autoBackupInterval = setInterval(function() {
				if (document.hasFocus()) { 
					createBackup();
					console.log('Авторезервка создана');
				}
			}, 5 * 60 * 1000); // 5 минут
			
			showNotification('Автоматическое резервное копирование включено', 'success');
		}

		// 19. Восстановление из последней резервной копии
		function restoreLastBackup() {
			const backups = Object.keys(localStorage)
				.filter(key => key.startsWith('backup_'))
				.sort()
				.reverse();
			
			if (backups.length > 0) {
				restoreBackup(backups[0]);
			} else {
				showNotification('Резервные копии не найдены', 'warning');
			}
		}

		// ==================== ОБНОВЛЕНИЕ ИНТЕРФЕЙСА ====================

		// 20. Добавляем кнопки в интерфейс
		
		function addTransferButtonsToUI() {
			// Добавляем кнопки в существующие контейнеры
			
			// В раздел экспорта
			const exportTab = document.querySelector('#export .export-buttons');
			if (exportTab) {
				exportTab.innerHTML += `
					<button class="btn" onclick="exportToFile()">?? Экспорт данных в файл</button>
					<button class="btn" onclick="importFromFile()">?? Импорт данных из файла</button>
					<button class="btn" onclick="showQuickTransferMenu()">?? Быстрый перенос</button>
					<button class="btn" onclick="showTransferHistory()">?? История переносов</button>
				`;
			}
			
			// В верхнюю панель или отдельную вкладку
			const tabs = document.querySelector('.tabs');
			if (tabs) {
				const transferTab = document.createElement('button');
				transferTab.className = 'tab-btn';
				transferTab.innerHTML = '?? Перенос данных';
				transferTab.onclick = () => showTab('transfer');
				tabs.appendChild(transferTab);
				
				// Добавляем контент вкладки
				const container = document.querySelector('.container');
				const transferContent = document.createElement('div');
				transferContent.id = 'transfer';
				transferContent.className = 'tab-content';
				transferContent.innerHTML = `
					<h2>?? Перенос данных между устройствами</h2>
					
					<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin: 30px 0;">
						<div class="chart-container" style="text-align: center;">
							<h3>?? Экспорт данных</h3>
							<div style="font-size: 4em; margin: 20px;">??</div>
							<p>Сохраните все данные в файл для работы на другом устройстве или создания резервной копии</p>
							<button class="btn btn-success" onclick="exportToFile()" style="width: 100%; margin: 10px 0;">Экспортировать в файл</button>
							<button class="btn" onclick="showExportOptions()" style="width: 100%;">Дополнительные опции</button>
							
							<div style="margin-top: 30px; text-align: left;">
								<h4>?? Для работы на разных устройствах:</h4>
								<ol>
									<li>Заполните данные на текущем устройстве</li>
									<li>Экспортируйте данные в файл</li>
									<li>Перенесите файл на другое устройство</li>
									<li>Импортируйте данные на новом устройстве</li>
									<li>Повторите процесс в обратном направлении</li>
								</ol>
							</div>
						</div>
						
						<div class="chart-container" style="text-align: center;">
							<h3>?? Импорт данных</h3>
							<div style="font-size: 4em; margin: 20px;">??</div>
							<p>Загрузите ранее сохраненные данные из файла для продолжения работы</p>
							<button class="btn btn-warning" onclick="importFromFile()" style="width: 100%; margin: 10px 0;">Импортировать из файла</button>
							<button class="btn" onclick="showImportOptions()" style="width: 100%;">Дополнительные опции</button>
							
							<div style="margin-top: 30px; text-align: left;">
								<h4>?? Рекомендации:</h4>
								<ul>
									<li>Регулярно создавайте резервные копии</li>
									<li>Используйте облачные хранилища для синхронизации</li>
									<li>Проверяйте данные после импорта</li>
									<li>Храните несколько версий файлов</li>
								</ul>
							</div>
						</div>
					</div>
					
					<div class="chart-container">
						<h3>?? Быстрые действия</h3>
						<div style="display: flex; gap: 10px; flex-wrap: wrap;">
							<button class="btn" onclick="showTransferHistory()">?? Показать историю</button>
							<button class="btn" onclick="restoreLastBackup()">?? Восстановить последнюю резервную копию</button>
							<button class="btn" onclick="setupAutoBackup()">? Настроить авторезервку</button>
							<button class="btn" onclick="showBackupManagement()">??? Управление резервными копиями</button>
						</div>
					</div>
					
					<div class="chart-container">
						<h3>?? Информация о текущих данных</h3>
						<div class="kpi-grid">
							<div class="kpi-card">
								<div class="kpi-value">${appData.students.length}</div>
								<div class="kpi-label">Учащихся</div>
							</div>
							<div class="kpi-card">
								<div class="kpi-value">${appData.tasks.length}</div>
								<div class="kpi-label">Заданий</div>
							</div>
							<div class="kpi-card">
								<div class="kpi-value">${appData.errors.length}</div>
								<div class="kpi-label">Ошибок</div>
							</div>
							<div class="kpi-card">
								<div class="kpi-value">${new Date().toLocaleDateString()}</div>
								<div class="kpi-label">Текущая дата</div>
							</div>
						</div>
					</div>
				`;
				
				// Добавляем после последней существующей вкладки
				const lastTab = document.querySelector('.tab-content:last-of-type');
				if (lastTab) {
					lastTab.parentNode.insertBefore(transferContent, lastTab.nextSibling);
				} else {
					container.appendChild(transferContent);
				}
			}
		}


		// 21. Инициализация при загрузке
		document.addEventListener('DOMContentLoaded', function() {
			// Добавляем кнопки в интерфейс
			//setTimeout(() => {
			//	addTransferButtonsToUI();
			//}, 1000);
			//setTimeout(() => {
			//	addDebugButtons();
			//}, 1000);
			// Добавляем кнопки с задержкой (чтобы DOM успел загрузиться)
			setTimeout(() => {
				addImportExportButtons();
			}, 500);
			
			
			    // Проверяем, есть ли сохраненные данные
			setTimeout(() => {
				if (appData.students.length === 0 && appData.tasks.length === 0) {
					// Предлагаем загрузить пример или импортировать
					console.log('Система готова. Используйте кнопки импорта/экспорта.');
				}
			}, 1000);
			
			// Настраиваем авторезервку
			setupAutoBackup();
			
			// Проверяем, есть ли несохраненные данные
			checkForUnsavedData();
		});
		// Просто скопируйте эти 2 функции если ничего не работает:
		function workingExport() {
			const data = JSON.stringify(appData, null, 2);
			const blob = new Blob([data], { type: 'application/json' });
			const url = URL.createObjectURL(blob);
			const a = document.createElement('a');
			a.href = url;
			a.download = 'данные.json';
			a.click();
			showNotification('Экспорт завершен', 'success');
		}
		
		// 14. ЭКСТРЕННЫЙ ЭКСПОРТ/ИМПОРТ (самый простой вариант)
		function emergencyExport() {
			// Создаем простой текстовый формат для экстренного экспорта
			let exportText = `ЭКСТРЕННЫЙ ЭКСПОРТ ДАННЫХ\n`;
			exportText += `Предмет: ${appData.test.subject}\n`;
			exportText += `Класс: ${appData.test.class}\n`;
			exportText += `Дата: ${new Date().toLocaleString()}\n\n`;
			
			exportText += `УЧАЩИЕСЯ И РЕЗУЛЬТАТЫ:\n`;
			appData.students.forEach((student, index) => {
				const totalScore = appData.results[index]?.reduce((sum, score) => sum + score, 0) || 0;
				const grade = calculateGrade(totalScore);
				exportText += `${student}: ${totalScore} баллов (оценка ${grade})\n`;
			});
			
			const blob = new Blob([exportText], { type: 'text/plain' });
			const url = URL.createObjectURL(blob);
			const a = document.createElement('a');
			a.href = url;
			a.download = `экспорт_${new Date().toISOString().slice(0, 10)}.txt`;
			a.click();
			URL.revokeObjectURL(url);
			
			showNotification('Экстренный экспорт выполнен', 'success');
		}


		function emergencyImport() {
			if (confirm('Это сбросит все текущие данные. Продолжить?')) {
				loadStandardSample();
			}
		}

		// Добавляем экстренные кнопки в консоль для отладки
		console.log('Доступные функции:');
		console.log('- simpleExport() - экспорт данных');
		console.log('- simpleImport() - импорт данных');
		console.log('- emergencyExport() - экстренный экспорт');
		console.log('- emergencyImport() - экстренный импорт');
		console.log('- createSampleFile() - создать пример файла');		
		
		
		// УТИЛИТАРНЫЕ ФУНКЦИИ для безопасной кодировки
		function safeEncode(data) {
			try {
				// Преобразуем в строку и кодируем
				const str = JSON.stringify(data);
				// Используем кодировку URI для безопасной передачи
				return encodeURIComponent(str);
			} catch (error) {
				console.error('Ошибка при кодировании данных:', error);
				return '';
			}
		}
		
		function safeDecode(encodedData) {
			try {
				// Декодируем из URI
				const str = decodeURIComponent(encodedData);
				return JSON.parse(str);
			} catch (error) {
				console.error('Ошибка при декодировании данных:', error);
				return null;
			}
		}

		function workingImport() {
			const input = document.createElement('input');
			input.type = 'file';
			input.accept = '.json';
			input.onchange = function(e) {
				const file = e.target.files[0];
				const reader = new FileReader();
				reader.onload = function(e) {
					try {
						appData = JSON.parse(e.target.result);
						saveData();
						renderAll();
						showNotification('Импорт завершен', 'success');
					} catch (err) {
						showNotification('Ошибка: ' + err.message, 'error');
					}
				};
				reader.readAsText(file);
			};
			input.click();
		}
		// 22. Проверка несохраненных данных
		function checkForUnsavedData() {
			const lastSave = localStorage.getItem('lastAutoSave');
			const lastBackup = localStorage.getItem('lastAutoBackup');
			
			if (lastSave && lastBackup) {
				const saveTime = new Date(lastSave);
				const backupTime = new Date(lastBackup);
				const now = new Date();
				
				// Если прошло больше 30 минут с последнего сохранения
				if ((now - saveTime) > 30 * 60 * 1000) {
					showNotification('Рекомендуется создать резервную копию данных', 'warning');
				}
			}
		}

		// 23. Управление резервными копиями
		function showBackupManagement() {
			const backups = Object.keys(localStorage)
				.filter(key => key.startsWith('backup_'))
				.map(key => ({
					key,
					data: JSON.parse(localStorage.getItem(key)),
					size: JSON.stringify(localStorage.getItem(key)).length
				}))
				.sort((a, b) => new Date(b.data.timestamp) - new Date(a.data.timestamp));
			
			let html = `
				<h3>??? Управление резервными копиями</h3>
				<p>Всего резервных копий: ${backups.length}</p>
				
				<div style="max-height: 400px; overflow-y: auto; margin: 20px 0;">
					${backups.map((backup, index) => `
						<div class="backup-item" style="display: flex; justify-content: space-between; align-items: center;">
							<div>
								<strong>${backup.data.timestamp}</strong><br>
								<small>${backup.data.data.test.subject} - ${backup.data.data.test.class}</small><br>
								<small>${Math.round(backup.size / 1024)} КБ</small>
							</div>
							<div style="display: flex; gap: 5px;">
								<button class="btn btn-sm" onclick="restoreBackup('${backup.key}')">Восстановить</button>
								<button class="btn btn-sm btn-danger" onclick="deleteBackup('${backup.key}')">Удалить</button>
								<button class="btn btn-sm" onclick="exportBackup('${backup.key}')">Экспорт</button>
							</div>
						</div>
					`).join('')}
				</div>
				
				<div style="display: flex; gap: 10px; margin-top: 20px;">
					<button class="btn btn-danger" onclick="deleteAllBackups()">??? Удалить все копии</button>
					<button class="btn" onclick="createBackup()">? Создать новую копию</button>
					<button class="btn" onclick="exportAllBackups()">?? Экспортировать все</button>
				</div>
			`;
			
			showModal('Управление резервными копиями', html);
		}
		// Добавьте в конец скрипта
		document.addEventListener('DOMContentLoaded', function() {
			console.log('DOM загружен, инициализируем графики...');
			setTimeout(updateVisualization, 1000);
		});
		// 24. Дополнительные функции управления
		function deleteBackup(key) {
			if (confirm('Удалить эту резервную копию?')) {
				localStorage.removeItem(key);
				showBackupManagement();
				showNotification('Резервная копия удалена', 'success');
			}
		}

		function deleteAllBackups() {
			if (confirm('Удалить ВСЕ резервные копии? Это действие нельзя отменить.')) {
				Object.keys(localStorage)
					.filter(key => key.startsWith('backup_'))
					.forEach(key => localStorage.removeItem(key));
				showBackupManagement();
				showNotification('Все резервные копии удалены', 'success');
			}
		}

		function exportBackup(key) {
			const backup = localStorage.getItem(key);
			const blob = new Blob([backup], { type: 'application/json' });
			const url = URL.createObjectURL(blob);
			
			const a = document.createElement('a');
			a.href = url;
			a.download = key + '.json';
			a.click();
			
			URL.revokeObjectURL(url);
		}

		function exportAllBackups() {
			const allBackups = {};
			Object.keys(localStorage)
				.filter(key => key.startsWith('backup_'))
				.forEach(key => {
					allBackups[key] = JSON.parse(localStorage.getItem(key));
				});
			
			const dataStr = JSON.stringify(allBackups, null, 2);
			const blob = new Blob([dataStr], { type: 'application/json' });
			const url = URL.createObjectURL(blob);
			
			const a = document.createElement('a');
			a.href = url;
			a.download = `все_резервные_копии_${new Date().toISOString().split('T')[0]}.json`;
			a.click();
			
			URL.revokeObjectURL(url);
			showNotification('Все резервные копии экспортированы', 'success');
		}
		
		// Анализ общего уровня функциональной грамотности
		function analyzeOverallLiteracyLevel(percentage) {
			if (percentage >= 80) {
				return {
					level: 'Продвинутый',
					title: 'Высокий уровень функциональной грамотности',
					description: 'Учащиеся демонстрируют уверенное применение знаний в реальных жизненных ситуациях.',
					interpretation: 'Компетенции сформированы на уровне, позволяющем успешно решать сложные жизненные задачи'
				};
			} else if (percentage >= 60) {
				return {
					level: 'Базовый',
					title: 'Достаточный уровень функциональной грамотности',
					description: 'Учащиеся владеют основными компетенциями для повседневной жизни.',
					interpretation: 'Сформированы ключевые навыки, требующие дальнейшего развития и автоматизации'
				};
			} else if (percentage >= 40) {
				return {
					level: 'Ограниченный',
					title: 'Недостаточный уровень функциональной грамотности',
					description: 'Обнаружены значительные пробелы в применении знаний на практике.',
					interpretation: 'Требуется целенаправленная работа по формированию практических компетенций'
				};
			} else {
				return {
					level: 'Начальный',
					title: 'Критически низкий уровень функциональной грамотности',
					description: 'Учащиеся испытывают серьезные трудности в применении знаний.',
					interpretation: 'Необходима системная работа по развитию всех видов функциональной грамотности'
				};
			}
		}
		function generateOGESpecializedReport() {
			// Сохраняем текущее содержимое анализа
			updateGIAnalysis();
			const analysisContent = document.getElementById('specializedAnalysis').innerHTML;
			
			return `
				<h3>?? Анализ подготовки к ОГЭ</h3>
				<p>Специализированный анализ выполнения заданий основного государственного экзамена с рекомендациями по подготовке.</p>
				
				<div class="stats-grid">
					<div class="stat-card">
						<div class="stat-value">${calculateAverageScore().toFixed(1)}</div>
						<div class="stat-label">Средний балл</div>
					</div>
					<div class="stat-card">
						<div class="stat-value">${calculateSuccessRate().toFixed(1)}%</div>
						<div class="stat-label">Успеваемость</div>
					</div>
					<div class="stat-card">
						<div class="stat-value">${calculateQualityRate().toFixed(1)}%</div>
						<div class="stat-label">Качество</div>
					</div>
					<div class="stat-card">
						<div class="stat-value">${appData.students.length}</div>
						<div class="stat-label">Учащихся</div>
					</div>
				</div>
				
				${analysisContent}
				
				<div class="recommendation-card" style="margin-top: 20px;">
					<h4>?? План подготовки к ОГЭ</h4>
					<ul>
						<li>Еженедельные тренировочные работы в формате ОГЭ</li>
						<li>Анализ типичных ошибок и работа над ними</li>
						<li>Индивидуальные образовательные маршруты для отстающих</li>
						<li>Тренировка заполнения бланков ответов</li>
						<li>Пробный экзамен за 1 месяц до ОГЭ</li>
					</ul>
				</div>
			`;
		}

        function generateEGESpecializedReport() {
            return `<h3>?? Анализ подготовки к ЕГЭ</h3>
            <p>Специализированный анализ выполнения заданий единого государственного экзамена.</p>
            ${document.getElementById('specializedAnalysis').innerHTML}`;
        }

        function generateStandardSpecializedReport() {
            return `<h3>?? Педагогический анализ</h3>
            <p>Комплексный анализ образовательных результатов с акцентом на педагогические аспекты.</p>
            ${document.getElementById('taxonomyAnalysis').innerHTML}
            ${document.getElementById('errorsAnalysis').innerHTML}`;
        }

        function generateSpecializedReportHTML(title, description, content) {
            return `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>${title}</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; }
        .header { text-align: center; margin-bottom: 40px; padding-bottom: 20px; border-bottom: 2px solid #3498db; }
        .section { margin: 30px 0; }
		/* Фикс для радарной диаграммы */
		#literacyRadarChart {
			max-height: 400px !important;
			width: 100% !important;
			margin: 0 auto;
		}

		/* Контейнер для графика */
		.chart-container {
			position: relative;
			height: 400px;
			min-height: 400px;
		}
    </style>
</head>
<body>
    <div class="header">
        <h1>${title}</h1>
        <h2>${appData.test.subject}, ${appData.test.class}</h2>
        <p>${description}</p>
    </div>
    ${content}
</body>
</html>`;
        }

        // Отчет для учителя
        function exportForTeacher() {
            const reportContent = generateTeacherReport();
            const blob = new Blob([reportContent], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `отчет_для_учителя_${appData.test.subject}_${new Date().toLocaleDateString()}.html`;
            a.click();
            URL.revokeObjectURL(url);
            showNotification("Отчет для учителя экспортирован", "success");
        }

        function generateTeacherReport() {
            const totalScores = appData.results.map(scores => scores.reduce((sum, score) => sum + score, 0));
            const grades = totalScores.map(score => calculateGrade(score));
            const avgScore = totalScores.reduce((sum, score) => sum + score, 0) / totalScores.length;
            const successRate = (grades.filter(grade => grade >= 3).length / grades.length * 100);
            const qualityRate = (grades.filter(grade => grade >= 4).length / grades.length * 100);
            
            const difficultTasks = appData.tasks
                .map((task, index) => ({ task, index, completion: calculateTaskCompletion(index) }))
                .filter(t => t.completion < 60)
                .slice(0, 5);
            
            const atRiskStudents = appData.students
                .map((student, index) => ({
                    name: student,
                    score: totalScores[index],
                    grade: grades[index],
                    percentage: (totalScores[index] / appData.tasks.reduce((sum, task) => sum + task.maxScore, 0)) * 100
                }))
                .filter(s => s.grade === 2)
                .slice(0, 10);
            
            return `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Отчет для учителя - ${appData.test.theme}</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 40px; 
            line-height: 1.6;
            color: #333;
        }
        .header { 
            text-align: center; 
            margin-bottom: 40px; 
            padding-bottom: 20px; 
            border-bottom: 2px solid #3498db; 
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            padding: 30px;
            border-radius: 10px;
        }
        .section { 
            margin: 30px 0; 
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .stats-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); 
            gap: 15px; 
            margin: 20px 0; 
        }
        .stat-card { 
            background: white; 
            padding: 20px; 
            border-radius: 8px; 
            text-align: center; 
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
            border-left: 4px solid #3498db;
        }
        .stat-value { 
            font-size: 2em; 
            font-weight: bold; 
            margin: 10px 0; 
            color: #2c3e50;
        }
        .stat-label { 
            font-size: 0.9em; 
            color: #7f8c8d;
        }
        .alert-card {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 10px 0;
            border-radius: 6px;
        }
        .success-card {
            background: #d4edda;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 10px 0;
            border-radius: 6px;
        }
        .task-list {
            background: white;
            padding: 15px;
            border-radius: 6px;
            margin: 10px 0;
        }
        .student-list {
            background: white;
            padding: 15px;
            border-radius: 6px;
            margin: 10px 0;
        }
		/* Фикс для радарной диаграммы */
		#literacyRadarChart {
			max-height: 400px !important;
			width: 100% !important;
			margin: 0 auto;
		}

		/* Контейнер для графика */
		.chart-container {
			position: relative;
			height: 400px;
			min-height: 400px;
		}
    </style>
</head>
<body>
    <div class="header">
        <h1>?? Отчет для учителя</h1>
        <h2>${appData.test.subject}, ${appData.test.class}</h2>
        <p><strong>Тема работы:</strong> ${appData.test.theme}</p>
        <p><strong>Дата проведения:</strong> ${new Date(appData.test.testDate).toLocaleDateString()}</p>
    </div>
    
    <div class="section">
        <h3>?? Ключевые показатели</h3>
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-value">${avgScore.toFixed(1)}</div>
                <div class="stat-label">Средний балл</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">${successRate.toFixed(1)}%</div>
                <div class="stat-label">Успеваемость</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">${qualityRate.toFixed(1)}%</div>
                <div class="stat-label">Качество знаний</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">${appData.test.presentStudents}</div>
                <div class="stat-label">Писало работу</div>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h3>?? Основные выводы</h3>
        ${successRate >= 70 ? 
            '<div class="success-card"><strong>? Положительная динамика:</strong> Большинство учащихся успешно освоили материал.</div>' :
            '<div class="alert-card"><strong>?? Требуется внимание:</strong> Необходима коррекционная работа с классом.</div>'
        }
        
        ${difficultTasks.length > 0 ? `
            <div class="alert-card">
                <strong>?? Проблемные зоны:</strong>
                <ul>
                    ${difficultTasks.map(task => 
                        `<li>Задание ${task.index + 1} "${task.task.type}" - ${task.completion.toFixed(1)}% выполнения</li>`
                    ).join('')}
                </ul>
            </div>
        ` : '<div class="success-card"><strong>? Все задания усвоены хорошо</strong></div>'}
    </div>
    
    <div class="section">
        <h3>?? Учащиеся, требующие внимания</h3>
        ${atRiskStudents.length > 0 ? `
            <div class="student-list">
                <p><strong>Учащиеся с неудовлетворительными результатами (${atRiskStudents.length} чел.):</strong></p>
                <ul>
                    ${atRiskStudents.map(student => 
                        `<li>${student.name} - ${student.score} баллов (${student.percentage.toFixed(1)}%)</li>`
                    ).join('')}
                </ul>
            </div>
        ` : '<div class="success-card"><strong>? Нет учащихся с неудовлетворительными результатами</strong></div>'}
    </div>
    
    <div class="section">
        <h3>?? Рекомендации</h3>
        <div class="task-list">
            <p><strong>Мероприятия на ближайшую перспективу:</strong></p>
            <ul>
                <li>Провести работу над ошибками в течение недели</li>
                <li>Организовать дополнительные консультации для отстающих учащихся</li>
                ${difficultTasks.length > 0 ? '<li>Разработать дополнительные упражнения по проблемным темам</li>' : ''}
                <li>Скорректировать план урока с учетом выявленных трудностей</li>
                <li>Проинформировать родителей о результатах работы</li>
            </ul>
        </div>
    </div>

    <div style="text-align: center; margin-top: 40px; color: #7f8c8d; font-size: 0.9em;">
        <p>Отчет сгенерирован ${new Date().toLocaleDateString()}</p>
        <p>Система анализа образовательных результатов</p>
    </div>
	<div id="globalError" style="display: none; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: #e74c3c; color: white; padding: 15px; border-radius: 8px; z-index: 9999; box-shadow: 0 5px 15px rgba(0,0,0,0.3);">
    ?? Произошла ошибка. Пожалуйста, обновите страницу.
</div>
</body>
</html>`;
        }

        function exportJSON() {
            const dataStr = JSON.stringify(appData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `данные_анализа_${new Date().toLocaleDateString()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            showNotification("Данные экспортированы в JSON", "success");
        }

        // Обработчик изменения размера окна
        window.addEventListener('resize', function() {
            if (document.getElementById('visualization').classList.contains('active')) {
                setTimeout(() => {
                    updateCharts();
                    updateSolvabilityChart();
                }, 300);
            }
        });

        // Закрытие модального окна по клику на оверлей
        document.getElementById('modalOverlay').addEventListener('click', function(e) {
            if (e.target === this) {
                hideModal();
            }
        });

    </script>
</body>
</html>